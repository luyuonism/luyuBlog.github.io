<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lu Ruijie&#39;s Personal Homepage</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luyuonism.github.io/"/>
  <updated>2019-11-06T06:01:32.325Z</updated>
  <id>https://luyuonism.github.io/</id>
  
  <author>
    <name>ruijielu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>django配置  STATIC_ROOT</title>
    <link href="https://luyuonism.github.io/2019/11/05/django-STATIC_ROOT/"/>
    <id>https://luyuonism.github.io/2019/11/05/django-STATIC_ROOT/</id>
    <published>2019-11-05T02:25:49.382Z</published>
    <updated>2019-11-06T06:01:32.325Z</updated>
    
    <content type="html"><![CDATA[<p>关于django静态文件的配置说明————STATIC_ROOT和STATIC_URL以及STATICFILES_DIRS</p><a id="more"></a><h3 id="MEDIA-ROOT："><a href="#MEDIA-ROOT：" class="headerlink" title="MEDIA_ROOT："></a>MEDIA_ROOT：</h3><p>在说STATIC_ROOT之前，必须得提一下MEDIA_ROOT，在配置中，当你需要在你的项目中按照你心中的目录来存储文件时，MEDIA_ROOT是必不可少的。</p><pre><code class="python"># 文件存储配置MEDIA_URL = &#39;/media/&#39;MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media&#39;) # 默认根目录</code></pre><p>通过在setting.py文件中添加如上设置，就会设置好你需要放置文件的默认根目录</p><pre><code class="python">image = models.ImageField(upload_to=&quot;image/%Y/%m&quot;, default=u&quot;image/default.png&quot;, max_length=100)</code></pre><p>上面是一个数据库模型的字段代码，当你使用upload_to这个属性的时候，django会自动解析，生成相对路径，保存在MEDIA_ROOT设置的根目录下</p><h3 id="STATIC-ROOT"><a href="#STATIC-ROOT" class="headerlink" title="STATIC_ROOT:"></a>STATIC_ROOT:</h3><p>那为什么要使用STATIC_ROOT呢，是因为当你设置中DEBUG为True时，django会自动为你静态文件代理，不过当DEBUG为False时，意味着你要进入生产环境，那么，你就必须使用STATIC_ROOT来指明你的静态文件在哪里，就像MEDIA_ROOT一样。</p><pre><code class="python">STATIC_URL = &#39;/static/&#39;    STATICFILES_DIRS = [    os.path.join(BASE_DIR, &quot;static&quot;)]STATIC_ROOT = os.path.join(BASE_DIR, &quot;static&quot;)</code></pre><p>在setting.py文件中添加上面代码，并且在urls.py中添加下面代码即可</p><pre><code class="python"># 配置静态文件代理    url(r&#39;^static/(?P&lt;path&gt;.*)$&#39;, serve, {&#39;document_root&#39;: STATIC_ROOT}),</code></pre><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>详细介绍STATIC_ROOT, <a href="https://blog.csdn.net/alxandral_brother/article/details/52202270" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于django静态文件的配置说明————STATIC_ROOT和STATIC_URL以及STATICFILES_DIRS&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="django" scheme="https://luyuonism.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>python f-string式格式化</title>
    <link href="https://luyuonism.github.io/2019/06/05/python-f-string/"/>
    <id>https://luyuonism.github.io/2019/06/05/python-f-string/</id>
    <published>2019-06-04T16:00:00.000Z</published>
    <updated>2019-11-06T01:50:21.156Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>interview</title>
    <link href="https://luyuonism.github.io/2018/07/05/interview/"/>
    <id>https://luyuonism.github.io/2018/07/05/interview/</id>
    <published>2018-07-05T04:03:43.000Z</published>
    <updated>2019-11-10T10:07:56.823Z</updated>
    
    <content type="html"><![CDATA[<p>python 学习之路</p><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with语句实质是上下文管理。</p><ol><li>上下文管理协议。包含方法__enter__()和__exit__(),支持该协议对象要实现这两个方法。</li><li>上下文管理器，定义执行with语句时要建立的运行时上下文，负责执行with语句块上下文中的进入与退出操作。</li><li>进入上下文的时候执行__enter__方法，如果设置as var语句，var变量接受__enter__方法返回值。</li><li>如果运行时发生了异常，就退出上下文管理器。调用管理器__exit__方法。</li></ol><p>但是with本身并没有异常捕获的功能，同时如果发生了运行时异常，它照样可以关闭文件释放资源。</p><p>应用场景: 1、文件操作。2、进程线程之间互斥对象。3、支持上下文其他对象</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器</li><li>当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象</li><li>当你使用for进行迭代的时候，函数中的代码才会执行</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://i.loli.net/2019/11/06/aGwNEdLhom9B4QM.png" alt="常用数据类型" title="常用数据类型"></p><h3 id="type-和-instance"><a href="#type-和-instance" class="headerlink" title="type() 和 instance()"></a>type() 和 instance()</h3><ul><li>type() 不会认为子类是一种父类类型，不考虑继承关系。</li><li>isinstance() 会认为子类是一种父类类型，考虑继承关系。<br>如果要判断两个类型是否相同推荐使用 isinstance()。</li></ul><pre><code class="python">a = 2print(isinstance(a,int))   # Trueprint(isinstance(a,str))   # Falseclass A:    passclass B(A):    passprint(&quot;isinstance&quot;,isinstance(A(),A))   # isinstance Trueprint(&quot;type&quot;,type(A())  == A)    # type Trueprint(&#39;isinstance&#39;,isinstance(B(),A) )   # isinstance Trueprint(&#39;type&#39;,type(B()) == A)     #  type False</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="和"><a href="#和" class="headerlink" title="// 和 %"></a>// 和 %</h3><pre><code class="python">&gt;&gt;&gt; 13 // 34&gt;&gt;&gt; -13 // 3-5&gt;&gt;&gt; 13 // -3-5&gt;&gt;&gt; -13 // -34&gt;&gt;&gt; 13 % 31&gt;&gt;&gt; -13 % 32&gt;&gt;&gt; 13 % -3-2&gt;&gt;&gt; -13 % -3-1</code></pre><p><strong>如果：x // y = a，x % y = b</strong><br><strong>那么：x = a * y + b</strong><br>13 // -3 = -5, 13 % -3 = -2<br>13 = (-5) * (-3) + (-2)</p><h3 id="gt-gt-和-lt-lt"><a href="#gt-gt-和-lt-lt" class="headerlink" title="&gt;&gt; 和 &lt;&lt;"></a>&gt;&gt; 和 &lt;&lt;</h3><p>‘&gt;&gt;’ 右移  除2<br>‘&lt;&lt;’ 左移  乘2</p><h3 id="math-isclose-a-b-rel-tol-1e-9"><a href="#math-isclose-a-b-rel-tol-1e-9" class="headerlink" title="math.isclose(a, b, rel_tol=1e-9)"></a>math.isclose(a, b, rel_tol=1e-9)</h3><p>浮点数相等的比较，由于存在精度的关系，不能使用==判断，要用math模块的isclose方法。</p><pre><code class="python">&gt;&gt;&gt; import math&gt;&gt;&gt; math.isclose(1.0, 1.0000000001)True&gt;&gt;&gt; math.isclose(1.0, 1.0000000001, rel_tol=1e-10)False</code></pre><h3 id="和-is"><a href="#和-is" class="headerlink" title="== 和 is"></a>== 和 is</h3><p>is 判断的是a对象是否是b对象，是通过id来判断<br>== 判断的是a对象的值和b对象的值和类型是否相等，是通过value和type来判断</p><pre><code class="python">&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1.0&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; id(a)12777000&gt;&gt;&gt; id(b)14986000&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; id(a)12777000&gt;&gt;&gt; id(b)12777000</code></pre><h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><p>break可以提前结束一层循环，continue可以提前结束一次循环。</p><h2 id="循环else"><a href="#循环else" class="headerlink" title="循环else"></a>循环else</h2><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p><code>assert 要判断表达式, &#39;字符串&#39;</code></p><pre><code class="python">i = 0mySum = 0while i &lt; 5:    mySum += i    i += 1assert mySum == 15, &#39;mySum不等于15&#39;print(&#39;mySum = {}&#39;.format(mySum))</code></pre><p>输出结果：</p><pre><code>Traceback (most recent call last):  File &quot;d:/Projects/ch04/4.17-assert.py&quot;, line 9, in &lt;module&gt;    assert mySum == 15, &#39;mySum不等于15&#39;AssertionError: mySum不等于15</code></pre><p><strong>当判断的表达式为真时，assert语句不做任何动作，当表达式为假时，会触发异常，并将字符串内容输出。字符串可以省略。</strong></p><h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="find-和-index"><a href="#find-和-index" class="headerlink" title="find 和 index"></a>find 和 index</h3><p>find: 查找字符串，严格区分大小写，返回值为字符串第一次出现所在的索引，后面的不管；未找到字符串，返回-1<br>index: 基本等同于find，区别：如果index查找不到，给出异常错误。</p><h3 id="列表的添加-插入-删除"><a href="#列表的添加-插入-删除" class="headerlink" title="列表的添加/插入/删除"></a>列表的添加/插入/删除</h3><pre><code class="python">mylist = [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;]mylist.append(&#39;defg&#39;)  # [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;, &#39;defg&#39;]# append 添加，把添加内容直接作为元素添加appendlist = [&#39;aaa&#39;, &#39;bbb&#39;]mylist.append(appendlist)   # [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;, [&#39;aaa&#39;, &#39;bbb&#39;]]# extend 添加，把列表拆成元素添加extendlist = [&#39;aaa&#39;, &#39;bbb&#39;]mylist.extend(extendlist)   # [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;, &#39;aaa&#39;, &#39;bbb&#39;]# insert 在index位置前插入元素mylist.insert(1, &#39;defg&#39;)    # [&#39;abcd&#39;, &#39;defg&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;]# insert对于列表的插入，等同于append做法mylist.insert(1, appendlist)   # [&#39;abcd&#39;, [&#39;aaa&#39;, &#39;bbb&#39;], &#39;zhangsan&#39;, &#39;jiangning&#39;]# 对列表元素进行修改，使用索引定位到元素，直接赋值修改mylist[1] = &#39;lisi&#39;  [&#39;abcd&#39;, &#39;lisi&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;]# del删除给定下标的元素mylist = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;]del(mylist[1])   # [&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;]# pop删除最后一个或指定索引的元素mylist.pop()  # [&#39;a&#39;, &#39;c&#39;, &#39;a&#39;]# remove 删除指定值的元素# 一次只删除一个mylist.remove(&#39;a&#39;)    # [&#39;c&#39;, &#39;a&#39;]mylist.remove(&#39;a&#39;)    # [&#39;c&#39;]</code></pre><h3 id="sort-sorted-reverse-reversed"><a href="#sort-sorted-reverse-reversed" class="headerlink" title="sort()  sorted()  reverse()  reversed()"></a>sort()  sorted()  reverse()  reversed()</h3><ul><li><p>sort方法和sorted函数：排序使用<br>sort方法: 列表对象有一个sort()方法，实现将原列表进行一个排序，然后return，因为python 默认return返回一个None,所以非要将lst.sort()指向一个变量，那么这个变量值就是None<br><img src="https://i.loli.net/2019/11/06/uDiWtI1LMxeofac.png" alt="sort方法" title="sort方法"><br>sorted函数: sorted()是一个函数，即面向过程，将排序过程进行一个封装，按照不同的对象进行处理，不同的对象最后统一都是以列表的形式返回数据，即 return a_lst<br><img src="https://i.loli.net/2019/11/06/gCmXtq2okPy1McI.png" alt="sorted函数" title="sorted函数"></p></li><li><p>reverse方法和reversed函数：反转序列使用<br>reverse方法: 实现与sort()方法基本一致，功能的差异是对一个列表进行反转然后return，同样因为python 默认return返回一个None,所以当非要将lst.reverse()指向一个变量，那么这个变量值也是None<br><img src="https://i.loli.net/2019/11/06/RICP3bFkplZvUnV.png" alt="reverse方法" title="reverse方法"><br>reversed函数: 与sorted函数不同的是，reversed函数不是返回一个反转后的列表或者字符串，而是返回一个内存对象，且不支持字典的反转， 返回反向迭代器<br><img src="https://i.loli.net/2019/11/06/JHT9bL6o8f4YryM.png" alt="reversed函数" title="reversed函数"></p></li></ul><p>sort和reverse是列表对象的方法，列表对象独有的方法，并且这两种方法都是在原列表上进行操作，并直接返回，返回值为None<br>sorted函数是支持字符串，字典，列表对象的排序，不在原列表上排序，而是返回一个新的列表，reveresd函数较为特殊，返回一个内存对象，而不是反转后的值</p><h3 id="dict-key-和-dict-get-key"><a href="#dict-key-和-dict-get-key" class="headerlink" title="dict[key] 和 dict.get(key)"></a>dict[key] 和 dict.get(key)</h3><p>一般对于字典取值会有dict[key]的方法取值，但是如果键key不存在，则会出现报错</p><pre><code class="python">&gt;&gt;&gt;a = {&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}&gt;&gt;&gt;a[&#39;one&#39;]           1&gt;&gt;&gt;a[&#39;four&#39;]           Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#39;four&#39;</code></pre><p>因为 dict[key] 的方式在无法判断是否存在 key 的情况下会出现 KeyError ，所以 可以使用dict.get(key[,default]) 的方法。</p><p>dict.get(key[,default]) 会查询字典中的key键，要是存在key键，则返回key键的值，要是没有key键，则返回 default， 若是没有 default，则返回 None。</p><pre><code class="python">&gt;&gt;&gt; a.get(&#39;four&#39;)   # 返回None&gt;&gt;&gt; a.get(&#39;four&#39;,&#39;can not find four&#39;)   # 返回default&#39;can not find four&#39;&gt;&gt;&gt;a  # 使用dict.get()后dict不变{&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}</code></pre><p><em>dict.setdefault(key[,default]) 表示：如果dict中存在key，则返回key的值， 如果不存在key，则返回default的值，并且在dict中增加 key: default 键值对，如果 default 不存在，则在dict增加 key:None 的键值对。</em></p><pre><code class="python">&gt;&gt;&gt;a{&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}&gt;&gt;&gt; a.setdefault(&#39;four&#39;,4)     # a 没有 &#39;four&#39;键，返回default, a 增加&#39;four&#39;:4键值对4&gt;&gt;&gt; a  {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}&gt;&gt;&gt; a.setdefault(&#39;five&#39;)     # a没有&#39;five&#39;键，没有default，返回None，a增加&#39;five&#39;:None键值对&gt;&gt;&gt; a{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;five&#39;: None}&gt;&gt;&gt; a.setdefault(&#39;one&#39;)1&gt;&gt;&gt; a{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;five&#39;: None}</code></pre><h3 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h3><ul><li>clear 清空字典的内容，字典还在  dict.clear()</li><li>del:</li></ul><ul><li>del(dict) 将删除整个字典</li><li>del(dict[‘key’])  删除的是键值对，是整个元素</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>[起始位置:结束位置:步长]<br>步长到达位置的元素被取出，如果超出结束位置的话，结束，不报错，超出的部分取不到元素</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="**args 和 **kwargs"></a>**args 和 **kwargs</h3><h3 id="局部变量-全局变量-global"><a href="#局部变量-全局变量-global" class="headerlink" title="局部变量 全局变量 global"></a>局部变量 全局变量 global</h3><pre><code class="python">def main():    print(a)a = 1main()</code></pre><p>运行结果：</p><pre><code class="python">1</code></pre><p>函数只能使用在它调用之前定义过的变量：</p><pre><code class="python">def main():    print(a)main()a = 1</code></pre><p>运行报错</p><pre><code class="python">def main():    a = 2    print(&#39;函数体内部a=&#39; + a)a = 1main()print(&#39;函数体外部a=&#39; + a)</code></pre><p>函数内的变量a是局部变量不会对全局变量造成影响，运行结果：</p><pre><code>函数体内部a=2函数体外部a=1</code></pre><pre><code class="python">def main():    global a    a = 2    print(&#39;函数体内部a=&#39; + a)a = 1main()print(&#39;函数体外部a=&#39; + a)</code></pre><p>运行结果：</p><pre><code>函数体内部a=2函数体外部a=2</code></pre><pre><code class="python">def fun1():    a1 = 1    def fun2():        a1 = a1 * 2        print(a1)    return fun2()fun1()</code></pre><p>运行报错，a1也不是全局变量不能用global,</p><pre><code class="python">def fun1():    a1 = 1    def fun2():        nonlocal a1        a1 = a1 * 2        print(a1)    return fun2()fun1()</code></pre><p>运行结果</p><pre><code>2</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code class="python">def out(a):  # 定义一个函数out(),形参为a    def In():  # 在函数内部在定义一个函数In()        print(a)  # 在In()函数内打印变量a    return In  # 在out()函数内返回In的指针out(1)  # 调用函数out,实参为1,此时将返回函数In的指针# out函数在运行结束后，变量a也将释放，那么理论上，函数In是访问不到a变量的# 因此如果调用这个In函数的话，应该会报错out(1)()  # 运行结果为1# 说明内层函数In依旧可以访问变量a# 这是因为当 内层函数 调用了 外层函数 作用域中的“变量”时，外层函数运行调用结束后，将会把内层函数涉及到的变量“送”给内层函数以保证其正常运行，这就是所谓的闭包#  闭包 = 函数块 + 创建它时的环境</code></pre><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>使用dir或help函数确定一个对象有哪些属性可供使用。<br>使用type函数确定这些对象都是什么类型，例如是函数还是变量。<br>使用help函数或对象的<strong>doc</strong>属性查看对象的的说明文档。</p><h3 id="if-name-‘-main-‘"><a href="#if-name-‘-main-‘" class="headerlink" title="if __name__ == ‘__main__‘:"></a>if __name__ == ‘__main__‘:</h3><p>if __name__ == ‘__main__‘ 可以保证脚本在以模块导入的时候不会自动执行最外层–函数定义以外的代码</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>read()会一次性读取文件的全部内容<br>read(size)每次最多读取size个字节的内容<br>readline()可以每次读取一行内容<br>readlines()一次读取所有内容并按行返回list</p><p>seek函数可以实现文件里的定位读写</p><pre><code class="python">seek(offset, from_what)</code></pre><p>offset参数：偏移量。<br>from_what：偏移量的起始位置。0：文件开头；1：当前位置；2：文件结尾。默认为0</p><h3 id="datetime…"><a href="#datetime…" class="headerlink" title="datetime…"></a>datetime…</h3><h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h2><h3 id="怎么实现多线程"><a href="#怎么实现多线程" class="headerlink" title="怎么实现多线程"></a>怎么实现多线程</h3><h3 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h3><h3 id="run-start"><a href="#run-start" class="headerlink" title="run()  start()"></a>run()  start()</h3><h3 id="GIL-全局解释锁"><a href="#GIL-全局解释锁" class="headerlink" title="GIL 全局解释锁"></a>GIL 全局解释锁</h3><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="init-…"><a href="#init-…" class="headerlink" title="__init__ …"></a>__init__ …</h3><h3 id="类-对象"><a href="#类-对象" class="headerlink" title="类 对象"></a>类 对象</h3><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>try…except…else…finally</p><h2 id="列表推倒式-迭代器-生成器"><a href="#列表推倒式-迭代器-生成器" class="headerlink" title="列表推倒式 迭代器  生成器"></a>列表推倒式 迭代器  生成器</h2><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器的详细部分，<a href="https://luyuonism.github.io/2018/06/05/decorator/">点击这里</a></p><h2 id="lamba-map-reduce-filter"><a href="#lamba-map-reduce-filter" class="headerlink" title="lamba  map()  reduce()  filter()"></a>lamba  map()  reduce()  filter()</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 学习之路&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="interview" scheme="https://luyuonism.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>decorator</title>
    <link href="https://luyuonism.github.io/2018/06/05/decorator/"/>
    <id>https://luyuonism.github.io/2018/06/05/decorator/</id>
    <published>2018-06-05T01:11:45.000Z</published>
    <updated>2019-11-07T02:18:14.801Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器</p><a id="more"></a><pre><code class="python">def a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))a()</code></pre><p>运行结果:</p><pre><code class="python">100000</code></pre><p>此时，想要计算下函数运行的时间:</p><pre><code class="python">import timedef a():    start = time.clock()    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))    end = time.clock()    print(&#39;函数运行时间为:&#39; + str(end - start))a()</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.0142545</code></pre><p>但是不能每个函数都加上这两句话，<br>于是，</p><pre><code class="python">import timedef CalTime(fun):    start = time.clock()    fun()    end = time.clock()    print(&#39;函数运行时间为:&#39; + str(end - start))def a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))CalTime(a)</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.0234953</code></pre><p>此时，无论有多少函数需要计算运行时间，都可以轻松实现。<br>那现在想要弄一个新函数，只是在原函数的基础上加上时间计算</p><pre><code class="python">import timedef CalTime(fun):    def In():        start = time.clock()        fun()        end = time.clock()        print(&#39;函数运行时间为:&#39; + str(end - start))    return Indef a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))print(CalTime(a))</code></pre><p><a href="https://luyuonism.github.io/2018/07/05/decorator/">闭包</a>…<br>运行结果:</p><pre><code class="python">&lt;function CalTime.&lt;locals&gt;.In at 0x000001CF3B90E0D0&gt;</code></pre><p>返回了新函数的指针</p><pre><code class="python">import timedef CalTime(fun):    def In():        start = time.clock()        fun()        end = time.clock()        print(&#39;函数运行时间为:&#39; + str(end - start))    return Indef a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))# print(CalTime(a))new_a = CalTime(a)new_a()</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.0270945</code></pre><p>这时</p><pre><code class="python">import timedef CalTime(fun):    def In():        start = time.clock()        fun()        end = time.clock()        print(&#39;函数运行时间为:&#39; + str(end - start))    return In@CalTimedef a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))a()</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.1938796</code></pre><p>于是装饰器，成了<br>它的主要功能就是在不改变函数内部代码的情况下增添一些新的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰器&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django</title>
    <link href="https://luyuonism.github.io/2018/06/05/django/"/>
    <id>https://luyuonism.github.io/2018/06/05/django/</id>
    <published>2018-06-05T01:11:43.000Z</published>
    <updated>2019-11-10T09:13:06.056Z</updated>
    
    <content type="html"><![CDATA[<p>Django–Django是一个由Python编写的开放源代码的Web应用框架。</p><a id="more"></a><h1 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h1><p><em>文章 分类 评论 搜索 统计</em></p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p>从用户的角度，通过访问不同的url，来得到不同的网页。<br>从开发者的角度，通过解析不同的url，来输出（render/display）该url指向的网页内容。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>用户请求(request) –&gt; 通过访问不同的url<br>响应(response)的内容，也就是用户看到的内容 –&gt; 用户最终看到的内容</p><p>http  用户发起请求 –&gt; 响应：浏览器获得响应内容，解析html，css，javascript</p><p>1.获得url请求 request<br>2.解析request （拿到url，解析url，让处理该url的方法去处理request）<br>3.拼接response ，返回给用户<br>4.浏览器获得响应内容，解析html，css，javascript</p><h2 id="django框架"><a href="#django框架" class="headerlink" title="django框架"></a>django框架</h2><p>创建项目:</p><pre><code class="django">django-admin startproject 项目名</code></pre><p>创建一个testdj目录,目录的结构为：</p><pre><code>testdj/    manage.py    一个让你用各种方式管理 Django 项目的命令行工具。    testdj/        一个纯 Python 包        __init__.py     一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。        settings.py     Django 项目的配置文件。        urls.py     Django 项目的 URL 声明，就像你网站的“目录”。        wsgi.py     作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。</code></pre><p>启动服务</p><pre><code class="python">python manage.py runserver</code></pre><p>将会输出如下结果：</p><pre><code class="python">python manage.py runserverPerforming system checks...System check identified no issues (0 silenced).May 10, 2018 - 17:21:16Django version 2.0.5, using settings &#39;testdj.settings&#39;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.</code></pre><p>更换端口</p><pre><code class="python">python manage.py runserver 8080</code></pre><p>如果想要修改服务器监听的IP，在端口之前输入新的</p><pre><code class="python">python manage.py runserver 0.0.0.0:8000</code></pre><p>简述django的MTV：</p><pre><code>MVC          用户-------------------------------\          |                     响应给用户显示 \          |                                   |发起请求  /    /----控制器将数据显示在视图上----View        /    /     Controller ------\     /                 \   / 按照请求访问数据库  \  /                     |  从数据库返回数据给控制器Model -------------------MTV  Model &lt;-----&lt;去models里取数据&lt;-----Views&lt;----&lt;根据url匹配相应的视图函数&lt;----url控制器&lt;----在页面输入访问的URL&lt;--\    | \                              / \                                                                      |    |   &gt;------&gt;将数据返回给视图&gt;-----&gt;   &gt;----&gt;把要展示的数据返回给模板&gt;----&gt; Templates----&gt;模板就是html文件---&gt; 用户    |去数据库里取数据    |   数据库</code></pre><h2 id="使用django开发个人博客"><a href="#使用django开发个人博客" class="headerlink" title="使用django开发个人博客"></a>使用django开发个人博客</h2><p>首先，博客的页面属于前端，不想自己写前端代码，怎么办???</p><h3 id="抓取网站源码工具"><a href="#抓取网站源码工具" class="headerlink" title="抓取网站源码工具"></a>抓取网站源码工具</h3><p><a href="'https://smalltool.github.io'">仿站小工具</a>是通过网址下载静态网页的工具。从输入的网址下载html代码，提取出JS、Css、Image、Picture、Flash等静态文件网址，再从下载完好的Css代码中提取出Image静态文件网址，通过网址下载静态文件，根据软件设置好的保存规则，自动修正html和css代码链接路径，最终这些静态文件被按分类保存到电脑文件夹。</p><ul><li>添加网址<br>输入的网址是要抓取页面网址，相对路径是主域名后边的路径，文件名即抓取后的文件保存的名字<br><img src="https://i.loli.net/2019/11/07/1cIVjQgrBLUwTE8.png" alt="添加地址.png" title="添加网址"></li><li>开始下载<br><img src="https://i.loli.net/2019/11/07/nHmhiDqzW2OyGo9.png" alt="开始下载" title="开始下载"></li><li>获取的结果</li></ul><p><img src="https://i.loli.net/2019/11/07/Ofp6F2CSZLqTg8h.png" alt="抓取结果" title="抓取结果"></p><ul><li>整理结果<br>把获取的除了static文件，其它文件中的 .html文件都放入 templates中，把static文件和templates放于同级目录<br><img src="https://i.loli.net/2019/11/07/xVj6tmMR4qAyG1C.png" alt="整理结果" title="整理结果"><br>此时，django所需的前端页面就有了，static、templates</li></ul><p><em>此时index.html 文件的静态文件配置的路径如果正确，路径都指向 static 对应的文件，则可以在浏览器中运行</em></p><h3 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h3><h4 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h4><h5 id="Virtualenv"><a href="#Virtualenv" class="headerlink" title="Virtualenv"></a>Virtualenv</h5><ol><li>安装 Virtualenv<br>Virtualenv 是一个创建隔绝的 Python 环境的工具。Virtualenv 创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需的包。<br>可以理解为我们电脑上要开发很多项目，每一个项目的开发环境是不同的，Virtualenv 可以创建出一个个不同的开发环境。<pre><code>pip install virtualenv</code></pre></li><li>创建虚拟环境<pre><code>cd 路径virtualenv 环境名</code></pre></li><li>激活·虚拟环境<pre><code>cd 环境名/Scriptsactivate.bat </code></pre>激活成功后，命令行前面会有（环境名）的字样<pre><code>(环境名) 路径\环境名\Scripts&gt;</code></pre></li><li>退出虚拟环境<pre><code>deactivate.bat</code></pre><h5 id="VirtualenvWrapper"><a href="#VirtualenvWrapper" class="headerlink" title="VirtualenvWrapper"></a>VirtualenvWrapper</h5></li><li>安装 VirtualenvWrapper<br>使用 Virtualenv，需要进入相对应的路径，相对麻烦，可以使用 VirtualWrapper 对虚拟环境集中管理。<pre><code>pip install virtualenvwrapper-win</code></pre></li><li>设置环境变量<br>环境变量是通过 VirtualenvWrapper 建立虚拟环境时，该虚拟环境的所在目录<br>右键计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;新建，变量值为你虚拟环境的目录。<pre><code>变量名：WORKON_HOME变量值：路径\virtualenv</code></pre></li><li>创建虚拟环境<pre><code>mkvirtualenv 环境名</code></pre>创建的虚拟环境存放位置：路径\virtualenv即可</li><li>查看创建的所有虚拟环境<pre><code>workon</code></pre></li><li>启动虚拟环境<pre><code>workon 环境名</code></pre></li><li>退出虚拟环境<pre><code>deactivate</code></pre>如果这个虚拟环境不想要了，直接进入 路径\virtualenv文件夹删除 环境名的文件夹即可</li></ol><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>启动虚拟环境</p><pre><code>workon 环境名</code></pre><p>创建方法见上文</p><p>这里直接用python IDE Pycharm 创建<br>file-&gt;new profile 新建一个项目</p><ul><li>选择左侧栏中的 django</li><li>位置栏输入自己的项目名称，这里直接叫 blog</li><li>解释器这里选择之前创建的虚拟环境 虚拟环境路径/环境名/Scripts/python.exe<br><img src="https://i.loli.net/2019/11/07/qwRQChyBemLnOix.png" alt="创建项目" title="创建项目"></li></ul><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行方法见上文</p><p>这里用IDE直接run即可</p><pre><code>Django version 2.2.4, using settings &#39;blog.settings&#39;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.</code></pre><p>在setting.py文件中，将语言改为中文，时区改为上海<br>blog -&gt; blog -&gt; settings.py</p><pre><code>LANGUAGE_CODE = &#39;zh-hans&#39;TIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre><h3 id="创建第一个APP"><a href="#创建第一个APP" class="headerlink" title="创建第一个APP"></a>创建第一个APP</h3><p>在Terminal中输入:</p><pre><code class="python">python manage.py startapp luyu</code></pre><p>于是就创建出一个名为luyu的app<br>此时项目完整的目录结构如下</p><pre><code>.|-- blog|   |-- luyu                # 博客应用|   |   |-- migrations      # 数据库映射文件|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- admin.py        # 该应用的后台管理系统|   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成|   |   |-- models.py       # 数据模块，使用ORM框架|   |   |-- tests.py        # 自动化测试的模块        |   |   |-- views.py        # 执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写        |   |-- blog                # 项目的容器|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- settings.py     # 该 Django 项目的设置/配置。|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。|   |   |-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目|   |-- templates           # 模板文件`-- manage.py</code></pre><p>新创建的app需要注册:<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python">INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;luyu&#39;,    # 添加用户应用]</code></pre><h3 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h3><p>这里使用的数据库是mysql</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>Django 中默认的数据库是 sqlite3<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python"># 默认DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),    }}</code></pre><p>改为:</p><pre><code class="python">DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;HOST&#39;: &#39;localhost&#39;,        &#39;PORT&#39;: &#39;3306&#39;,        &#39;USER&#39;: &#39;root&#39;,        &#39;PASSWORD&#39;: &#39;123456&#39;,        &#39;NAME&#39;: &#39;luyu&#39;,        # 避免映射数据库时出现警告        &#39;OPTIONS&#39;: {            &#39;init_command&#39;: &quot;SET sql_mode=&#39;STRICT_TRANS_TABLES&#39;&quot;,            &#39;charset&#39;: &#39;utf8mb4&#39;,        },    }}</code></pre><p>此时 Django 与 Mysql 关联上了，但是 Python 并没有与 Mysql 连接上,需要安装pymysql</p><pre><code>pip install pymysql</code></pre><p>此时，<br>在Terminal中输入:</p><pre><code class="python">python manage.py makemigrations</code></pre><p>和</p><pre><code class="python">python manage.py migrate</code></pre><p>当执行了 makemigrations 后，Django 在 luyu 这个应用的 migrations\ 目录下生成了一个 0001_initial.py 文件，这个文件是 Django 用来记录我们对模型做了哪些修改的文件。<br>不过此时只是告诉了 Django 做了哪些改变，为了让 Django 真正地为我们创建数据库表，接下来执行 migrate 命令。<br>Django 通过检测应用中 migrations\ 目录下的文件，得知我们对数据库做了哪些操作，然后它把这些操作翻译成数据库操作语言，从而把这些操作作用于数据库。<br>经过这两项操作后，我们打开 navicat 等mysql数据库可视化软件中的 blog 数据库，发现多了如下表单，这些表单为Django 自身还内置的很多应用，这些应用本身也是需要存储数据的。</p><pre><code>auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions, django_admin_log, django_content_type, django_migrations, django_session</code></pre><p>此时如果你发现项目文件中并没有 templates 文件，新建 templates 文件，右击鼠标，选择 Mark Directory as -&gt; Template Folder, 点击确定。</p><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>数据库设计是一个难点，先从功能上分析，看看这个博客网站需要建立哪些表，每个表中都需要什么字段。<br>首先，最主要的是我们的博文表，名字可以直接叫做 article，这个表中，肯定要包括以下几点：</p><p>博文的标题、博文的内容、博文的发表时间、博文的修改时间、博文的分类、博文的阅读量、博文喜欢量、博文作者 等</p><p>针对博文的分类，我们可以参考csdn博客系统，一篇博文只能有一个分类，但是可以有多个标签，比如我现在写的这篇博文，可以分类到 django 下，但是它可以有多个标签：django、博客、数据库、开发……</p><p>考虑到每一篇博文都只能有一个分类，而一个分类下是可以包含很多博文的，因此分类与博文是一对多的关系，此时应当使用外键来进行关联。而一篇博文可以有多个标签， 每个标签也可以包含多个博文，因此，标签与博文是多对多的关系。关于一对多与多对多的知识话题，这里就不再展开了，不了解的查看 Django文档 与相关资料。<br>针对网站优化，那么一个网站最基本的<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=seo&fromid=102990&fr=aladdin" target="_blank" rel="noopener">SEO</a>就是设置TDK</p><pre><code>T： 网站页面 titleD： 网站页面描述K： 网站页面Keywords，也即网站涵盖的主题</code></pre><p>则需要一个页面关键字表 Keyword，一个页面可能包含多个主题，一个主题可能在多个页面出现，所以应该是多对多的关系 暂且称作 Keyword</p><p><a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板博客</a>导航栏菜单存在下拉菜单，下拉菜单即是博文分类，这里的导航栏菜单也需要一个表，因为这个表就是为了给博文分类归类的 暂且称作 Bigcategory</p><p>观察<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板博客</a>导航栏下边还一个公告，公告也需要一个表，它和任何表都没关系 暂且称作 Activate</p><p>公告下边是幻灯片，思考了一下，这个幻灯片应该和别的表也没啥关系，暂且称作 Carousel</p><p>再看看，右侧还有一个友情链接功能，需要一个表，友链和其它表也没啥关系 暂且称作 FriendLink</p><p>因此，通过上述分析，我们可以确定出这些数据表，博客（Article）、分类（Category）与标签（Tag）、导航(Bigcategory)、文章关键词 (Keyword)、公告(Activate)、幻灯片(Carousel)、友链(FriendLink)</p><h4 id="编写-luyu-应用模型"><a href="#编写-luyu-应用模型" class="headerlink" title="编写 luyu 应用模型"></a>编写 luyu 应用模型</h4><p>blog -&gt; luyu -&gt; models.py</p><pre><code class="python">from django.db import modelsfrom django.conf import settingsfrom django.shortcuts import reverseimport markdownimport re</code></pre><p>由于 Article 表包含外键与多对多关系，因此首先应当建立另外两个表：</p><p>分类（Category）表的创建：</p><p>由于 Category 分类表包含外键，因此首先需要创建导航菜单表 Bigcategory</p><pre><code class="python"># 网站导航菜单栏分类表class BigCategory(models.Model):    # 导航名称    name = models.CharField(&#39;文章大分类&#39;, max_length=20)    # 用作文章的访问路径，每篇文章有独一无二的标识，下同    slug = models.SlugField(unique=True)    # 分类页描述    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)    # 分类页Keywords    keywords = models.TextField(&#39;关键字&#39;, max_length=240, default=settings.SITE_KEYWORDS,                              help_text=&#39;用来作为SEO中keywords,长度参考SEO标准&#39;)    class Meta:        verbose_name = &#39;大分类&#39;        verbose_name_plural = verbose_name    def __str__(self):        return self.name# 导航栏，分类下的下拉擦菜单分类class Category(models.Model):    # 分类名字    name = models.CharField(&#39;文章分类&#39;, max_length=20)    # slug 用作分类路径，对一无二    slug = models.SlugField(unique=True)    # 分类栏目页描述    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)    # 对应导航菜单外键    bigcategory = models.ForeignKey(BigCategory, verbose_name=&#39;大分类&#39;, on_delete=models.CASCADE)    class Meta:        verbose_name = &#39;分类&#39;        verbose_name_plural = verbose_name        ordering = [&#39;name&#39;]    def __str__(self):        return self.name    def get_absolute_url(self):        return reverse(&#39;blog:category&#39;, kwargs={&#39;slug&#39;: self.slug, &#39;bigslug&#39;: self.bigcategory.slug})    def get_article_list(self):        return Article.objects.filter(category=self)</code></pre><p>标签（Tag）表的创建：</p><pre><code class="python"># 文章标签class Tag(models.Model):    name = models.CharField(&#39;文章标签&#39;, max_length=20)    slug = models.SlugField(unique=True)    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)    class Meta:        verbose_name = &#39;标签&#39;        verbose_name_plural = verbose_name        ordering = [&#39;id&#39;]    def __str__(self):        return self.name    def get_absolute_url(self):        return reverse(&#39;blog:tag&#39;, kwargs={&#39;tag&#39;: self.name})    def get_article_list(self):        &quot;&quot;&quot;返回当前标签下所有发表的文章列表&quot;&quot;&quot;        return Article.objects.filter(tags=self)</code></pre><p>标签（Keyword）表的创建：</p><pre><code class="python"># 文章关键词，用来作为 SEO 中 keywordsclass Keyword(models.Model):    name = models.CharField(&#39;文章关键词&#39;, max_length=20)    class Meta:        verbose_name = &#39;关键词&#39;        verbose_name_plural = verbose_name        ordering = [&#39;name&#39;]    def __str__(self):        return self.name</code></pre><p>博客（Article）表的创建：</p><pre><code class="python"># 文章class Article(models.Model):    # 文章默认缩略图    IMG_LINK = &#39;/static/images/summary.jpg&#39;    # 文章作者    author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=&#39;作者&#39;, on_delete=models.CASCADE)    title = models.CharField(max_length=150, verbose_name=&#39;文章标题&#39;)    summary = models.TextField(&#39;文章摘要&#39;, max_length=230, default=&#39;文章摘要等同于网页description内容，请务必填写...&#39;)    # 文章内容    body = models.TextField(verbose_name=&#39;文章内容&#39;)    img_link = models.CharField(&#39;图片地址&#39;, default=IMG_LINK, max_length=255)    create_date = models.DateTimeField(verbose_name=&#39;创建时间&#39;, auto_now_add=True)    update_date = models.DateTimeField(verbose_name=&#39;修改时间&#39;, auto_now=True)    views = models.IntegerField(&#39;阅览量&#39;, default=0)    loves = models.IntegerField(&#39;喜爱量&#39;, default=0)    # 文章唯一标识符    slug = models.SlugField(unique=True)    category = models.ForeignKey(Category, verbose_name=&#39;文章分类&#39;, on_delete=models.CASCADE)    tags = models.ManyToManyField(Tag, verbose_name=&#39;标签&#39;)    keywords = models.ManyToManyField(Keyword, verbose_name=&#39;文章关键词&#39;,                                    help_text=&#39;文章关键词，用来作为SEO中keywords，最好使用长尾词，3-4个足够&#39;)    class Meta:        verbose_name = &#39;文章&#39;        verbose_name_plural = verbose_name        ordering = [&#39;-create_date&#39;]    def __str__(self):        return self.title[:20]    def get_absolute_url(self):        return reverse(&#39;blog:article&#39;, kwargs={&#39;slug&#39;: self.slug})    def body_to_markdown(self):        return markdown.markdown(self.body, extensions=[            &#39;markdown.extensions.extra&#39;,            &#39;markdown.extensions.codehilite&#39;,        ])    def update_views(self):        self.views += 1        self.save(update_fields=[&#39;views&#39;])    def get_pre(self):        return Article.objects.filter(id__lt=self.id).order_by(&#39;-id&#39;).first()    def get_next(self):        return Article.objects.filter(id__gt=self.id).order_by(&#39;id&#39;).first()</code></pre><p>为什么要用slug给文章起别名呢？这个可能暂且就认为只是为了提升逼格吧</p><p>公告（Activate）表的创建：</p><pre><code class="python"># 公告class Activate(models.Model):    text = models.TextField(&#39;公告&#39;, null=True)    is_active = models.BooleanField(&#39;是否开启&#39;, default=False)    add_date = models.DateTimeField(&#39;提交日期&#39;, auto_now_add=True)    class Meta:        verbose_name = &#39;公告&#39;        verbose_name_plural = verbose_name    def __str__(self):        return self.id</code></pre><p>幻灯片（Carousel）表的创建：</p><pre><code class="python"># 幻灯片class Carousel(models.Model):    number = models.IntegerField(&#39;编号&#39;, help_text=&#39;编号决定图片播放的顺序，图片不要多于5张&#39;)    title = models.CharField(&#39;标题&#39;, max_length=20, blank=True, null=True, help_text=&#39;标题可以为空&#39;)    content = models.CharField(&#39;描述&#39;, max_length=80)    img_url = models.CharField(&#39;图片地址&#39;, max_length=200)    url = models.CharField(&#39;跳转链接&#39;, max_length=200, default=&#39;#&#39;, help_text=&#39;图片跳转的超链接，默认#表示不跳转&#39;)    class Meta:        verbose_name = &#39;图片轮播&#39;        verbose_name_plural = verbose_name        # 编号越小越靠前，添加的时间约晚约靠前        ordering = [&#39;number&#39;, &#39;-id&#39;]    def __str__(self):        return self.content[:25]</code></pre><p>友链（FriendLink）表的创建：</p><pre><code class="python"># 友情链接表class FriendLink(models.Model):    name = models.CharField(&#39;网站名称&#39;, max_length=50)    description = models.CharField(&#39;网站描述&#39;, max_length=100, blank=True)    link = models.URLField(&#39;友链地址&#39;, help_text=&#39;请填写http或https开头的完整形式地址&#39;)    logo = models.URLField(&#39;网站LOGO&#39;, help_text=&#39;请填写http或https开头的完整形式地址&#39;, blank=True)    create_date = models.DateTimeField(&#39;创建时间&#39;, auto_now_add=True)    is_active = models.BooleanField(&#39;是否有效&#39;, default=True)    is_show = models.BooleanField(&#39;是否首页展示&#39;, default=False)    class Meta:        verbose_name = &#39;友情链接&#39;        verbose_name_plural = verbose_name        ordering = [&#39;create_date&#39;]    def __str__(self):        return self.name    def get_home_url(self):        &quot;&quot;&quot;提取友链的主页&quot;&quot;&quot;        u = re.findall(r&#39;(http|https://.*?)/.*?&#39;, self.link)        home_url = u[0] if u else self.link        return home_url    def active_to_false(self):        self.is_active=False        self.save(update_fields=[&#39;is_active&#39;])    def show_to_false(self):        self.is_show = True        self.save(update_fields=[&#39;is_show&#39;])</code></pre><p>这里需要注意一下，luyu -&gt; models.py 中出现的 AUTH_USER_MODEL、SITE_DESCRIPTION、AUTH_USER_MODEL、SITE_KEYWORDS，把它们当作默认字段放在 setting.py 中，便于管理<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python"># 网站描述，用于SEOSITE_DESCRIPTION = &quot;luyu的个人网站，记录python学习之路&quot;# 网站关键词，用于SEOSITE_KEYWORDS = &quot;luyuonism,luyu,网络,IT,技术,博客,Python&quot;</code></pre><p>在文件首部 # 引入 settings.py 文件，即可使用这些字段</p><pre><code class="python">from django.conf import settings</code></pre><p>以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime），max_length 参数限定长度。</p><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li><p>标题应当限定长度，我们设定最大值为100</p></li><li><p>内容不用限定长度，因此用的是TextField字段</p></li><li><p>修改时间直接设定成，auto_now=True，在你修改时，会自动变成当前时间。</p></li><li><p>关于ForeignKey与ManyToManyField，查看<a href="https://docs.djangoproject.com/en/2.1/topics/db/models/" target="_blank" rel="noopener">Django官方文档</a> <a href="http://djangobook.py3k.cn/2.0/chapter05/" target="_blank" rel="noopener">Django中文文档</a></p></li></ul><h4 id="编写-user-用户模型"><a href="#编写-user-用户模型" class="headerlink" title="编写 user 用户模型"></a>编写 user 用户模型</h4><p>blog -&gt; luyu -&gt; models.py 中文章有一个作者外键</p><pre><code class="python">    author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=&#39;作者&#39;, on_delete=models.CASCADE)</code></pre><p>这个外键是网站注册用户，这样用户也可以有发文权限，考虑到以后会扩展用户功能，所以这里还是创建一个用户app比较好。<br>创建app不再赘述, 不要忘了创建app后去配置文件里注册用户app<br>blog -&gt; user -&gt; models.py</p><pre><code class="python"># 继承 AbstractUser ，django 自带用户类，扩展用户个人网站字段，用户头像字段class Ouser(AbstractUser):    # 扩展用户个人网站字段    link = models.URLField(&#39;个人网址&#39;, blank=True, help_text=&#39;提示：网址必须填写以http开头的完整形式&#39;)    # 扩展用户头像字段    avatar = ProcessedImageField(upload_to=&#39;avatar/%Y/%m/%d&#39;,                                 default=&#39;avatar/default.png&#39;,                                 verbose_name=&#39;头像&#39;,                                 processors=[ResizeToFill(80, 80)]                                 )    class Meta:        verbose_name = &#39;用户&#39; # 定义网站管理后台表名        verbose_name_plural = verbose_name        ordering = [&#39;-id&#39;]    def __str__(self):        return self.username</code></pre><h4 id="迁移-user-用户应用模型"><a href="#迁移-user-用户应用模型" class="headerlink" title="迁移 user 用户应用模型"></a>迁移 user 用户应用模型</h4><p>Terminal中执行命令</p><pre><code class="python">python  manage.py  makemigrationspython  manage.py  migrate</code></pre><p>如遇以下问题，</p><pre><code class="python">    File &quot;E:\\ProgramData\\Anaconda3\\lib\\site-packages\\imagekit\\registry.py&quot;, line 3, in &lt;module&gt;        from .utils import autodiscover, call_strategy_methodImportError: cannot import name &#39;autodiscover&#39;</code></pre><p>解决办法：</p><pre><code>E:\ProgramData\Anaconda3\Lib\site-packages\imagekit 中有一个utils文件和utils.py文件，两个文件名发生冲突产生歧义，将utils文件夹手动改为foo</code></pre><pre><code class="python">SystemCheckError: System check identified some issues:ERRORS:auth.User.groups: (fields.E304) Reverse accessor for &#39;User.groups&#39; clashes with reverse accessor for &#39;Ouser.groups&#39;.        HINT: Add or change a related_name argument to the definition for &#39;User.groups&#39; or &#39;Ouser.groups&#39;.auth.User.user_permissions: (fields.E304) Reverse accessor for &#39;User.user_permissions&#39; clashes with reverse accessor for &#39;Ouser.user_permissions&#39;.        HINT: Add or change a related_name argument to the definition for &#39;User.user_permissions&#39; or &#39;Ouser.user_permissions&#39;.user.Ouser.groups: (fields.E304) Reverse accessor for &#39;Ouser.groups&#39; clashes with reverse accessor for &#39;User.groups&#39;.        HINT: Add or change a related_name argument to the definition for &#39;Ouser.groups&#39; or &#39;User.groups&#39;.user.Ouser.user_permissions: (fields.E304) Reverse accessor for &#39;Ouser.user_permissions&#39; clashes with reverse accessor for &#39;User.user_permissions&#39;.        HINT: Add or change a related_name argument to the definition for &#39;Ouser.user_permissions&#39; or &#39;User.user_permissions&#39;.</code></pre><p>解决办法:</p><pre><code>抽象基类创建完成后, 没有在setting中声明, 或者声明错误setting.py 文件中添加一句 AUTH_USER_MODEL = &quot;user.Ouser&quot;</code></pre><pre><code class="python">django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency user.0001_initial on database &#39;default&#39;.</code></pre><p>解决办法:</p><pre><code>删库跑路，把所有表删掉之后，再次执行 python  manage.py  migrate</code></pre><p>以上，即可将新建的这些表添加到我们的数据库 blog 中：</p><pre><code>auth_group, auth_group_permissions,auth_permission,auth_user_groups,auth_user_user_permissions, django_admin_log, django_content_type, django_migrations, django_session,storm_activate,         # 公告表 storm_article,          # 新增的博文表storm_article_keywords, # 这个是博文与关键词的多对多关系表storm_article_tags,     # 这个是博文与标签的多对多关系表storm_bigcategory,      # 导航菜单大分类表storm_carousel,         # 幻灯片storm_category,         # 新增的分类表storm_friendlink,       # 友情链接storm_keyword,          # 关键词表storm_tag，              # 新增的标签表user_ouser,             # 新增扩展用户表user_ouser_groups,      # 自动产生user_ouser_user_permissions # 自动产生</code></pre><p>最后两个表示用户表继承了，Django自带的用户models产生的用户关系表<br>需要说明的是，这里我们只给出了最开始设计时考虑到的情况，在后续开发过程中，可以随时对其进行变更。当数据表信息变动时<br>再次执行</p><pre><code class="python">python  manage.py  makemigrationspython  manage.py  migrate</code></pre><h3 id="通过admin管理后台"><a href="#通过admin管理后台" class="headerlink" title="通过admin管理后台"></a>通过admin管理后台</h3><p>Django 中一个最强大的部分是自动管理接口，在模型中读取元数据来提供一个强大的、生产就绪的接口，使内容提供者能立即用它向站点中添加内容，在这篇文档中，我们讨论如何去激活，使用和自定义Django的站点管理接口。</p><h4 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a>创建管理员账号</h4><p>在浏览器中输入<a href="http://127.0.0.1:8000/admin" target="_blank" rel="noopener">http://127.0.0.1:8000/admin</a>,<br>便可进入到后台管理登录页面，如下图所示：<br><img src="https://i.loli.net/2019/11/09/wtbLJoiRTNW8Fau.png" alt="django登陆" title="django登陆"><br>首先，创建一个能登录管理页面的用户,</p><pre><code class="python">python manage.py createsuperuser</code></pre><p>键入你想要使用的用户名:</p><pre><code>Username: admin</code></pre><p>然后提示你输入想要使用的邮件地址：</p><pre><code>Email address: admin@example.com</code></pre><p>最后一步是输入密码。你会被要求输入两次密码，密码需要满足起码的强度。</p><pre><code>Password:Password (again):Superuser created successfully.</code></pre><h4 id="注册模型到后台"><a href="#注册模型到后台" class="headerlink" title="注册模型到后台"></a>注册模型到后台</h4><p>登录后台后，我们看到此时的后台只有用户、组和最近动作，并没有我们之前创建的我的文章、分类、标签这些内容。<br><img src="https://i.loli.net/2019/11/09/8UgS7sJWwDftc1r.png" alt="django后台" title="django后台"><br>在admin.py中进行配置，将其在后台展现出来：<br>blog -&gt; luyu -&gt; admin.py</p><pre><code class="python">from django.contrib import adminfrom .models import Article, Tag, Category, Carousel, Keyword, FriendLink, BigCategory@admin.register(Article)class ArticleAdmin(admin.ModelAdmin):    # 这个的作用是给出一个筛选机制，一般按照时间比较好    date_hierarchy = &#39;create_date&#39;    exclude = (&#39;views&#39;,)    # 在查看修改的时候显示的属性，第一个字段带有&lt;a&gt;标签，所以最好放标题    list_display = (&#39;id&#39;, &#39;title&#39;, &#39;author&#39;, &#39;create_date&#39;, &#39;update_date&#39;)    # 设置需要添加&lt;a&gt;标签的字段    list_display_links = (&#39;title&#39;,)    # 激活过滤器，这个很有用    list_filter = (&#39;create_date&#39;, &#39;category&#39;)    list_per_page = 50  # 控制每页显示的对象数量，默认是100    filter_horizontal = (&#39;tags&#39;, &#39;keywords&#39;)  # 给多选增加一个左右添加的框    # 限制用户权限，只能看到自己编辑的文章    def get_queryset(self, request):        qs = super(ArticleAdmin, self).get_queryset(request)        if request.user.is_superuser:            return qs        return qs.filter(author=request.user)@admin.register(Tag)class TagAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)@admin.register(Category)class CategoryAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)@admin.register(BigCategory)class BigCategoryAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)# 自定义管理站点的名称和URL标题admin.site.site_header = &#39;网站管理&#39;admin.site.site_title = &#39;博客后台管理&#39;@admin.register(Carousel)class CarouselAdmin(admin.ModelAdmin):    list_display = (&#39;number&#39;, &#39;title&#39;, &#39;content&#39;, &#39;img_url&#39;, &#39;url&#39;)@admin.register(Keyword)class KeywordAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;)@admin.register(FriendLink)class FriendLinkAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;description&#39;, &#39;link&#39;, &#39;create_date&#39;, &#39;is_active&#39;, &#39;is_show&#39;)    date_hierarchy = &#39;create_date&#39;    list_filter = (&#39;is_active&#39;, &#39;is_show&#39;)</code></pre><p>此时，再次刷新博客admin页面，即可看到我们创建的表：<br><img src="https://i.loli.net/2019/11/09/XRjFVdeGoNfpbW4.png" alt="刷新admin页面" title="刷新admin页面"><br>我们可以对其进行增加、修改、删除操作, admin 也是 Django 中最方便的一个特性。</p><h3 id="博客首页开发"><a href="#博客首页开发" class="headerlink" title="博客首页开发"></a>博客首页开发</h3><h4 id="添加模板"><a href="#添加模板" class="headerlink" title="添加模板"></a>添加模板</h4><p>前面已经获取了 static、templates 文件，将 static 文件夹整个拷贝到博客项目根目录下，然后在将 templates 文件夹下的 html 文件全部拷贝到到 templates 目录下。</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>Django 中后端的控制都是在视图函数中进行的，也就是 view.py，每创建一个 app，该 app 目录下都会有一个view.py，我们主要就是在这里进行后端代码的书写的。</p><pre><code class="python"># ---------------------------__author__ = &#39;luyuonism&#39;__date__ = &#39;2018/6/5 09:11:43&#39;# ---------------------------from django.views import genericfrom django.shortcuts import get_object_or_404, get_list_or_404from .models import Article, BigCategory, Category, Tag# Create your views here.class IndexView(generic.ListView):    &quot;&quot;&quot;        首页视图,继承自ListVIew，用于展示从数据库中获取的文章列表    &quot;&quot;&quot;    # 获取数据库中的文章列表    model = Article    # template_name属性用于指定使用哪个模板进行渲染    template_name = &#39;index.html&#39;    # context_object_name属性用于给上下文变量取名（在模板中使用该名字）    context_object_name = &#39;articles&#39;</code></pre><h4 id="配置首页路由"><a href="#配置首页路由" class="headerlink" title="配置首页路由"></a>配置首页路由</h4><p>通过 url 将视图函数与模板关联起来</p><p>现在我们有了 index.html 页面，也有了视图函数 IndexView，但是怎么才能通过 127.0.0.1:8000 访问到这个页面呢？django中是通过 url 将这个页面与视图函数关联起来，也就是前后端的API接口。</p><p>添加 urls.py 文件   blog -&gt; luyu</p><p>配置页面路由   blog -&gt; luyu -&gt; urls.py</p><pre><code class="python">from django.conf.urls import urlfrom .views import IndexViewurlpatterns = [    url(r&#39;^$&#39;, IndexView.as_view(template_name=&#39;index.html&#39;), name=&#39;index&#39;)]</code></pre><p><strong>template_name 是指定使用的模板文件，传递给视图，进行数据渲染，后边详讲路由配置博客应用路由</strong></p><p>blog -&gt; blog -&gt; urls.py</p><pre><code class="python">from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [    # 后台管理应用，django自带    url(r&#39;^admin/&#39;, admin.site.urls),    # storm 应用    url(&#39;&#39;, include(&#39;storm.urls&#39;, namespace=&#39;blog&#39;)),  ]</code></pre><p>此时的项目结构：</p><pre><code>.|-- blog|   |-- luyu                # 博客应用|   |   |-- migrations      # 数据库映射文件|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- admin.py        # 该应用的后台管理系统|   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成|   |   |-- models.py       # 数据模块，使用ORM框架|   |   |-- tests.py        # 自动化测试的模块    |   |   |-- urls.py         # 应用路由    |   |   |-- views.py        # 执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写    |   |-- blog                # 项目的容器|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- settings.py     # 该 Django 项目的设置/配置。|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。|   `-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目|   |-- static              # 静态文件|   |   |-- css|   |   |-- fonts|   |   |-- images|   |   |-- js|   |-- templates           # 模板文件|   |   |-- about.html|   |   |-- donate.html|   |   |-- exchange.html|   |   |-- index.html|   |   |-- message.html|   |   |-- project.html|   |   |-- question.html|   |   |-- resources.html|   |   |-- technique.html|   |   |-- wp-login.html`-- manage.py</code></pre><h4 id="修改静态文件路径"><a href="#修改静态文件路径" class="headerlink" title="修改静态文件路径"></a>修改静态文件路径</h4><p>访问 127.0.0.1:8000 这个页面时，Django 会通过正则表达式解析这个 url，从而判断出该 url 连接到哪个视图函数，我们这里对应的就是 IndexView。然后在 IndexView 中， 将 index.html 传递给前端，并通过浏览器展示给用户，这样我们便配置好了首页。<br><strong>首页样式的加载</strong></p><p>但是在刷新首页时，我们发现并没有样式，样式文件我们放在 static 文件夹中了，而index.html并没有定位到该目录</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django–Django是一个由Python编写的开放源代码的Web应用框架。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="django" scheme="https://luyuonism.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="https://luyuonism.github.io/2018/06/05/sql/"/>
    <id>https://luyuonism.github.io/2018/06/05/sql/</id>
    <published>2018-06-05T01:11:43.000Z</published>
    <updated>2019-11-10T10:50:47.931Z</updated>
    
    <content type="html"><![CDATA[<p>结构化查询语言</p><a id="more"></a><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><pre><code class="mysql">create database shop;</code></pre><h1 id="一-数据库与SQL"><a href="#一-数据库与SQL" class="headerlink" title="一 数据库与SQL"></a>一 数据库与SQL</h1><h2 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h2><h3 id="我们身边的数据库"><a href="#我们身边的数据库" class="headerlink" title="我们身边的数据库"></a>我们身边的数据库</h3><ul><li>例子：图书馆</li><li>数据库 DB</li><li>数据库管理系统 DBMS</li></ul><h3 id="为什么DBMS那么重要"><a href="#为什么DBMS那么重要" class="headerlink" title="为什么DBMS那么重要"></a>为什么DBMS那么重要</h3><ul><li>多人共享数据</li><li>提供操作大量数据所需的格式</li><li>读写自动化</li><li>应对突发事故</li></ul><h3 id="DBMS的种类"><a href="#DBMS的种类" class="headerlink" title="DBMS的种类"></a>DBMS的种类</h3><ul><li>层次数据库 HDB</li><li>关系数据库 RDB<pre><code>SQL 结构化查询语言RDBMS 关系数据库管理系统 --- Oracle Database(甲骨文)/SQL Server(微软)/DB2(IBM)/PostgreSQL(开源的RDBMS)/MySQL(开源的RDBMS)OODB 面向对象数据库XMLDB XML数据库KVS 键值存储系统</code></pre></li></ul><h2 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h2><h3 id="RDBMS的常见系统结构-客户端-服务器类型c-s类型"><a href="#RDBMS的常见系统结构-客户端-服务器类型c-s类型" class="headerlink" title="RDBMS的常见系统结构(客户端/服务器类型c/s类型)"></a>RDBMS的常见系统结构(客户端/服务器类型c/s类型)</h3><p><img src="https://i.loli.net/2019/11/10/68wkWgO1TYCNsoF.png" alt="系统结构" title="系统结构"></p><h3 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h3><p>数据库表格一个单元格中无法输入2个数据</p><h2 id="SQL概要"><a href="#SQL概要" class="headerlink" title="SQL概要"></a>SQL概要</h2><h3 id="标准SQL"><a href="#标准SQL" class="headerlink" title="标准SQL"></a>标准SQL</h3><h3 id="SQL语句及其种类"><a href="#SQL语句及其种类" class="headerlink" title="SQL语句及其种类"></a>SQL语句及其种类</h3><ul><li>DDL 数据定义语言<pre><code>CREATE 创建数据库和表等对象DROP 删除数据库和表等对象ALTER 修改数据库和表等对象的结构</code></pre></li><li>DML 数据操作语言<pre><code>SELECT 查询表中数据INSERT 向表中插入数据UPDTE 更新表中数据DELETE 删除表中数据</code></pre></li><li>DCL 数据控制语言<pre><code>COMMIT 确认对数据库中的数据进行修改ROLLBACK 取消对数据库中的数据进行变更GRANT 赋予用户操作权限REVOKE 取消用户的操作权限</code></pre></li></ul><h3 id="SQL的基本书写规则"><a href="#SQL的基本书写规则" class="headerlink" title="SQL的基本书写规则"></a>SQL的基本书写规则</h3><p>以(;)分号结尾<br>不区分关键字大小写<br>常数的书写方式是固定的<br>单词需要用半角空格或者换行来分隔</p><h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="https://i.loli.net/2019/11/10/BcyCeAWULs2HtTl.png" alt="实例表" title="实例表"></p><h2 id="表的删除和更新"><a href="#表的删除和更新" class="headerlink" title="表的删除和更新"></a>表的删除和更新</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构化查询语言&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="django" scheme="https://luyuonism.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luyuonism.github.io/2018/04/13/hello-world/"/>
    <id>https://luyuonism.github.io/2018/04/13/hello-world/</id>
    <published>2018-04-13T12:46:25.000Z</published>
    <updated>2019-11-06T10:20:47.574Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
