<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lu Ruijie&#39;s Personal Homepage</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luyuonism.github.io/"/>
  <updated>2019-12-04T11:37:11.155Z</updated>
  <id>https://luyuonism.github.io/</id>
  
  <author>
    <name>ruijielu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luyuonism.github.io/2019/12/04/question/"/>
    <id>https://luyuonism.github.io/2019/12/04/question/</id>
    <published>2019-12-04T12:46:25.000Z</published>
    <updated>2019-12-04T11:37:11.155Z</updated>
    
    <content type="html"><![CDATA[<p>##自我介绍<br>##挑一个自己完成的模块<br>##完整的讲述怎么实现<br>##整个工作经历中你觉得做的最重大的贡献的事件</p><p>##过去的项目中有没有什么不完善的地方</p><p>##后台读取数据库没有接口？？</p><p>##python 连接数据库</p><p> import pymysql<br> 连上数据库：帐号、密码、ip、端口号、数据库<br>coon = pymysql.connect(host = ‘127.0.0.1’,user = ‘root’,passwd = ‘123456’,port = 3306,db = ‘mydb’,charset = ‘utf8’）<br> 建立游标<br>cur = coon.cursor()<br> 执行sql<br>cur.execute(“select * from stu”) / cur.execute(‘insert into stu(name,sex) VALUE (“pzp”,”man”);’)  coon.commit() #如果是插入数据，则要commit一下<br> 获取结果<br>res = cur.fetchall()<br> 关闭游标<br>cur.close()<br> 连接关闭<br>coon.close()</p><p>##基本查询语句了解吗</p><p>##linux常用命令   查内存使用率 cpu使用率  磁盘使用率的指令<br>vim 编辑文件  wq!退出<br>cat 查看文件<br>pwd 当前目录<br>touch 新建空文件<br>rm 删除文件<br>mv 移动文件<br>chmod命令使用数字修改文件权限<br>chown命令：修改文件和目录的所有者和所属组<br>改变文件所属用户组：chgrp<br>top命令可以看到总体的系统运行状态和cpu的使用率 。显示96.9id表示空闲cpu<br>使用 free 命令可以显示闲置内存、总内存和交换内等方面的信息，单位是字节。<br>df命令参数功能：检查文件系统的磁盘空间占用情况，可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>##容器熟悉吗<br>docker<br>images命令用来查看本机Docker中存在哪些镜像<br>run 命令就是将镜像运行起来的  运行起来的镜像就叫做容器<br>ps命令可以查看当前都运行了一些容器<br>commit命令用来将容器转化为镜像</p><p>##手写代码 </p><p>###输入两个数计算最大公约数<br>def gcd(a, b):<br>      s = x if x＜y else y<br>      for i in range(1,s+1):<br>          if (x%i==0) and (y%i==0):<br>                res = i<br>      minb = res * (a//res) * (b//res)<br>     return res</p><p>def gcd(a,b)<br>      if a == 0:<br>           return b<br>      return gcd(a, a%b)</p><p>###输入一个数，统计＜这个数的质数个数<br>lower = int(input(“输入区间最小值: “))<br>upper = int(input(“输入区间最大值: “))<br>s = 0<br>for num in range(lower,upper + 1):<br>    if num &gt; 1:<br>        for i in range(2,num):<br>            if (num % i) == 0:<br>                break<br>        else:<br>            s += 1</p><p>###输入一个列表，里面包含正数和复数求这个列表哪一个子串的和是最大的，求这个和是多少</p><p>###引用一个库怎么引用 引用一个自定义的模块<br>sys.path.append</p><p>###json格式的字符串怎么转为字典</p><p>import json<br>json.dumps()用于将字典形式的数据转化为字符串<br>json.loads()用于将字符串形式的数据转化为字典<br>json.dump()用于将dict类型的数据转成str，并写入到json文件中<br>json.load()用于从json文件中读取数据</p><p>###元组和列表的区别</p><p>###字符串的本质是什么<br>字符串是可迭代对象，是序列中的有序序列，即可迭代对象就是有序序列</p><p>文件操作 打开文件怎么操作 怎么读取文件内容  如果文件比较大呢</p><p>读模式 r            只能读不能写，文件不存在时会报错<br>读写模式 r+      可以读也可以写，是覆盖写，会把文件最前面的内容覆盖；文件不存在时会报错<br>写模式 w           只能写不能读；写的时候会把原来的文件内容清空；当文件不存在时，会创建新文件<br>追加模式 a         不能读；是追加写，即在原内容末尾添加新内容；文件不存在时创建新文件<br>追加读模式 a+   可读可写；是追加写，即在原内容末尾添加新内容；文件不存在时创建新文件</p><p>打开文件   f = open(file,’模式’,’编码方式’)</p><p>读文件  content = f.read()<br>读取整个文件，将文件内容放到一个字符串变量中。如果文件非常大，尤其是大于内存时，无法使用read()方法。<br>readline()方法：每次读取一行；返回的是一个字符串对象，保持当前行的内存。比readlines慢得多。<br>readlines()方法：一次性读取整个文件；自动将文件内容分析成一个行的列表。</p><p>写文件  f.write(‘Hello, world!’)</p><p>关闭文件  f.close()</p><p>stra == ‘’ 和 stra is none 的区别</p><p>###字符串的拼接有几种方式    有一个列表用+和join哪个更好</p><p>def fun1(fun):<br>    def fun2():<br>         start = time.time()<br>         fun()<br>         end ….<br>         print ….<br>     return fun2</p><p>@fun1<br>def fun():<br>     ….</p><p>fun()</p><p>class Single(Object):<br>    _instance = None<br>    def __new__(cls,*args,**kwargs):<br>         if Single._instance is None:<br>                Single._instance = Object.__new__(cls,*args,**kwargs)<br>         return Single._instance<br>   def __init__….</p><p>##自我介绍<br>##18年7月到10月在干嘛<br>##毕业绩点要求<br>##老家在哪<br>##离职原因<br>##当时基于什么平台开发的<br>##linux熟悉吗   查找一个文件怎么查  在/opt目录下查一个result.txt怎么查   sad截取命令??    查内存以M、G显示<br>##MTV<br>##M层怎么和T层进行数据传输<br>##怎么进行模板继承  语句是什么<br>##需要自己写模板页面<br>##爬虫技术用的框架   框架有什么特色</p><p>##XPath /和//的区别<br>  /a/b/@abc 指的是根节点b元素的属性为abc的子代b元素（一级）；<br>  //a/b/@abc 指的是文档中所有a元素的属性为abc的子代b元素（一级）<br>  //a//b/@abc 指的是文档中所有a元素的属性为abc的后代b元素（包括子代元素）（多级）</p><p>##ORM有几种关联类型<br>  一对一/一对多/多对多</p><p>##forms 到view层怎么用<br>  forms.cleaned_data[“***“]     读取表单返回的值，返回类型为字典dict型</p><p>##用过装饰器吗</p><p>##学长内推  学长还在吗  为什么不去他那<br>##有没有考研计划<br>##开发产品的代码行有多少</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##自我介绍&lt;br&gt;##挑一个自己完成的模块&lt;br&gt;##完整的讲述怎么实现&lt;br&gt;##整个工作经历中你觉得做的最重大的贡献的事件&lt;/p&gt;
&lt;p&gt;##过去的项目中有没有什么不完善的地方&lt;/p&gt;
&lt;p&gt;##后台读取数据库没有接口？？&lt;/p&gt;
&lt;p&gt;##python 连接数据库&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>django配置  STATIC_ROOT</title>
    <link href="https://luyuonism.github.io/2019/11/05/django-STATIC_ROOT/"/>
    <id>https://luyuonism.github.io/2019/11/05/django-STATIC_ROOT/</id>
    <published>2019-11-05T02:25:49.382Z</published>
    <updated>2019-11-06T06:01:32.325Z</updated>
    
    <content type="html"><![CDATA[<p>关于django静态文件的配置说明————STATIC_ROOT和STATIC_URL以及STATICFILES_DIRS</p><a id="more"></a><h3 id="MEDIA-ROOT："><a href="#MEDIA-ROOT：" class="headerlink" title="MEDIA_ROOT："></a>MEDIA_ROOT：</h3><p>在说STATIC_ROOT之前，必须得提一下MEDIA_ROOT，在配置中，当你需要在你的项目中按照你心中的目录来存储文件时，MEDIA_ROOT是必不可少的。</p><pre><code class="python"># 文件存储配置MEDIA_URL = &#39;/media/&#39;MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media&#39;) # 默认根目录</code></pre><p>通过在setting.py文件中添加如上设置，就会设置好你需要放置文件的默认根目录</p><pre><code class="python">image = models.ImageField(upload_to=&quot;image/%Y/%m&quot;, default=u&quot;image/default.png&quot;, max_length=100)</code></pre><p>上面是一个数据库模型的字段代码，当你使用upload_to这个属性的时候，django会自动解析，生成相对路径，保存在MEDIA_ROOT设置的根目录下</p><h3 id="STATIC-ROOT"><a href="#STATIC-ROOT" class="headerlink" title="STATIC_ROOT:"></a>STATIC_ROOT:</h3><p>那为什么要使用STATIC_ROOT呢，是因为当你设置中DEBUG为True时，django会自动为你静态文件代理，不过当DEBUG为False时，意味着你要进入生产环境，那么，你就必须使用STATIC_ROOT来指明你的静态文件在哪里，就像MEDIA_ROOT一样。</p><pre><code class="python">STATIC_URL = &#39;/static/&#39;    STATICFILES_DIRS = [    os.path.join(BASE_DIR, &quot;static&quot;)]STATIC_ROOT = os.path.join(BASE_DIR, &quot;static&quot;)</code></pre><p>在setting.py文件中添加上面代码，并且在urls.py中添加下面代码即可</p><pre><code class="python"># 配置静态文件代理    url(r&#39;^static/(?P&lt;path&gt;.*)$&#39;, serve, {&#39;document_root&#39;: STATIC_ROOT}),</code></pre><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>详细介绍STATIC_ROOT, <a href="https://blog.csdn.net/alxandral_brother/article/details/52202270" target="_blank" rel="noopener">点击这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于django静态文件的配置说明————STATIC_ROOT和STATIC_URL以及STATICFILES_DIRS&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="django" scheme="https://luyuonism.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>python f-string式格式化</title>
    <link href="https://luyuonism.github.io/2019/06/05/python-f-string/"/>
    <id>https://luyuonism.github.io/2019/06/05/python-f-string/</id>
    <published>2019-06-04T16:00:00.000Z</published>
    <updated>2019-11-06T01:50:21.156Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="https://luyuonism.github.io/2018/07/05/python-basis/"/>
    <id>https://luyuonism.github.io/2018/07/05/python-basis/</id>
    <published>2018-07-05T04:03:43.000Z</published>
    <updated>2019-11-22T09:07:05.748Z</updated>
    
    <content type="html"><![CDATA[<p>python 学习之路</p><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h2><p><a href="#关键字">关键字</a><br><a href="#数据类型">数据类型</a><br><a href="#运算符">运算符</a><br><a href="#复合数据类型">复合数据类型</a><br><a href="#函数">函数</a><br><a href="#标准库">标准库</a><br><a href="#多线程和多进程">多线程和多进程</a><br><a href="#面向对象">面向对象</a><br><a href="#异常">异常等其他</a></p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><a name="#关键字">关键字</a></h2><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>with语句实质是上下文管理。</p><ol><li>上下文管理协议。包含方法__enter__()和__exit__(),支持该协议对象要实现这两个方法。</li><li>上下文管理器，定义执行with语句时要建立的运行时上下文，负责执行with语句块上下文中的进入与退出操作。</li><li>进入上下文的时候执行__enter__方法，如果设置as var语句，var变量接受__enter__方法返回值。</li><li>如果运行时发生了异常，就退出上下文管理器。调用管理器__exit__方法。</li></ol><p>但是with本身并没有异常捕获的功能，同时如果发生了运行时异常，它照样可以关闭文件释放资源。</p><p>应用场景: 1、文件操作。2、进程线程之间互斥对象。3、支持上下文其他对象</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul><li>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器</li><li>当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象</li><li>当你使用for进行迭代的时候，函数中的代码才会执行</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a name="#数据类型">数据类型</a></h2><p><img src="https://i.loli.net/2019/11/06/aGwNEdLhom9B4QM.png" alt="常用数据类型" title="常用数据类型"></p><h3 id="type-和-instance"><a href="#type-和-instance" class="headerlink" title="type() 和 instance()"></a>type() 和 instance()</h3><ul><li>type() 不会认为子类是一种父类类型，不考虑继承关系。</li><li>isinstance() 会认为子类是一种父类类型，考虑继承关系。<br>如果要判断两个类型是否相同推荐使用 isinstance()。</li></ul><pre><code class="python">a = 2print(isinstance(a,int))   # Trueprint(isinstance(a,str))   # Falseclass A:    passclass B(A):    passprint(&quot;isinstance&quot;,isinstance(A(),A))   # isinstance Trueprint(&quot;type&quot;,type(A())  == A)    # type Trueprint(&#39;isinstance&#39;,isinstance(B(),A) )   # isinstance Trueprint(&#39;type&#39;,type(B()) == A)     #  type False</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a href="#运算符">运算符</a></h2><h3 id="和"><a href="#和" class="headerlink" title="// 和 %"></a>// 和 %</h3><pre><code class="python">&gt;&gt;&gt; 13 // 34&gt;&gt;&gt; -13 // 3-5&gt;&gt;&gt; 13 // -3-5&gt;&gt;&gt; -13 // -34&gt;&gt;&gt; 13 % 31&gt;&gt;&gt; -13 % 32&gt;&gt;&gt; 13 % -3-2&gt;&gt;&gt; -13 % -3-1</code></pre><p><strong>如果：x // y = a，x % y = b</strong><br><strong>那么：x = a * y + b</strong><br>13 // -3 = -5, 13 % -3 = -2<br>13 = (-5) * (-3) + (-2)</p><h3 id="gt-gt-和-lt-lt"><a href="#gt-gt-和-lt-lt" class="headerlink" title="&gt;&gt; 和 &lt;&lt;"></a>&gt;&gt; 和 &lt;&lt;</h3><p>‘&gt;&gt;’ 右移  除2<br>‘&lt;&lt;’ 左移  乘2</p><h3 id="math-isclose-a-b-rel-tol-1e-9"><a href="#math-isclose-a-b-rel-tol-1e-9" class="headerlink" title="math.isclose(a, b, rel_tol=1e-9)"></a>math.isclose(a, b, rel_tol=1e-9)</h3><p>浮点数相等的比较，由于存在精度的关系，不能使用==判断，要用math模块的isclose方法。</p><pre><code class="python">&gt;&gt;&gt; import math&gt;&gt;&gt; math.isclose(1.0, 1.0000000001)True&gt;&gt;&gt; math.isclose(1.0, 1.0000000001, rel_tol=1e-10)False</code></pre><h3 id="和-is"><a href="#和-is" class="headerlink" title="== 和 is"></a>== 和 is</h3><p>is 判断的是a对象是否是b对象，是通过id来判断<br>== 判断的是a对象的值和b对象的值和类型是否相等，是通过value和type来判断</p><pre><code class="python">&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1.0&gt;&gt;&gt; a is bFalse&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; id(a)12777000&gt;&gt;&gt; id(b)14986000&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; id(a)12777000&gt;&gt;&gt; id(b)12777000</code></pre><h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><p>break可以提前结束一层循环，continue可以提前结束一次循环。</p><h2 id="循环else"><a href="#循环else" class="headerlink" title="循环else"></a>循环else</h2><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p><code>assert 要判断表达式, &#39;字符串&#39;</code></p><pre><code class="python">i = 0mySum = 0while i &lt; 5:    mySum += i    i += 1assert mySum == 15, &#39;mySum不等于15&#39;print(&#39;mySum = {}&#39;.format(mySum))</code></pre><p>输出结果：</p><pre><code>Traceback (most recent call last):  File &quot;d:/Projects/ch04/4.17-assert.py&quot;, line 9, in &lt;module&gt;    assert mySum == 15, &#39;mySum不等于15&#39;AssertionError: mySum不等于15</code></pre><p><strong>当判断的表达式为真时，assert语句不做任何动作，当表达式为假时，会触发异常，并将字符串内容输出。字符串可以省略。</strong></p><h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a><a name="#复合数据类型">复合数据类型</a></h2><h3 id="find-和-index"><a href="#find-和-index" class="headerlink" title="find 和 index"></a>find 和 index</h3><p>find: 查找字符串，严格区分大小写，返回值为字符串第一次出现所在的索引，后面的不管；未找到字符串，返回-1<br>index: 基本等同于find，区别：如果index查找不到，给出异常错误。</p><h3 id="列表的添加-插入-删除"><a href="#列表的添加-插入-删除" class="headerlink" title="列表的添加/插入/删除"></a>列表的添加/插入/删除</h3><pre><code class="python">mylist = [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;]mylist.append(&#39;defg&#39;)  # [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;, &#39;defg&#39;]# append 添加，把添加内容直接作为元素添加appendlist = [&#39;aaa&#39;, &#39;bbb&#39;]mylist.append(appendlist)   # [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;, [&#39;aaa&#39;, &#39;bbb&#39;]]# extend 添加，把列表拆成元素添加extendlist = [&#39;aaa&#39;, &#39;bbb&#39;]mylist.extend(extendlist)   # [&#39;abcd&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;, &#39;aaa&#39;, &#39;bbb&#39;]# insert 在index位置前插入元素mylist.insert(1, &#39;defg&#39;)    # [&#39;abcd&#39;, &#39;defg&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;]# insert对于列表的插入，等同于append做法mylist.insert(1, appendlist)   # [&#39;abcd&#39;, [&#39;aaa&#39;, &#39;bbb&#39;], &#39;zhangsan&#39;, &#39;jiangning&#39;]# 对列表元素进行修改，使用索引定位到元素，直接赋值修改mylist[1] = &#39;lisi&#39;  [&#39;abcd&#39;, &#39;lisi&#39;, &#39;zhangsan&#39;, &#39;jiangning&#39;]# del删除给定下标的元素mylist = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;]del(mylist[1])   # [&#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;]# pop删除最后一个或指定索引的元素mylist.pop()  # [&#39;a&#39;, &#39;c&#39;, &#39;a&#39;]# remove 删除指定值的元素# 一次只删除一个mylist.remove(&#39;a&#39;)    # [&#39;c&#39;, &#39;a&#39;]mylist.remove(&#39;a&#39;)    # [&#39;c&#39;]</code></pre><h3 id="sort-sorted-reverse-reversed"><a href="#sort-sorted-reverse-reversed" class="headerlink" title="sort()  sorted()  reverse()  reversed()"></a>sort()  sorted()  reverse()  reversed()</h3><ul><li><p>sort方法和sorted函数：排序使用<br>sort方法: 列表对象有一个sort()方法，实现将原列表进行一个排序，然后return，因为python 默认return返回一个None,所以非要将lst.sort()指向一个变量，那么这个变量值就是None<br><img src="https://i.loli.net/2019/11/06/uDiWtI1LMxeofac.png" alt="sort方法" title="sort方法"><br>sorted函数: sorted()是一个函数，即面向过程，将排序过程进行一个封装，按照不同的对象进行处理，不同的对象最后统一都是以列表的形式返回数据，即 return a_lst<br><img src="https://i.loli.net/2019/11/06/gCmXtq2okPy1McI.png" alt="sorted函数" title="sorted函数"></p></li><li><p>reverse方法和reversed函数：反转序列使用<br>reverse方法: 实现与sort()方法基本一致，功能的差异是对一个列表进行反转然后return，同样因为python 默认return返回一个None,所以当非要将lst.reverse()指向一个变量，那么这个变量值也是None<br><img src="https://i.loli.net/2019/11/06/RICP3bFkplZvUnV.png" alt="reverse方法" title="reverse方法"><br>reversed函数: 与sorted函数不同的是，reversed函数不是返回一个反转后的列表或者字符串，而是返回一个内存对象，且不支持字典的反转， 返回反向迭代器<br><img src="https://i.loli.net/2019/11/06/JHT9bL6o8f4YryM.png" alt="reversed函数" title="reversed函数"></p></li></ul><p>sort和reverse是列表对象的方法，列表对象独有的方法，并且这两种方法都是在原列表上进行操作，并直接返回，返回值为None<br>sorted函数是支持字符串，字典，列表对象的排序，不在原列表上排序，而是返回一个新的列表，reveresd函数较为特殊，返回一个内存对象，而不是反转后的值</p><h3 id="dict-key-和-dict-get-key"><a href="#dict-key-和-dict-get-key" class="headerlink" title="dict[key] 和 dict.get(key)"></a>dict[key] 和 dict.get(key)</h3><p>一般对于字典取值会有dict[key]的方法取值，但是如果键key不存在，则会出现报错</p><pre><code class="python">&gt;&gt;&gt;a = {&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}&gt;&gt;&gt;a[&#39;one&#39;]           1&gt;&gt;&gt;a[&#39;four&#39;]           Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#39;four&#39;</code></pre><p>因为 dict[key] 的方式在无法判断是否存在 key 的情况下会出现 KeyError ，所以 可以使用dict.get(key[,default]) 的方法。</p><p>dict.get(key[,default]) 会查询字典中的key键，要是存在key键，则返回key键的值，要是没有key键，则返回 default， 若是没有 default，则返回 None。</p><pre><code class="python">&gt;&gt;&gt; a.get(&#39;four&#39;)   # 返回None&gt;&gt;&gt; a.get(&#39;four&#39;,&#39;can not find four&#39;)   # 返回default&#39;can not find four&#39;&gt;&gt;&gt;a  # 使用dict.get()后dict不变{&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}</code></pre><p><em>dict.setdefault(key[,default]) 表示：如果dict中存在key，则返回key的值， 如果不存在key，则返回default的值，并且在dict中增加 key: default 键值对，如果 default 不存在，则在dict增加 key:None 的键值对。</em></p><pre><code class="python">&gt;&gt;&gt;a{&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}&gt;&gt;&gt; a.setdefault(&#39;four&#39;,4)     # a 没有 &#39;four&#39;键，返回default, a 增加&#39;four&#39;:4键值对4&gt;&gt;&gt; a  {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4}&gt;&gt;&gt; a.setdefault(&#39;five&#39;)     # a没有&#39;five&#39;键，没有default，返回None，a增加&#39;five&#39;:None键值对&gt;&gt;&gt; a{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;five&#39;: None}&gt;&gt;&gt; a.setdefault(&#39;one&#39;)1&gt;&gt;&gt; a{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;five&#39;: None}</code></pre><h3 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h3><ul><li>clear 清空字典的内容，字典还在  dict.clear()</li><li>del:</li></ul><ul><li>del(dict) 将删除整个字典</li><li>del(dict[‘key’])  删除的是键值对，是整个元素</li></ul><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>[起始位置:结束位置:步长]<br>步长到达位置的元素被取出，如果超出结束位置的话，结束，不报错，超出的部分取不到元素</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a name="#函数">函数</a></h2><h3 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="**args 和 **kwargs"></a>**args 和 **kwargs</h3><p>**args 传入多个数据组成元组<br>**kwargs 传入多个键值对组成字典</p><h3 id="局部变量-全局变量-global"><a href="#局部变量-全局变量-global" class="headerlink" title="局部变量 全局变量 global"></a>局部变量 全局变量 global</h3><pre><code class="python">def main():    print(a)a = 1main()</code></pre><p>运行结果：</p><pre><code class="python">1</code></pre><p>函数只能使用在它调用之前定义过的变量：</p><pre><code class="python">def main():    print(a)main()a = 1</code></pre><p>运行报错</p><pre><code class="python">def main():    a = 2    print(&#39;函数体内部a=&#39; + a)a = 1main()print(&#39;函数体外部a=&#39; + a)</code></pre><p>函数内的变量a是局部变量不会对全局变量造成影响，运行结果：</p><pre><code>函数体内部a=2函数体外部a=1</code></pre><pre><code class="python">def main():    global a    a = 2    print(&#39;函数体内部a=&#39; + a)a = 1main()print(&#39;函数体外部a=&#39; + a)</code></pre><p>运行结果：</p><pre><code>函数体内部a=2函数体外部a=2</code></pre><pre><code class="python">def fun1():    a1 = 1    def fun2():        a1 = a1 * 2        print(a1)    return fun2()fun1()</code></pre><p>运行报错，a1也不是全局变量不能用global,</p><pre><code class="python">def fun1():    a1 = 1    def fun2():        nonlocal a1        a1 = a1 * 2        print(a1)    return fun2()fun1()</code></pre><p>运行结果</p><pre><code>2</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a><a name="#闭包">闭包</a></h3><pre><code class="python">def out(a):  # 定义一个函数out(),形参为a    def In():  # 在函数内部在定义一个函数In()        print(a)  # 在In()函数内打印变量a    return In  # 在out()函数内返回In的指针out(1)   # 运行结果为In的指针# 调用函数out,实参为1,此时将返回函数In的指针# out函数在运行结束后，变量a也将释放，那么理论上，函数In是访问不到a变量的# 因此如果调用这个In函数的话，应该会报错out(1)()  # 运行结果为1# 说明内层函数In依旧可以访问变量a# 这是因为当 内层函数 调用了 外层函数 作用域中的“变量”时，外层函数运行调用结束后，将会把内层函数涉及到的变量“送”给内层函数以保证其正常运行，这就是所谓的闭包# 闭包 = 函数块 + 创建它时的环境</code></pre><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>使用dir或help函数确定一个对象有哪些属性可供使用。<br>使用type函数确定这些对象都是什么类型，例如是函数还是变量。<br>使用help函数或对象的<strong>doc</strong>属性查看对象的的说明文档。</p><h3 id="if-name-‘-main-‘"><a href="#if-name-‘-main-‘" class="headerlink" title="if __name__ == ‘__main__‘:"></a>if __name__ == ‘__main__‘:</h3><p>if __name__ == ‘__main__‘ 可以保证脚本在以模块导入的时候不会自动执行最外层–函数定义以外的代码</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a><a name="#标准库">标准库</a></h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>read()会一次性读取文件的全部内容<br>read(size)每次最多读取size个字节的内容<br>readline()可以每次读取一行内容<br>readlines()一次读取所有内容并按行返回list</p><p>seek函数可以实现文件里的定位读写</p><pre><code class="python">seek(offset, from_what)</code></pre><p>offset参数：偏移量。<br>from_what：偏移量的起始位置。0：文件开头；1：当前位置；2：文件结尾。默认为0</p><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><pre><code>           +-- date 日期对象,常用的属性有year, month, day           +-- time 时间对象           +-- datetime 日期时间对象,常用的属性有hour, minute, second, microseconddatetime - |           +-- datetime_CAPI 日期时间对象C语言接口           +-- timedelta 时间间隔，即两个时间点之间的长度           +-- tzinfo 时区信息对象</code></pre><ol><li>date类</li></ol><ul><li><p>date对象由year年份、month月份及day日期三部分构成</p><pre><code>date（year，month，day)</code></pre><p>通过year, month, day三个数据描述符可以进行访问</p><pre><code class="python">&gt;&gt;&gt; a = datetime.date.today()&gt;&gt;&gt; adatetime.date(2018, 7, 5)&gt;&gt;&gt; a.year2018&gt;&gt;&gt; a.month7&gt;&gt;&gt; a.day5</code></pre><p>当然，你也可以用<strong>getattribute</strong>(…)方法获得上述值</p><pre><code class="python">&gt;&gt;&gt; a.__getattribute__(&#39;year&#39;)2018&gt;&gt;&gt; a.__getattribute__(&#39;month&#39;)7&gt;&gt;&gt; a.__getattribute__(&#39;day&#39;)5</code></pre></li><li><p>date对象中包含的方法与属性</p><pre><code>方法名          方法说明            用法__eq__(…)     等于(x==y)         x.__eq__(y)__ge__(…)     大于等于(x&gt;=y)     x.__ge__(y)__gt__(…)     大于(x&gt;y)         x.__gt__(y)__le__(…)     小于等于(x&lt;=y)     x.__le__(y)__lt__(…)     小于(x&lt;y)        x.__lt__(y)__ne__(…)     不等于(x!=y)     x.__ne__(y)__sub__(…)     x - y             x.__sub__(y)__rsub__(…)     y - x             x.__rsub__(y)</code></pre><p>使用<strong>sub</strong>(…)和<strong>rsub</strong>(…)方法，获得二个日期相差多少天, 其实二个方法差不太多，一个是正向操作，一个是反向操作,计算结果的返回值类型为datetime.timedelta</p><pre><code class="python">&gt;&gt;&gt; adatetime.date(2018, 7, 5)&gt;&gt;&gt; bdatetime.date(2018, 7, 12)&gt;&gt;&gt; a.__sub__(b)datetime.timedelta(-7)&gt;&gt;&gt; a.__rsub__(b)datetime.timedelta(7)</code></pre><p>如果获得整数类型的结果则按下面的方法操作:</p><pre><code class="py">  &gt;&gt;&gt; a.__sub__(b).days  -7  &gt;&gt;&gt; a.__rsub__(b).days  7</code></pre></li><li><p>ISO标准化日期<br><code>isocalender()</code> 返回一个包含三个值的元组，三个值依次为：year年份，week number周数，weekday星期数（周一为1…周日为7)</p><pre><code class="py">&gt;&gt;&gt; adatetime.date(2018, 7, 5)&gt;&gt;&gt; a.isocalendar()(2018, 7, 5)</code></pre><p><code>isoformat()</code> 返回符合ISO 8601标准 ( <code>YYYY-MM-DD</code> ) 的日期字符串</p><pre><code class="py">&gt;&gt;&gt; a.isoformat()&#39;2018-07-05&#39;</code></pre><p><code>isoweekday()</code> 返回符合ISO标准的指定日期所在的星期数（周一为1…周日为7)<br>与 <code>isoweekday()</code> 相似的还有一个 <code>weekday()</code> 方法，只不过是 <code>weekday()</code> 方法返回的周一为 0, 周日为 6</p></li><li><p>日期的字符串输出</p></li></ul><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p>……</p><h2 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a><a name="#多线程和多进程">多线程和多进程</a></h2><p><strong>进程是操作系统分配程序执行资源的单位，而线程是进程的一个实体，是CPU调度和分配的单位。一个进程肯定有一个主线程，我们可以在一个进程里创建多个线程来实现多任务。</strong><br>实现多任务:</p><ul><li>在主进程里面开启多个子进程，主进程和多个子进程一起处理任务。<pre><code class="py">import multiprocessingimport timedef task1():  while True:      time.sleep(1)      print(&quot;I am task1&quot;)def task2():  while True:      time.sleep(2)      print(&quot;I am task2&quot;)if __name__ == &#39;__main__&#39;:  p1 = multiprocessing.Process(target=task1)  # multiprocessing.Process创建了子进程对象p1  p2 = multiprocessing.Process(target=task2)  # multiprocessing.Process创建了子进程对象p2  p1.start()  # 子进程p1启动  p2.start()  # 子进程p2启动  print(&quot;I am main task&quot;)  # 这是主进程的任务</code></pre>输出结果：<pre><code>I am main taskI am task1I am task2I am task1I am task1I am task2I am task1I am task1I am task2...</code></pre>(1) 并发:当任务数大于cpu核数时，通过操作系统的各种任务调度算法，实现多个任务“一起”执行。（实际上总有一些任务不在执行，因为切换任务相当快，看上去想同时执行而已。)<br>(2) 当是并发的情况下，子进程与主进程的运行都是没有顺序的，CPU会采用时间片轮寻的方式，哪个程序先要运行就先运行哪个。<br>(3) 主进程会默认等待所有子进程执行完毕后，它才会退出。<br>(4) 主进程默认创建的是非守护进程。如果子进程是守护进程的话，那么主进程运行完最后一句代码后，主进程会直接关闭，不管子进程运行完了没有<pre><code class="py">import multiprocessingimport timedef task1():  while True:      time.sleep(1)      print(&quot;I am task1&quot;)def task2():  while True:      time.sleep(2)      print(&quot;I am task2&quot;)if __name__ == &#39;__main__&#39;:  p1 = multiprocessing.Process(target=task1)  p2 = multiprocessing.Process(target=task2)  p1.daemon = True  # 设置p1子进程为守护进程  p2.daemon = True  # 设置p2子进程为守护进程  p1.start()  p2.start()  print(&quot;I am main task&quot;)</code></pre>输出结果：<pre><code>I am main task</code></pre>当主进程结束后，会发一个消息给子进程(守护进程)，守护进程收到消息，则立即结束<br>CPU是按照时间片轮寻的方式来运行多进程的。哪个合适的哪个运行，如果你的子进程里都有time.sleep。那我CPU为了不浪费资源，肯定先去干点其他的事情啊<br>因此，守护进程主要用来做与业务无关的任务，无关紧要的任务，可有可无的任务，比如内存垃圾回收，某些方法的执行时间的计时等</li><li><em>进程之间是不可以共享全局变量的，即使子进程与主进程。道理很简单，一个新的进程，其实就是占用一个新的内存空间，不同的内存空间，里面的变量肯定不能够共享的。*</em></li><li>在主进程里开启多个子线程，主线程和多个子线程一起处理任务。</li><li>在主进程里开启多个协程，多个协程一起处理任务。<br>(1) yield生成器实现协程<pre><code class="py">import timedef work1():  while True:      print(&quot;我是任务1&quot;)      yield      time.sleep(1)def work2():  while True:      print(&quot;我是任务2&quot;)      yield      time.sleep(1)w1 = work1()  # 取得work1函数的生成器w2 = work2()  # 取得work2函数的生成器while True:  next(w1)  next(w2)</code></pre>输出：<pre><code>我是任务1我是任务2我是任务1我是任务2我是任务1我是任务2......</code></pre>在一个进程里面，没有开线程，只有一个主进程主线程，也能实现多任务。因此说协程也能实现多任务，实现的方式是通过yield生成器来实现的。我们先唤醒第一个生成器，执行到yield，暂停。然后我们再唤醒第二个生成器，执行到yield，暂停。再唤醒第一个生成器，依次循环。（用while True来实现依次唤醒）<br>(2) 用greenlet模块中的greenlet类来实现协程<pre><code class="py">import timeimport greenletdef work1():  while True:      print(&quot;我是任务1&quot;)      g2.switch()  # 转换到任务2      time.sleep(1)def work2():  while True:      print(&quot;我是任务2&quot;)      g1.switch()  # 转换到任务1      time.sleep(1)g1 = greenlet.greenlet(run=work1)g2 = greenlet.greenlet(run=work2)g1.switch()  # 转换到任务1，其实就是开始执行任务1的意思</code></pre>输出：<pre><code>我是任务1我是任务2我是任务1我是任务2我是任务1我是任务2......</code></pre>greenlet类虽然能实现协程，但是每个任务都要用switch()方法转换到另一个任务。如果很多很多任务，每个任务都要带这么一段代码，是不是很烦。还要考虑切换顺序什么的。所以，greenlet又被封装到gevent模块的spawn类里。<br>(3) gevent模块的spawn类来实现协程<br>gevent的原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。<pre><code class="py">import geventimport timefrom gevent import monkey  # 这个类一定要这样子导入才能识别！monkey.patch_all()  # 如果不打这个补丁的话，系统是识别不了原生python代码的time.sleep的                          # 所以就不能按在适当的时候切换任务def work1(n):  i = 0  while True:      print(&quot;我是任务1&quot;)      time.sleep(1)      i += 1      if i&gt;n:          breakdef work2(n):  i = 0  while True:      print(&quot;我是任务2&quot;)      time.sleep(2)      i += 1      if i&gt;n:          breakg1 = gevent.spawn(work1,4)  # 开启g1协程，且阻塞主线程，直到g1协成任务执行完毕，再解主线程的阻塞g2 = gevent.spawn(work2,4)g1.join()g2.join()  # join方法既可以启动协程，又可以阻塞主线程，等到该协程完成任务后再解阻塞。print(&quot;我会在哪里？&quot;)</code></pre>输出：<pre><code>我是任务1我是任务2我是任务1我是任务2我是任务1我是任务1我是任务2我是任务1我是任务2我是任务2我会在哪里？</code></pre></li></ul><h3 id="怎么实现多线程"><a href="#怎么实现多线程" class="headerlink" title="怎么实现多线程"></a>怎么实现多线程</h3><pre><code class="py">import threadingp1 = threading.Thread(target=[函数名],args=([要传入函数的参数]))p1.start()  # 启动p1线程</code></pre><p>假如使用网易云音乐一边听歌一边下载。网易云音乐就是一个进程。假设网易云音乐内部程序是用多线程来实现多任务的，网易云音乐开两个子线程。一个用来缓存音乐，用于现在的播放。一个用来下载用户要下载的音乐的。这时候的代码框架是这样的：</p><pre><code class="py">import threadingimport timedef listen_music(name):    while True:        time.sleep(1)        print(name,&quot;正在播放音乐&quot;)def download_music(name):    while True:        time.sleep(2)        print(name,&quot;正在下载音乐&quot;)if __name__ == &#39;__main__&#39;:    p1 = threading.Thread(target=listen_music,args=(&quot;网易云音乐&quot;,))    p2 = threading.Thread(target=download_music,args=(&quot;网易云音乐&quot;,))    p1.start()    p2.start()输出：网易云音乐 正在播放音乐网易云音乐 正在下载音乐网易云音乐 正在播放音乐网易云音乐 正在播放音乐网易云音乐 正在下载音乐网易云音乐 正在播放音乐网易云音乐 正在播放音乐网易云音乐 正在下载音乐网易云音乐 正在播放音乐网易云音乐 正在播放音乐网易云音乐 正在播放音乐......</code></pre><p>(1) CPU是按照时间片轮询的方式来执行子线程的。cpu内部会合理分配时间片。时间片到a程序的时候，a程序如果在休眠，就会自动切换到b程序。<br>(2) 严谨来说，CPU在某个时间点，只在执行一个任务，但是由于CPU运行速度和切换速度快，因为看起来像多个任务在一起执行而已。<br>还有另一种方法,可以编写一个类，继承threaing.Thread类，然后重写父类的run方法。</p><pre><code class="py">import threadingimport timeclass MyThread(threading.Thread):    def run(self):        for i in range(5):            time.sleep(1)            print(self.name,i)t1 = MyThread()t2 = MyThread()t3 = MyThread()t1.start()t2.start()t3.start()输出：Thread-1 0Thread-3 0Thread-2 0Thread-1 1Thread-2 1Thread-3 1Thread-1 2Thread-3 2Thread-2 2Thread-1 3Thread-2 3Thread-3 3Thread-1 4Thread-2 4Thread-3 4</code></pre><p>(1) 子线程何时开启，何时运行<br>当调用thread.start()时 开启线程，再运行线程的代码<br>(2) 子线程何时结束<br>子线程把target指向的函数中的语句执行完毕后，或者线程中的run函数代码执行完毕后，立即结束当前子线程<br>(3) 查看当前线程数量<br>通过threading.enumerate()可枚举当前运行的所有线程<br>(4) 主线程何时结束<br>所有子线程执行完毕后，主线程才结束</p><pre><code class="py">import threadingimport timedef run():    for i in range(5):        time.sleep(1)        print(i)t1 = threading.Thread(target=run)t1.start()print(&quot;我会在哪里出现&quot;)输出：我会在哪里出现01234</code></pre><p>为什么主进程（主线程）的代码会先出现呢？因为CPU采用时间片轮询的方式，如果轮询到子线程，发现他要休眠1s，他会先去运行主线程。所以说CPU的时间片轮询方式可以保证CPU的最佳运行。</p><p>如果想主进程输出的那句话运行在结尾,就需要用到 join() 方法。</p><pre><code class="py">import threadingimport timedef run():    for i in range(5):        time.sleep(1)        print(i)t1 = threading.Thread(target=run)t1.start()t1.join()  print(&quot;我会在哪里出现&quot;)输出：01234我会在哪里出现</code></pre><p>join() 方法可以阻塞主线程（注意只能阻塞主线程，其他子线程是不能阻塞的），直到 t1 子线程执行完，再解阻塞。</p><p>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题：多个线程共同对某个数据修改，则可能出现不可预料的结果。为了保证数据的正确性，需要对多个线程进行同步。<br>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。<br>互斥锁为资源引入一个状态：锁定/非锁定<br>某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。<br>互斥锁有三个常用步骤</p><pre><code class="py">lock = threading.Lock()  # 取得锁lock.acquire()  # 上锁lock.release()  # 解锁</code></pre><h3 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h3><h3 id="run-start"><a href="#run-start" class="headerlink" title="run()  start()"></a>run()  start()</h3><ul><li>start() 方法是启动一个子线程，线程名就是我们定义的name<br>启动多线程，必须使用start()方法。</li><li>run() 方法并不启动一个新线程，就是在主线程中调用了一个普通函数而已。</li></ul><h3 id="GIL-全局解释锁"><a href="#GIL-全局解释锁" class="headerlink" title="GIL 全局解释锁"></a>GIL 全局解释锁</h3><p>GIL:全局解释器锁。当我们使用多线程的时候,每一个进程中只有一个GIL锁,那么这多个线程中谁拿到GIL锁，谁就可以使用cpu(ps:多个进程有多个Gil锁，但每个进程中只有一个GIL)，所以当python用cpython作为解释器的时候，多线程就不是真正意义上的多线程，属于伪并发的多线程。</p><ul><li>Gil锁 :保证同一时刻只有一个线程能使用到cpu<br>GIL 只是解释器级别的锁，它能保证当多个线程在修改一个变量时不会崩溃，但结果可能是错乱的。</li><li>互斥锁 : 多线程时,保证修改共享数据时有序的修改,不会产生数据修改混乱</li></ul><ol><li>多线程运行，假设Thread1获得GIL可以使用cpu，这时Thread1获得 互斥锁lock,Thread1可以改date数据(但并没有开始修改数据);</li><li>Thread1线程在修改date数据前发生了 i/o操作 或者 ticks计数满100((注意就是没有运行到修改data数据),这个时候 Thread1 让出了Gil,Gil锁可以被竞争);</li><li>Thread1 和 Thread2 开始竞争Gil (注意:如果Thread1是因为i/o 阻塞 让出的Gil，Thread2必定拿到Gil,如果Thread1是因为ticks计数满100让出Gil这个时候Thread1 和 Thread2 公平竞争);</li><li>假设 Thread2正好获得了GIL, 运行代码去修改共享数据date,由于Thread1有互斥锁lock，所以Thread2无法更改共享数据date,这时Thread2让出Gil锁, GIL锁再次发生竞争;</li><li>假设Thread1又抢到GIL，由于其有互斥锁Lock所以其可以继续修改共享数据data,当Thread1修改完数据释放互斥锁lock,Thread2在获得GIL与lock后才可对data进行修改</li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><a name="#面向对象">面向对象</a></h2><h3 id="init-…"><a href="#init-…" class="headerlink" title="__init__ …"></a>__init__ …</h3><p>__init__:初始化<br>__doc__ : 类的文档字符串<br>__str__ : 打印输出</p><h3 id="类-对象"><a href="#类-对象" class="headerlink" title="类 对象"></a>类 对象</h3><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a><a name="#异常">异常</a></h2><p>try…except…else…finally</p><pre><code class="py">try：      &quot;包含可能会抛出异常的代码&quot; except：      &quot;try代码块里的代码如果抛出异常了，该执行什么内容&quot; else：      &quot;try代码块里的代码如果没有抛出异常，就执行这里&quot; finally:      &quot;不管如何，finally里的代码，是总会执行的&quot;</code></pre><h2 id="列表推倒式-迭代器-生成器"><a href="#列表推倒式-迭代器-生成器" class="headerlink" title="列表推倒式  迭代器  生成器"></a>列表推倒式  迭代器  生成器</h2><p>列表推导式: <code>[表达式 for 变量 in 列表 if 条件]</code> 本质上可以把列表推导式理解成一种集合了变换和筛选功能的函数，通过这个函数把一个列表转换成另一个列表。原列表保持不变。<br>迭代器:访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。<br>生成器: 如果把列表推导式的[]换成()，那么就会成为生成器的表达式。注意生成器也是没有长度的。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器的详细部分，<a href="https://luyuonism.github.io/2018/06/05/decorator/">点击这里</a></p><h2 id="lamba-map-reduce-filter"><a href="#lamba-map-reduce-filter" class="headerlink" title="lamba  map()  reduce()  filter()"></a>lamba  map()  reduce()  filter()</h2><p>lambda<br>map()函数: 接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。<br>filter()函数: 用于过滤序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。<br>reduce()函数: 把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。</p><h2 id="面向对象中怎么实现只读属性"><a href="#面向对象中怎么实现只读属性" class="headerlink" title="面向对象中怎么实现只读属性?"></a>面向对象中怎么实现只读属性?</h2><p>将对象私有化，通过共有方法提供一个读取数据的接口。</p><pre><code class="py">class person:    def__init__(self,x):        self.__age=10;    def age(self):        return self.__age;t=person(22)# t.__age=100print(t.age())</code></pre><p>最好的方法:</p><pre><code class="py">classMyCls(object):    __weight=50    @property   # 以访问属性的方式来访问weight方法    def weight(self):        return self.__weightif__name__==&#39;__main__&#39;:    obj=MyCls()    print(obj.weight)    obj.weight=12Traceback(mostrecentcalllast):50File&quot;C:/PythonTest/test.py&quot;,line11,in&lt;module&gt;4．obj.weight=12AttributeError:cant set attribute</code></pre><h2 id="谈谈对面向对象的理解"><a href="#谈谈对面向对象的理解" class="headerlink" title="谈谈对面向对象的理解"></a>谈谈对面向对象的理解</h2><p>面向对象是相对于面向过程而言的。面向过程语言是一种基于功能分析的、以算法为中心的程序设计方法；而面向对象是一种基于结构分析的、以数据为中心的程序设计思想 。在面向对象语言中有一个有很重要东西，叫做类。<br>面向对象有三大特性：封装、继承、多态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 学习之路&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>decorator</title>
    <link href="https://luyuonism.github.io/2018/06/05/decorator/"/>
    <id>https://luyuonism.github.io/2018/06/05/decorator/</id>
    <published>2018-06-05T01:11:45.000Z</published>
    <updated>2019-11-15T06:10:19.412Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器<br>装饰器本质上是一个python函数，它可以让其他函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。</p><a id="more"></a><pre><code class="python">def a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))a()</code></pre><p>运行结果:</p><pre><code class="python">100000</code></pre><p>此时，想要计算下函数运行的时间:</p><pre><code class="python">import timedef a():    start = time.clock()    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))    end = time.clock()    print(&#39;函数运行时间为:&#39; + str(end - start))a()</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.0142545</code></pre><p>但是不能每个函数都加上这两句话，<br>于是，</p><pre><code class="python">import timedef CalTime(fun):    start = time.clock()    fun()    end = time.clock()    print(&#39;函数运行时间为:&#39; + str(end - start))def a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))CalTime(a)</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.0234953</code></pre><p>此时，无论有多少函数需要计算运行时间，都可以轻松实现。<br>那现在想要弄一个新函数，只是在原函数的基础上加上时间计算</p><pre><code class="python">import timedef CalTime(fun):    def In():        start = time.clock()        fun()        end = time.clock()        print(&#39;函数运行时间为:&#39; + str(end - start))    return Indef a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))print(CalTime(a))</code></pre><p><a href="https://luyuonism.github.io/2018/07/05/python-basis/#闭包">闭包</a>…<br>运行结果:</p><pre><code class="python">&lt;function CalTime.&lt;locals&gt;.In at 0x000001CF3B90E0D0&gt;</code></pre><p>返回了新函数的指针</p><pre><code class="python">import timedef CalTime(fun):    def In():        start = time.clock()        fun()        end = time.clock()        print(&#39;函数运行时间为:&#39; + str(end - start))    return Indef a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))# print(CalTime(a))new_a = CalTime(a)new_a()</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.0270945</code></pre><p>这时</p><pre><code class="python">import timedef CalTime(fun):    def In():        start = time.clock()        fun()        end = time.clock()        print(&#39;函数运行时间为:&#39; + str(end - start))    return In@CalTimedef a():    temp = []    for i in range(100000):        temp.append(&#39;!!!&#39;)    print(len(temp))a()</code></pre><p>运行结果:</p><pre><code class="python">100000函数运行时间为:0.1938796</code></pre><p>于是装饰器，成了<br>它的主要功能就是在不改变函数内部代码的情况下增添一些新的功能。<br>比如：插入日志、性能测试，事务处理、缓存、权限验证等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰器&lt;br&gt;装饰器本质上是一个python函数，它可以让其他函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django</title>
    <link href="https://luyuonism.github.io/2018/06/05/django/"/>
    <id>https://luyuonism.github.io/2018/06/05/django/</id>
    <published>2018-06-05T01:11:43.000Z</published>
    <updated>2019-11-11T09:00:11.177Z</updated>
    
    <content type="html"><![CDATA[<p>Django–Django是一个由Python编写的开放源代码的Web应用框架。</p><a id="more"></a><h1 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h1><p><em>文章 分类 评论 搜索 统计</em></p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p>从用户的角度，通过访问不同的url，来得到不同的网页。<br>从开发者的角度，通过解析不同的url，来输出（render/display）该url指向的网页内容。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>用户请求(request) –&gt; 通过访问不同的url<br>响应(response)的内容，也就是用户看到的内容 –&gt; 用户最终看到的内容</p><p>http  用户发起请求 –&gt; 响应：浏览器获得响应内容，解析html，css，javascript</p><p>1.获得url请求 request<br>2.解析request （拿到url，解析url，让处理该url的方法去处理request）<br>3.拼接response ，返回给用户<br>4.浏览器获得响应内容，解析html，css，javascript</p><h2 id="django框架"><a href="#django框架" class="headerlink" title="django框架"></a>django框架</h2><p>创建项目:</p><pre><code class="django">django-admin startproject 项目名</code></pre><p>创建一个testdj目录,目录的结构为：</p><pre><code>testdj/    manage.py    一个让你用各种方式管理 Django 项目的命令行工具。    testdj/        一个纯 Python 包        __init__.py     一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。        settings.py     Django 项目的配置文件。        urls.py     Django 项目的 URL 声明，就像你网站的“目录”。        wsgi.py     作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。</code></pre><p>启动服务</p><pre><code class="python">python manage.py runserver</code></pre><p>将会输出如下结果：</p><pre><code class="python">python manage.py runserverPerforming system checks...System check identified no issues (0 silenced).May 10, 2018 - 17:21:16Django version 2.0.5, using settings &#39;testdj.settings&#39;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.</code></pre><p>更换端口</p><pre><code class="python">python manage.py runserver 8080</code></pre><p>如果想要修改服务器监听的IP，在端口之前输入新的</p><pre><code class="python">python manage.py runserver 0.0.0.0:8000</code></pre><p>简述django的MTV：</p><pre><code>MVC          用户-------------------------------\          |                     响应给用户显示 \          |                                   |发起请求  /    /----控制器将数据显示在视图上----View        /    /     Controller ------\     /                 \   / 按照请求访问数据库  \  /                     |  从数据库返回数据给控制器Model -------------------MTV  Model &lt;-----&lt;去models里取数据&lt;-----Views&lt;----&lt;根据url匹配相应的视图函数&lt;----url控制器&lt;----在页面输入访问的URL&lt;--\    | \                              / \                                                                      |    |   &gt;------&gt;将数据返回给视图&gt;-----&gt;   &gt;----&gt;把要展示的数据返回给模板&gt;----&gt; Templates----&gt;模板就是html文件---&gt; 用户    |去数据库里取数据    |   数据库</code></pre><h2 id="使用django开发个人博客"><a href="#使用django开发个人博客" class="headerlink" title="使用django开发个人博客"></a>使用django开发个人博客</h2><p>首先，博客的页面属于前端，不想自己写前端代码，怎么办???</p><h3 id="抓取网站源码工具"><a href="#抓取网站源码工具" class="headerlink" title="抓取网站源码工具"></a>抓取网站源码工具</h3><p><a href="'https://smalltool.github.io'">仿站小工具</a>是通过网址下载静态网页的工具。从输入的网址下载html代码，提取出JS、Css、Image、Picture、Flash等静态文件网址，再从下载完好的Css代码中提取出Image静态文件网址，通过网址下载静态文件，根据软件设置好的保存规则，自动修正html和css代码链接路径，最终这些静态文件被按分类保存到电脑文件夹。</p><ul><li>添加网址<br>输入的网址是要抓取页面网址，相对路径是主域名后边的路径，文件名即抓取后的文件保存的名字<br><img src="https://i.loli.net/2019/11/07/1cIVjQgrBLUwTE8.png" alt="添加地址.png" title="添加网址"></li><li>开始下载<br><img src="https://i.loli.net/2019/11/07/nHmhiDqzW2OyGo9.png" alt="开始下载" title="开始下载"></li><li>获取的结果</li></ul><p><img src="https://i.loli.net/2019/11/07/Ofp6F2CSZLqTg8h.png" alt="抓取结果" title="抓取结果"></p><ul><li>整理结果<br>把获取的除了static文件，其它文件中的 .html文件都放入 templates中，把static文件和templates放于同级目录<br><img src="https://i.loli.net/2019/11/07/xVj6tmMR4qAyG1C.png" alt="整理结果" title="整理结果"><br>此时，django所需的前端页面就有了，static、templates</li></ul><p><em>此时index.html 文件的静态文件配置的路径如果正确，路径都指向 static 对应的文件，则可以在浏览器中运行</em></p><h3 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h3><h4 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h4><h5 id="Virtualenv"><a href="#Virtualenv" class="headerlink" title="Virtualenv"></a>Virtualenv</h5><ol><li>安装 Virtualenv<br>Virtualenv 是一个创建隔绝的 Python 环境的工具。Virtualenv 创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需的包。<br>可以理解为我们电脑上要开发很多项目，每一个项目的开发环境是不同的，Virtualenv 可以创建出一个个不同的开发环境。<pre><code>pip install virtualenv</code></pre></li><li>创建虚拟环境<pre><code>cd 路径virtualenv 环境名</code></pre></li><li>激活·虚拟环境<pre><code>cd 环境名/Scriptsactivate.bat </code></pre>激活成功后，命令行前面会有（环境名）的字样<pre><code>(环境名) 路径\环境名\Scripts&gt;</code></pre></li><li>退出虚拟环境<pre><code>deactivate.bat</code></pre><h5 id="VirtualenvWrapper"><a href="#VirtualenvWrapper" class="headerlink" title="VirtualenvWrapper"></a>VirtualenvWrapper</h5></li><li>安装 VirtualenvWrapper<br>使用 Virtualenv，需要进入相对应的路径，相对麻烦，可以使用 VirtualWrapper 对虚拟环境集中管理。<pre><code>pip install virtualenvwrapper-win</code></pre></li><li>设置环境变量<br>环境变量是通过 VirtualenvWrapper 建立虚拟环境时，该虚拟环境的所在目录<br>右键计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;新建，变量值为你虚拟环境的目录。<pre><code>变量名：WORKON_HOME变量值：路径\virtualenv</code></pre></li><li>创建虚拟环境<pre><code>mkvirtualenv 环境名</code></pre>创建的虚拟环境存放位置：路径\virtualenv即可</li><li>查看创建的所有虚拟环境<pre><code>workon</code></pre></li><li>启动虚拟环境<pre><code>workon 环境名</code></pre></li><li>退出虚拟环境<pre><code>deactivate</code></pre>如果这个虚拟环境不想要了，直接进入 路径\virtualenv文件夹删除 环境名的文件夹即可</li></ol><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>启动虚拟环境</p><pre><code>workon 环境名</code></pre><p>创建方法见上文</p><p>这里直接用python IDE Pycharm 创建<br>file-&gt;new profile 新建一个项目</p><ul><li>选择左侧栏中的 django</li><li>位置栏输入自己的项目名称，这里直接叫 blog</li><li>解释器这里选择之前创建的虚拟环境 虚拟环境路径/环境名/Scripts/python.exe<br><img src="https://i.loli.net/2019/11/07/qwRQChyBemLnOix.png" alt="创建项目" title="创建项目"></li></ul><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行方法见上文</p><p>这里用IDE直接run即可</p><pre><code>Django version 2.2.4, using settings &#39;blog.settings&#39;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK.</code></pre><p>在setting.py文件中，将语言改为中文，时区改为上海<br>blog -&gt; blog -&gt; settings.py</p><pre><code>LANGUAGE_CODE = &#39;zh-hans&#39;TIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre><h3 id="创建第一个APP"><a href="#创建第一个APP" class="headerlink" title="创建第一个APP"></a>创建第一个APP</h3><p>在Terminal中输入:</p><pre><code class="python">python manage.py startapp luyu</code></pre><p>于是就创建出一个名为luyu的app<br>此时项目完整的目录结构如下</p><pre><code>.|-- blog|   |-- luyu                # 博客应用|   |   |-- migrations      # 数据库映射文件|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- admin.py        # 该应用的后台管理系统|   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成|   |   |-- models.py       # 数据模块，使用ORM框架|   |   |-- tests.py        # 自动化测试的模块        |   |   |-- views.py        # 执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写        |   |-- blog                # 项目的容器|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- settings.py     # 该 Django 项目的设置/配置。|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。|   |   |-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目|   |-- templates           # 模板文件`-- manage.py</code></pre><p>新创建的app需要注册:<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python">INSTALLED_APPS = [    &#39;django.contrib.admin&#39;,    &#39;django.contrib.auth&#39;,    &#39;django.contrib.contenttypes&#39;,    &#39;django.contrib.sessions&#39;,    &#39;django.contrib.messages&#39;,    &#39;django.contrib.staticfiles&#39;,    &#39;luyu&#39;,    # 添加用户应用]</code></pre><h3 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h3><p>这里使用的数据库是mysql</p><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>Django 中默认的数据库是 sqlite3<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python"># 默认DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),    }}</code></pre><p>改为:</p><pre><code class="python">DATABASES = {    &#39;default&#39;: {        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,        &#39;HOST&#39;: &#39;localhost&#39;,        &#39;PORT&#39;: &#39;3306&#39;,        &#39;USER&#39;: &#39;root&#39;,        &#39;PASSWORD&#39;: &#39;123456&#39;,        &#39;NAME&#39;: &#39;luyu&#39;,        # 避免映射数据库时出现警告        &#39;OPTIONS&#39;: {            &#39;init_command&#39;: &quot;SET sql_mode=&#39;STRICT_TRANS_TABLES&#39;&quot;,            &#39;charset&#39;: &#39;utf8mb4&#39;,        },    }}</code></pre><p>此时 Django 与 Mysql 关联上了，但是 Python 并没有与 Mysql 连接上,需要安装pymysql</p><pre><code>pip install pymysql</code></pre><p>此时，<br>在Terminal中输入:</p><pre><code class="python">python manage.py makemigrations</code></pre><p>和</p><pre><code class="python">python manage.py migrate</code></pre><p>当执行了 makemigrations 后，Django 在 luyu 这个应用的 migrations\ 目录下生成了一个 0001_initial.py 文件，这个文件是 Django 用来记录我们对模型做了哪些修改的文件。<br>不过此时只是告诉了 Django 做了哪些改变，为了让 Django 真正地为我们创建数据库表，接下来执行 migrate 命令。<br>Django 通过检测应用中 migrations\ 目录下的文件，得知我们对数据库做了哪些操作，然后它把这些操作翻译成数据库操作语言，从而把这些操作作用于数据库。<br>经过这两项操作后，我们打开 navicat 等mysql数据库可视化软件中的 blog 数据库，发现多了如下表单，这些表单为Django 自身还内置的很多应用，这些应用本身也是需要存储数据的。</p><pre><code>auth_group, auth_group_permissions, auth_permission, auth_user, auth_user_groups, auth_user_user_permissions, django_admin_log, django_content_type, django_migrations, django_session</code></pre><p>此时如果你发现项目文件中并没有 templates 文件，新建 templates 文件，右击鼠标，选择 Mark Directory as -&gt; Template Folder, 点击确定。</p><h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>数据库设计是一个难点，先从功能上分析，看看这个博客网站需要建立哪些表，每个表中都需要什么字段。<br>首先，最主要的是我们的博文表，名字可以直接叫做 article，这个表中，肯定要包括以下几点：</p><p>博文的标题、博文的内容、博文的发表时间、博文的修改时间、博文的分类、博文的阅读量、博文喜欢量、博文作者 等</p><p>针对博文的分类，我们可以参考csdn博客系统，一篇博文只能有一个分类，但是可以有多个标签，比如我现在写的这篇博文，可以分类到 django 下，但是它可以有多个标签：django、博客、数据库、开发……</p><p>考虑到每一篇博文都只能有一个分类，而一个分类下是可以包含很多博文的，因此分类与博文是一对多的关系，此时应当使用外键来进行关联。而一篇博文可以有多个标签， 每个标签也可以包含多个博文，因此，标签与博文是多对多的关系。关于一对多与多对多的知识话题，这里就不再展开了，不了解的查看 Django文档 与相关资料。<br>针对网站优化，那么一个网站最基本的<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=seo&fromid=102990&fr=aladdin" target="_blank" rel="noopener">SEO</a>就是设置TDK</p><pre><code>T： 网站页面 titleD： 网站页面描述K： 网站页面Keywords，也即网站涵盖的主题</code></pre><p>则需要一个页面关键字表 Keyword，一个页面可能包含多个主题，一个主题可能在多个页面出现，所以应该是多对多的关系 暂且称作 Keyword</p><p><a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板博客</a>导航栏菜单存在下拉菜单，下拉菜单即是博文分类，这里的导航栏菜单也需要一个表，因为这个表就是为了给博文分类归类的 暂且称作 Bigcategory</p><p>观察<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板博客</a>导航栏下边还一个公告，公告也需要一个表，它和任何表都没关系 暂且称作 Activate</p><p>公告下边是幻灯片，思考了一下，这个幻灯片应该和别的表也没啥关系，暂且称作 Carousel</p><p>再看看，右侧还有一个友情链接功能，需要一个表，友链和其它表也没啥关系 暂且称作 FriendLink</p><p>因此，通过上述分析，我们可以确定出这些数据表，博客（Article）、分类（Category）与标签（Tag）、导航(Bigcategory)、文章关键词 (Keyword)、公告(Activate)、幻灯片(Carousel)、友链(FriendLink)</p><h4 id="编写-luyu-应用模型"><a href="#编写-luyu-应用模型" class="headerlink" title="编写 luyu 应用模型"></a>编写 luyu 应用模型</h4><p>blog -&gt; luyu -&gt; models.py</p><pre><code class="python">from django.db import modelsfrom django.conf import settingsfrom django.shortcuts import reverseimport markdownimport re</code></pre><p>由于 Article 表包含外键与多对多关系，因此首先应当建立另外两个表：</p><p>分类（Category）表的创建：</p><p>由于 Category 分类表包含外键，因此首先需要创建导航菜单表 Bigcategory</p><pre><code class="python"># 网站导航菜单栏分类表class BigCategory(models.Model):    # 导航名称    name = models.CharField(&#39;文章大分类&#39;, max_length=20)    # 用作文章的访问路径，每篇文章有独一无二的标识，下同    slug = models.SlugField(unique=True)    # 分类页描述    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)    # 分类页Keywords    keywords = models.TextField(&#39;关键字&#39;, max_length=240, default=settings.SITE_KEYWORDS,                              help_text=&#39;用来作为SEO中keywords,长度参考SEO标准&#39;)    class Meta:        verbose_name = &#39;大分类&#39;        verbose_name_plural = verbose_name    def __str__(self):        return self.name# 导航栏，分类下的下拉擦菜单分类class Category(models.Model):    # 分类名字    name = models.CharField(&#39;文章分类&#39;, max_length=20)    # slug 用作分类路径，对一无二    slug = models.SlugField(unique=True)    # 分类栏目页描述    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)    # 对应导航菜单外键    bigcategory = models.ForeignKey(BigCategory, verbose_name=&#39;大分类&#39;, on_delete=models.CASCADE)    class Meta:        verbose_name = &#39;分类&#39;        verbose_name_plural = verbose_name        ordering = [&#39;name&#39;]    def __str__(self):        return self.name    def get_absolute_url(self):        return reverse(&#39;blog:category&#39;, kwargs={&#39;slug&#39;: self.slug, &#39;bigslug&#39;: self.bigcategory.slug})    def get_article_list(self):        return Article.objects.filter(category=self)</code></pre><p>标签（Tag）表的创建：</p><pre><code class="python"># 文章标签class Tag(models.Model):    name = models.CharField(&#39;文章标签&#39;, max_length=20)    slug = models.SlugField(unique=True)    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)    class Meta:        verbose_name = &#39;标签&#39;        verbose_name_plural = verbose_name        ordering = [&#39;id&#39;]    def __str__(self):        return self.name    def get_absolute_url(self):        return reverse(&#39;blog:tag&#39;, kwargs={&#39;tag&#39;: self.name})    def get_article_list(self):        &quot;&quot;&quot;返回当前标签下所有发表的文章列表&quot;&quot;&quot;        return Article.objects.filter(tags=self)</code></pre><p>标签（Keyword）表的创建：</p><pre><code class="python"># 文章关键词，用来作为 SEO 中 keywordsclass Keyword(models.Model):    name = models.CharField(&#39;文章关键词&#39;, max_length=20)    class Meta:        verbose_name = &#39;关键词&#39;        verbose_name_plural = verbose_name        ordering = [&#39;name&#39;]    def __str__(self):        return self.name</code></pre><p>博客（Article）表的创建：</p><pre><code class="python"># 文章class Article(models.Model):    # 文章默认缩略图    IMG_LINK = &#39;/static/images/summary.jpg&#39;    # 文章作者    author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=&#39;作者&#39;, on_delete=models.CASCADE)    title = models.CharField(max_length=150, verbose_name=&#39;文章标题&#39;)    summary = models.TextField(&#39;文章摘要&#39;, max_length=230, default=&#39;文章摘要等同于网页description内容，请务必填写...&#39;)    # 文章内容    body = models.TextField(verbose_name=&#39;文章内容&#39;)    img_link = models.CharField(&#39;图片地址&#39;, default=IMG_LINK, max_length=255)    create_date = models.DateTimeField(verbose_name=&#39;创建时间&#39;, auto_now_add=True)    update_date = models.DateTimeField(verbose_name=&#39;修改时间&#39;, auto_now=True)    views = models.IntegerField(&#39;阅览量&#39;, default=0)    loves = models.IntegerField(&#39;喜爱量&#39;, default=0)    # 文章唯一标识符    slug = models.SlugField(unique=True)    category = models.ForeignKey(Category, verbose_name=&#39;文章分类&#39;, on_delete=models.CASCADE)    tags = models.ManyToManyField(Tag, verbose_name=&#39;标签&#39;)    keywords = models.ManyToManyField(Keyword, verbose_name=&#39;文章关键词&#39;,                                    help_text=&#39;文章关键词，用来作为SEO中keywords，最好使用长尾词，3-4个足够&#39;)    class Meta:        verbose_name = &#39;文章&#39;        verbose_name_plural = verbose_name        ordering = [&#39;-create_date&#39;]    def __str__(self):        return self.title[:20]    def get_absolute_url(self):        return reverse(&#39;blog:article&#39;, kwargs={&#39;slug&#39;: self.slug})    def body_to_markdown(self):        return markdown.markdown(self.body, extensions=[            &#39;markdown.extensions.extra&#39;,            &#39;markdown.extensions.codehilite&#39;,        ])    def update_views(self):        self.views += 1        self.save(update_fields=[&#39;views&#39;])    def get_pre(self):        return Article.objects.filter(id__lt=self.id).order_by(&#39;-id&#39;).first()    def get_next(self):        return Article.objects.filter(id__gt=self.id).order_by(&#39;id&#39;).first()</code></pre><p>为什么要用slug给文章起别名呢？这个可能暂且就认为只是为了提升逼格吧</p><p>公告（Activate）表的创建：</p><pre><code class="python"># 公告class Activate(models.Model):    text = models.TextField(&#39;公告&#39;, null=True)    is_active = models.BooleanField(&#39;是否开启&#39;, default=False)    add_date = models.DateTimeField(&#39;提交日期&#39;, auto_now_add=True)    class Meta:        verbose_name = &#39;公告&#39;        verbose_name_plural = verbose_name    def __str__(self):        return self.id</code></pre><p>幻灯片（Carousel）表的创建：</p><pre><code class="python"># 幻灯片class Carousel(models.Model):    number = models.IntegerField(&#39;编号&#39;, help_text=&#39;编号决定图片播放的顺序，图片不要多于5张&#39;)    title = models.CharField(&#39;标题&#39;, max_length=20, blank=True, null=True, help_text=&#39;标题可以为空&#39;)    content = models.CharField(&#39;描述&#39;, max_length=80)    img_url = models.CharField(&#39;图片地址&#39;, max_length=200)    url = models.CharField(&#39;跳转链接&#39;, max_length=200, default=&#39;#&#39;, help_text=&#39;图片跳转的超链接，默认#表示不跳转&#39;)    class Meta:        verbose_name = &#39;图片轮播&#39;        verbose_name_plural = verbose_name        # 编号越小越靠前，添加的时间约晚约靠前        ordering = [&#39;number&#39;, &#39;-id&#39;]    def __str__(self):        return self.content[:25]</code></pre><p>友链（FriendLink）表的创建：</p><pre><code class="python"># 友情链接表class FriendLink(models.Model):    name = models.CharField(&#39;网站名称&#39;, max_length=50)    description = models.CharField(&#39;网站描述&#39;, max_length=100, blank=True)    link = models.URLField(&#39;友链地址&#39;, help_text=&#39;请填写http或https开头的完整形式地址&#39;)    logo = models.URLField(&#39;网站LOGO&#39;, help_text=&#39;请填写http或https开头的完整形式地址&#39;, blank=True)    create_date = models.DateTimeField(&#39;创建时间&#39;, auto_now_add=True)    is_active = models.BooleanField(&#39;是否有效&#39;, default=True)    is_show = models.BooleanField(&#39;是否首页展示&#39;, default=False)    class Meta:        verbose_name = &#39;友情链接&#39;        verbose_name_plural = verbose_name        ordering = [&#39;create_date&#39;]    def __str__(self):        return self.name    def get_home_url(self):        &quot;&quot;&quot;提取友链的主页&quot;&quot;&quot;        u = re.findall(r&#39;(http|https://.*?)/.*?&#39;, self.link)        home_url = u[0] if u else self.link        return home_url    def active_to_false(self):        self.is_active=False        self.save(update_fields=[&#39;is_active&#39;])    def show_to_false(self):        self.is_show = True        self.save(update_fields=[&#39;is_show&#39;])</code></pre><p>这里需要注意一下，luyu -&gt; models.py 中出现的 AUTH_USER_MODEL、SITE_DESCRIPTION、AUTH_USER_MODEL、SITE_KEYWORDS，把它们当作默认字段放在 setting.py 中，便于管理<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python"># 网站描述，用于SEOSITE_DESCRIPTION = &quot;luyu的个人网站，记录python学习之路&quot;# 网站关键词，用于SEOSITE_KEYWORDS = &quot;luyuonism,luyu,网络,IT,技术,博客,Python&quot;</code></pre><p>在文件首部 # 引入 settings.py 文件，即可使用这些字段</p><pre><code class="python">from django.conf import settings</code></pre><p>以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime），max_length 参数限定长度。</p><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li><p>标题应当限定长度，我们设定最大值为100</p></li><li><p>内容不用限定长度，因此用的是TextField字段</p></li><li><p>修改时间直接设定成，auto_now=True，在你修改时，会自动变成当前时间。</p></li><li><p>关于ForeignKey与ManyToManyField，查看<a href="https://docs.djangoproject.com/en/2.1/topics/db/models/" target="_blank" rel="noopener">Django官方文档</a> <a href="http://djangobook.py3k.cn/2.0/chapter05/" target="_blank" rel="noopener">Django中文文档</a></p></li></ul><h4 id="编写-user-用户模型"><a href="#编写-user-用户模型" class="headerlink" title="编写 user 用户模型"></a>编写 user 用户模型</h4><p>blog -&gt; luyu -&gt; models.py 中文章有一个作者外键</p><pre><code class="python">    author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=&#39;作者&#39;, on_delete=models.CASCADE)</code></pre><p>这个外键是网站注册用户，这样用户也可以有发文权限，考虑到以后会扩展用户功能，所以这里还是创建一个用户app比较好。<br>创建app不再赘述, 不要忘了创建app后去配置文件里注册用户app<br>blog -&gt; user -&gt; models.py</p><pre><code class="python"># 继承 AbstractUser ，django 自带用户类，扩展用户个人网站字段，用户头像字段class Ouser(AbstractUser):    # 扩展用户个人网站字段    link = models.URLField(&#39;个人网址&#39;, blank=True, help_text=&#39;提示：网址必须填写以http开头的完整形式&#39;)    # 扩展用户头像字段    avatar = ProcessedImageField(upload_to=&#39;avatar/%Y/%m/%d&#39;,                                 default=&#39;avatar/default.png&#39;,                                 verbose_name=&#39;头像&#39;,                                 processors=[ResizeToFill(80, 80)]                                 )    class Meta:        verbose_name = &#39;用户&#39; # 定义网站管理后台表名        verbose_name_plural = verbose_name        ordering = [&#39;-id&#39;]    def __str__(self):        return self.username</code></pre><h4 id="迁移-user-用户应用模型"><a href="#迁移-user-用户应用模型" class="headerlink" title="迁移 user 用户应用模型"></a>迁移 user 用户应用模型</h4><p>Terminal中执行命令</p><pre><code class="python">python  manage.py  makemigrationspython  manage.py  migrate</code></pre><p>如遇以下问题，</p><pre><code class="python">    File &quot;E:\\ProgramData\\Anaconda3\\lib\\site-packages\\imagekit\\registry.py&quot;, line 3, in &lt;module&gt;        from .utils import autodiscover, call_strategy_methodImportError: cannot import name &#39;autodiscover&#39;</code></pre><p>解决办法：</p><pre><code>E:\ProgramData\Anaconda3\Lib\site-packages\imagekit 中有一个utils文件和utils.py文件，两个文件名发生冲突产生歧义，将utils文件夹手动改为foo</code></pre><pre><code class="python">SystemCheckError: System check identified some issues:ERRORS:auth.User.groups: (fields.E304) Reverse accessor for &#39;User.groups&#39; clashes with reverse accessor for &#39;Ouser.groups&#39;.        HINT: Add or change a related_name argument to the definition for &#39;User.groups&#39; or &#39;Ouser.groups&#39;.auth.User.user_permissions: (fields.E304) Reverse accessor for &#39;User.user_permissions&#39; clashes with reverse accessor for &#39;Ouser.user_permissions&#39;.        HINT: Add or change a related_name argument to the definition for &#39;User.user_permissions&#39; or &#39;Ouser.user_permissions&#39;.user.Ouser.groups: (fields.E304) Reverse accessor for &#39;Ouser.groups&#39; clashes with reverse accessor for &#39;User.groups&#39;.        HINT: Add or change a related_name argument to the definition for &#39;Ouser.groups&#39; or &#39;User.groups&#39;.user.Ouser.user_permissions: (fields.E304) Reverse accessor for &#39;Ouser.user_permissions&#39; clashes with reverse accessor for &#39;User.user_permissions&#39;.        HINT: Add or change a related_name argument to the definition for &#39;Ouser.user_permissions&#39; or &#39;User.user_permissions&#39;.</code></pre><p>解决办法:</p><pre><code>抽象基类创建完成后, 没有在setting中声明, 或者声明错误setting.py 文件中添加一句 AUTH_USER_MODEL = &quot;user.Ouser&quot;</code></pre><pre><code class="python">django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency user.0001_initial on database &#39;default&#39;.</code></pre><p>解决办法:</p><pre><code>删库跑路，把所有表删掉之后，再次执行 python  manage.py  migrate</code></pre><p>以上，即可将新建的这些表添加到我们的数据库 blog 中：</p><pre><code>auth_group, auth_group_permissions,auth_permission,auth_user_groups,auth_user_user_permissions, django_admin_log, django_content_type, django_migrations, django_session,storm_activate,         # 公告表 storm_article,          # 新增的博文表storm_article_keywords, # 这个是博文与关键词的多对多关系表storm_article_tags,     # 这个是博文与标签的多对多关系表storm_bigcategory,      # 导航菜单大分类表storm_carousel,         # 幻灯片storm_category,         # 新增的分类表storm_friendlink,       # 友情链接storm_keyword,          # 关键词表storm_tag，              # 新增的标签表user_ouser,             # 新增扩展用户表user_ouser_groups,      # 自动产生user_ouser_user_permissions # 自动产生</code></pre><p>最后两个表示用户表继承了，Django自带的用户models产生的用户关系表<br>需要说明的是，这里我们只给出了最开始设计时考虑到的情况，在后续开发过程中，可以随时对其进行变更。当数据表信息变动时<br>再次执行</p><pre><code class="python">python  manage.py  makemigrationspython  manage.py  migrate</code></pre><h3 id="通过admin管理后台"><a href="#通过admin管理后台" class="headerlink" title="通过admin管理后台"></a>通过admin管理后台</h3><p>Django 中一个最强大的部分是自动管理接口，在模型中读取元数据来提供一个强大的、生产就绪的接口，使内容提供者能立即用它向站点中添加内容，在这篇文档中，我们讨论如何去激活，使用和自定义Django的站点管理接口。</p><h4 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a>创建管理员账号</h4><p>在浏览器中输入<a href="http://127.0.0.1:8000/admin" target="_blank" rel="noopener">http://127.0.0.1:8000/admin</a>,<br>便可进入到后台管理登录页面，如下图所示：<br><img src="https://i.loli.net/2019/11/09/wtbLJoiRTNW8Fau.png" alt="django登陆" title="django登陆"><br>首先，创建一个能登录管理页面的用户,</p><pre><code class="python">python manage.py createsuperuser</code></pre><p>键入你想要使用的用户名:</p><pre><code>Username: admin</code></pre><p>然后提示你输入想要使用的邮件地址：</p><pre><code>Email address: admin@example.com</code></pre><p>最后一步是输入密码。你会被要求输入两次密码，密码需要满足起码的强度。</p><pre><code>Password:Password (again):Superuser created successfully.</code></pre><h4 id="注册模型到后台"><a href="#注册模型到后台" class="headerlink" title="注册模型到后台"></a>注册模型到后台</h4><p>登录后台后，我们看到此时的后台只有用户、组和最近动作，并没有我们之前创建的我的文章、分类、标签这些内容。<br><img src="https://i.loli.net/2019/11/09/8UgS7sJWwDftc1r.png" alt="django后台" title="django后台"><br>在admin.py中进行配置，将其在后台展现出来：<br>blog -&gt; luyu -&gt; admin.py</p><pre><code class="python">from django.contrib import adminfrom .models import Article, Tag, Category, Carousel, Keyword, FriendLink, BigCategory@admin.register(Article)class ArticleAdmin(admin.ModelAdmin):    # 这个的作用是给出一个筛选机制，一般按照时间比较好    date_hierarchy = &#39;create_date&#39;    exclude = (&#39;views&#39;,)    # 在查看修改的时候显示的属性，第一个字段带有&lt;a&gt;标签，所以最好放标题    list_display = (&#39;id&#39;, &#39;title&#39;, &#39;author&#39;, &#39;create_date&#39;, &#39;update_date&#39;)    # 设置需要添加&lt;a&gt;标签的字段    list_display_links = (&#39;title&#39;,)    # 激活过滤器，这个很有用    list_filter = (&#39;create_date&#39;, &#39;category&#39;)    list_per_page = 50  # 控制每页显示的对象数量，默认是100    filter_horizontal = (&#39;tags&#39;, &#39;keywords&#39;)  # 给多选增加一个左右添加的框    # 限制用户权限，只能看到自己编辑的文章    def get_queryset(self, request):        qs = super(ArticleAdmin, self).get_queryset(request)        if request.user.is_superuser:            return qs        return qs.filter(author=request.user)@admin.register(Tag)class TagAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)@admin.register(Category)class CategoryAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)@admin.register(BigCategory)class BigCategoryAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)# 自定义管理站点的名称和URL标题admin.site.site_header = &#39;网站管理&#39;admin.site.site_title = &#39;博客后台管理&#39;@admin.register(Carousel)class CarouselAdmin(admin.ModelAdmin):    list_display = (&#39;number&#39;, &#39;title&#39;, &#39;content&#39;, &#39;img_url&#39;, &#39;url&#39;)@admin.register(Keyword)class KeywordAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;id&#39;)@admin.register(FriendLink)class FriendLinkAdmin(admin.ModelAdmin):    list_display = (&#39;name&#39;, &#39;description&#39;, &#39;link&#39;, &#39;create_date&#39;, &#39;is_active&#39;, &#39;is_show&#39;)    date_hierarchy = &#39;create_date&#39;    list_filter = (&#39;is_active&#39;, &#39;is_show&#39;)</code></pre><p>此时，再次刷新博客admin页面，即可看到我们创建的表：<br><img src="https://i.loli.net/2019/11/09/XRjFVdeGoNfpbW4.png" alt="刷新admin页面" title="刷新admin页面"><br>我们可以对其进行增加、修改、删除操作, admin 也是 Django 中最方便的一个特性。</p><h3 id="博客首页开发"><a href="#博客首页开发" class="headerlink" title="博客首页开发"></a>博客首页开发</h3><h4 id="添加模板"><a href="#添加模板" class="headerlink" title="添加模板"></a>添加模板</h4><p>前面已经获取了 static、templates 文件，将 static 文件夹整个拷贝到博客项目根目录下，然后在将 templates 文件夹下的 html 文件全部拷贝到到 templates 目录下。</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>Django 中后端的控制都是在视图函数中进行的，也就是 view.py，每创建一个 app，该 app 目录下都会有一个view.py，我们主要就是在这里进行后端代码的书写的。</p><pre><code class="python"># ---------------------------__author__ = &#39;luyuonism&#39;__date__ = &#39;2018/6/5 09:11:43&#39;# ---------------------------from django.views import genericfrom django.shortcuts import get_object_or_404, get_list_or_404from .models import Article, BigCategory, Category, Tag# Create your views here.class IndexView(generic.ListView):    &quot;&quot;&quot;        首页视图,继承自ListVIew，用于展示从数据库中获取的文章列表    &quot;&quot;&quot;    # 获取数据库中的文章列表    model = Article    # template_name属性用于指定使用哪个模板进行渲染    template_name = &#39;index.html&#39;    # context_object_name属性用于给上下文变量取名（在模板中使用该名字）    context_object_name = &#39;articles&#39;</code></pre><h4 id="配置首页路由"><a href="#配置首页路由" class="headerlink" title="配置首页路由"></a>配置首页路由</h4><p>通过 url 将视图函数与模板关联起来</p><p>现在我们有了 index.html 页面，也有了视图函数 IndexView，但是怎么才能通过 127.0.0.1:8000 访问到这个页面呢？django中是通过 url 将这个页面与视图函数关联起来，也就是前后端的API接口。</p><p>添加 urls.py 文件   blog -&gt; luyu</p><p>配置页面路由   blog -&gt; luyu -&gt; urls.py</p><pre><code class="python">from django.conf.urls import urlfrom .views import IndexViewurlpatterns = [    url(r&#39;^$&#39;, IndexView.as_view(template_name=&#39;index.html&#39;), name=&#39;index&#39;)]</code></pre><p><strong>template_name 是指定使用的模板文件，传递给视图，进行数据渲染，后边详讲路由配置博客应用路由</strong></p><p>blog -&gt; blog -&gt; urls.py</p><pre><code class="python">from django.conf.urls import url, includefrom django.contrib import adminurlpatterns = [    # 后台管理应用，django自带    url(r&#39;^admin/&#39;, admin.site.urls),    # storm 应用    url(&#39;&#39;, include(&#39;storm.urls&#39;, namespace=&#39;blog&#39;)),  ]</code></pre><p>此时的项目结构：</p><pre><code>.|-- blog|   |-- luyu                # 博客应用|   |   |-- migrations      # 数据库映射文件|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- admin.py        # 该应用的后台管理系统|   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成|   |   |-- models.py       # 数据模块，使用ORM框架|   |   |-- tests.py        # 自动化测试的模块    |   |   |-- urls.py         # 应用路由    |   |   |-- views.py        # 执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写    |   |-- blog                # 项目的容器|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- settings.py     # 该 Django 项目的设置/配置。|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。|   `-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目|   |-- static              # 静态文件|   |   |-- css|   |   |-- fonts|   |   |-- images|   |   |-- js|   |-- templates           # 模板文件|   |   |-- about.html|   |   |-- donate.html|   |   |-- exchange.html|   |   |-- index.html|   |   |-- message.html|   |   |-- project.html|   |   |-- question.html|   |   |-- resources.html|   |   |-- technique.html|   |   |-- wp-login.html`-- manage.py</code></pre><h4 id="修改静态文件路径"><a href="#修改静态文件路径" class="headerlink" title="修改静态文件路径"></a>修改静态文件路径</h4><p>访问 127.0.0.1:8000 这个页面时，Django 会通过正则表达式解析这个 url，从而判断出该 url 连接到哪个视图函数，我们这里对应的就是 IndexView。然后在 IndexView 中， 将 index.html 传递给前端，并通过浏览器展示给用户，这样我们便配置好了首页。<br><strong>首页样式的加载</strong></p><p>但是在刷新首页时，我们发现并没有样式，样式文件我们放在 static 文件夹中了，而index.html并没有定位到该目录</p><p>配置静态路径<br>blog -&gt; blog -&gt; settings.py</p><pre><code class="python">STATIC_URL = &#39;/static/&#39;STATICFILES_DIRS = [    os.path.join(BASE_DIR, &#39;static&#39;)]</code></pre><p>index.html 中，在第一行添加：</p><pre><code class="python">{% load staticfiles %}</code></pre><p>修改静态文件路径</p><pre><code class="python">&lt;link rel=&#39;stylesheet&#39; id=&#39;l2h_print_style-css&#39;  href=&#39;../static/css/print.min.css&#39; type=&#39;text/css&#39; media=&#39;print&#39; /&gt;&lt;link rel=&#39;stylesheet&#39; id=&#39;style-css&#39;  href=&#39;../static/css/style.css&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;&lt;script type=&#39;text/javascript&#39; src=&#39;../static/js/jquery.min.js&#39;&gt;&lt;/script&gt;</code></pre><p>修改静态文件路径为绝对路径</p><pre><code class="python">&lt;link rel=&#39;stylesheet&#39; id=&#39;l2h_print_style-css&#39;  href=&#39;/static/css/print.min.css&#39; type=&#39;text/css&#39; media=&#39;print&#39; /&gt;&lt;link rel=&#39;stylesheet&#39; id=&#39;style-css&#39;  href=&#39;/static/css/style.css&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;&lt;script type=&#39;text/javascript&#39; src=&#39;/static/js/jquery.min.js&#39;&gt;&lt;/script&gt;</code></pre><p>把静态路径修改为动态路径</p><pre><code class="python">&lt;link rel=&#39;stylesheet&#39; id=&#39;l2h_print_style-css&#39;  href=&#39;{% static 'css/print.min.css' %}&#39; type=&#39;text/css&#39; media=&#39;print&#39; /&gt;&lt;link rel=&#39;stylesheet&#39; id=&#39;style-css&#39;  href=&#39;{% static 'css/style.css' %}&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;&lt;script type=&#39;text/javascript&#39; src=&#39;{% static 'js/jquery.min.js' %}&#39;&gt;&lt;/script&gt;</code></pre><p>以上只是部分示列，要把 index.html文件中的 ../ 按上边的方式全改掉</p><p>绝对路径也可以加载静态文件，为什么要配置动态路径，</p><p>settings.py 中设置的静态路径，/static/ 这里对应前端模板的 /static/, 如果后台 static 文件夹名称修改了，前端那么多 /static/ 都要修改那不得累死，所以这里给 把静态文件路由固定为 /static/.</p><pre><code class="python">STATIC_URL = &#39;/static/&#39;STATICFILES_DIRS = [    os.path.join(BASE_DIR, &#39;static&#39;)]</code></pre><p>这样如果修改了 static 静态文件夹的名称，只需要修改一下 os.path.join(BASE_DIR, ‘static’) 名字即可</p><p>(BASE_DIR, ‘static’) 中的 ‘static’ 名字随便修改<br>配置好静态路径后，重启项目，查看运行效果<br>目前展示的还只是静态页面，首页中博客的内容仍然是<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板</a>的内容</p><p>过程中可能遇到</p><pre><code class="python">&#39;Specifying a namespace in include() without providing an app_name &#39;django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</code></pre><p>的报错，python3 Django 环境下，如果遇到在根目录下urls.py中的include方法的第二个参数namespace添加之后就出错的问题。可以 luyu 目录下的urls.py中的urlpatterns前面加上app_name=’luyu’.</p><h4 id="整理项目结构"><a href="#整理项目结构" class="headerlink" title="整理项目结构"></a>整理项目结构</h4><h5 id="集中管理应用"><a href="#集中管理应用" class="headerlink" title="集中管理应用"></a>集中管理应用</h5><p>在项目根目录下新建 apps 文件，让项目变得更精致，把 luyu 和 user 拷贝到内 apps 文件内<br>现在项目结构</p><pre><code>.|-- blog|   |-- apps|   |   |-- luyu                # 博客应用|   |   |   |-- migrations      # 数据库映射文件|   |   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |   |-- admin.py        # 该应用的后台管理系统|   |   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成|   |   |   |-- models.py       # 数据模块，使用ORM框架|   |   |   |-- tests.py        # 自动化测试的模块        |   |   |   |-- views.py        # 项目业务逻辑主要在这里编写 |   |   |-- user                # 用户应用|   |   |   |-- migrations      |   |   |   |-- __init__.py     |   |   |   |-- admin.py        |   |   |   |-- apps.py     |   |   |   |-- models.py       |   |   |   |-- tests.py          |   |   |   |-- views.py        |   |-- blog                # 项目的容器|   |   |-- __init__.py     # 声明模块，内容默认为空|   |   |-- settings.py     # 该 Django 项目的设置/配置。|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。|   `-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目|   |-- static              # 静态文件|   |   |-- css|   |   |-- fonts|   |   |-- images|   |   |-- js|   |-- templates           # 模板文件|   |   |-- about.html|   |   |-- donate.html|   |   |-- exchange.html|   |   |-- index.html|   |   |-- message.html|   |   |-- project.html|   |   |-- question.html|   |   |-- resources.html|   |   |-- technique.html|   |   |-- wp-login.html`-- manage.py</code></pre><p>把鼠标放在apps上右击鼠标，选择 Mark Directory as -&gt; Sources Root 点击</p><p>在配置文件中配置应用文件路径</p><p>blog -&gt; blog -&gt; settings.py</p><pre><code class="python"># 添加 apps 目录sys.path.insert(0, os.path.join(BASE_DIR, &#39;apps&#39;))</code></pre><h5 id="制作基础模板"><a href="#制作基础模板" class="headerlink" title="制作基础模板"></a>制作基础模板</h5><p>分析一下模板博客页面<br>生活笔记、技术杂谈、福利专区、文章归档、标签、生活笔记下拉菜单、技术杂谈下拉菜单</p><p>这些页面属于同一个页面，只是不同类别展示的文章不同而已</p><p>首页和上边的区别就是多了一个轮播图</p><p>关于自己、给我留言、赞助作者、属于单个静态页面加上一个评论区</p><p>技术交流、提问交流、项目合作、属于单个静态页面</p><p>那么初步分析，可以有两个模板</p><p>一区为顶部基础模板，几乎网站的每个页面都要用到</p><p>二区 为幻灯片，热门推荐，只有首页有</p><p>三区为侧边栏，分类页、标签页、归档页也都有用到</p><p>四区就是内容展示区了，分类页、标签页、详情页都有用到</p><p>综上，用到的地方多的是 一区、三区、四区</p><p>四区基本都是伴随一区、三区出现的，也即四区继承一区或者三区</p><p>所以，需要两个基础模板，就是 一个是一区，一个是一区结合三区</p><p>头部一区称作 base.html、一区加侧边栏三区称作 base_right.html</p><p>base_right.html 继承 base.html</p><p><a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base.html" target="_blank" rel="noopener">base.html</a></p><p><a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_right.html" target="_blank" rel="noopener">base_right.html</a></p><p>index.html 改写一下，<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/index.html" target="_blank" rel="noopener">index.html</a></p><h4 id="Django-工作原理"><a href="#Django-工作原理" class="headerlink" title="Django 工作原理"></a>Django 工作原理</h4><p>视图函数（类），简称视图，是一个简单的 Python 函数（类），它接收 Web 请求并且返回 Web 响应。响应可以是一个网页的 HTML 内容，一个重定向，一个404错误，一个 XML 文档，或者一张图片，甚至一个文件。无论视图本身包含什么逻辑，都要返回响应。代码书写位置无要求，只要它在你当前项目目录下面。除此之外没有更多的要求——可以说 “没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为views.py的文件中</p><p>正确的流程，应该是，先分析前端代码，来配置路由，然后书写视图逻辑</p><p>Django 工作原理：<br>用户发出 http 请求 -&gt; 匹配路由 -&gt; 进入视图 -&gt; 根据用户请求在视图内编写逻辑 -&gt; 把渲染后的 html 代码返给浏览器 -&gt; 浏览器解析后呈现给用户</p><p>用户请求：就是 url(网址)</p><p>路由：Django 根据 用户请求的地址，来判断用户是干啥的，把任务交给指定的视图函数去干活</p><p>视图：接收到路由委派的任务后，开始操作数据库，增、删、查，基本就这些个活，干好后，把渲染后的thml交给浏览器，浏览器解析后展示给用户要看的东西</p><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>blog -&gt;templates -&gt; base.html</p><p>头部引入文件，staticfiles静态文件、blog_tags 自定义模板标签，记得无论那个页面只要用到里边的函数都要在头部引入</p><pre><code class="python">{% load staticfiles %}{% load blog_tags %}&lt;!DOCTYPE HTML&gt;&lt;html&gt;</code></pre><p><a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE.html" target="_blank" rel="noopener">导航栏渲染数据</a></p><p>blog -&gt; luyu -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py"># 创建了新的tags标签文件后必须重启服务器from django import templatefrom ..models import Article, Category, Tag, Carousel, FriendLink, BigCategory, Activate, Keywordfrom django.db.models.aggregates import Countfrom django.utils.html import mark_safeimport re# 注册自定义标签函数register = template.Library()# 获取导航条大分类查询集@register.simple_tagdef get_bigcategory_list():    &quot;&quot;&quot;返回大分类列表&quot;&quot;&quot;    return BigCategory.objects.all()# 返回文章分类查询集@register.simple_tagdef get_category_list(id):    &quot;&quot;&quot;返回小分类列表&quot;&quot;&quot;    return Category.objects.filter(bigcategory_id=id)</code></pre><p>Templatetags:</p><p>必须写的头部</p><pre><code class="py">from django import template# 注册自定义标签函数register = template.Library()</code></pre><p>自定义模版标签，和(view)视图的区别就是不需要接收 request 请求，只需要在模板也即前端页面接收参数，返回需要的数据进行展示即可。也就意味着，除了需要和用户交互的内容，比如用户给某篇章点赞，需要使用 Jquery + ajax 实现无刷新给页面喜欢数量加一，这个就需要 Jquery 接收到用户点击行为后，AJAX 携带信息给指定路由发出请求，视图接收到请求，把处理结果返给 AJAX 实现无数刷新地更新喜欢量。只要不涉及交互，的数据请求都可以放在 Templatetags 处理前端需要展示的数据</p><h4 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h4><p>blog -&gt;templates -&gt; index.html<br>幻灯片部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/indexcarousel.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; luyu -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py"># 获取滚动的大幻灯片查询集、获取左侧的幻灯片查询集，这两个部分用的图片是一样的@register.simple_tagdef get_carousel_index():    return Carousel.objects.filter(number__lte=5)</code></pre><p>在数据库内给幻灯片添加一些图片</p><p>不要忘了在index.html中加载blog_tags</p><pre><code>{% load blog_tags %}</code></pre><h4 id="热门文章"><a href="#热门文章" class="headerlink" title="热门文章"></a>热门文章</h4><p>blog -&gt;templates -&gt; index.html<br>热门文章部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/indexhotposts.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py"># 获取热门排行数据查询集，参数：sort 文章类型， num 数量@register.simple_tagdef get_article_list(sort=None, num=None):    &quot;&quot;&quot;获取指定排序方式和指定数量的文章&quot;&quot;&quot;    if sort:        if num:            return Article.objects.order_by(sort)[:num]        return Article.objects.order_by(sort)    if num:        return Article.objects.all()[:num]    return Article.objects.all()</code></pre><h4 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h4><p>blog -&gt;templates -&gt; index.html<br>文章列表部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/indexarticle.html" target="_blank" rel="noopener">index.html</a>的修改<br>这里没用到自定义模板标签</p><h4 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h4><p>blog -&gt;templates -&gt; base_right.html<br>首先个人联系方式的矢量图没显示出来，需要引入一下矢量图文件<br>首先去awesome官网下载 font-awesome-4.7.0或者拷贝Github项目中的矢量文件，然后把文件放入 static 静态文件中，然后在<br>blog -&gt;templates -&gt; base.html中的head标签引入头部文件的地方导入路径</p><pre><code>&lt;link rel=&#39;stylesheet&#39; id=&#39;page-list-style-css&#39;  href=&#39;/static/font-awesome-4.7.0/css/font-awesome.min.css&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;</code></pre><p>侧边栏热门专题轮播图</p><p>blog -&gt;templates -&gt; base_right.html</p><p>不要忘记在头部引入自定义模板标签 </p><pre><code>{% load blog_tags %}</code></pre><p>热门专题轮播图部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_righthot.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py"># 获取右侧栏热门专题幻灯片查询集@register.simple_tagdef get_carousel_right():    return Carousel.objects.filter(number__gt=5, number__lte=10)</code></pre><p>Carousel表前五个是首页大轮播图、后五个是热门专题轮播图</p><h4 id="文章归档"><a href="#文章归档" class="headerlink" title="文章归档"></a>文章归档</h4><p>blog -&gt;templates -&gt; base_right.html<br>文章归档部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_righarchive.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py">blog -&gt; templatetags -&gt; blog_tags.py# 获取归档文章查询集@register.simple_tagdef get_data_date():    &quot;&quot;&quot;获取文章发表的不同月份&quot;&quot;&quot;    article_dates = Article.objects.datetimes(&#39;create_date&#39;, &#39;month&#39;, order=&#39;DESC&#39;)    return article_dates</code></pre><h4 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h4><p>blog -&gt;templates -&gt; base_right.html<br>猜你喜欢部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_righlove.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py"># 文章相关标签函数，和热门文章使用同一个函数@register.simple_tagdef get_article_list(sort=None, num=None):    &#39;&#39;&#39;获取指定排序方式和指定数量的文章&#39;&#39;&#39;    if sort:        if num:            return Article.objects.order_by(sort)[:num]        return Article.objects.order_by(sort)    if num:        return Article.objects.all()[:num]    return Article.objects.all()</code></pre><p>和热门文章使用同一个函数</p><h4 id="标签云和友情链接"><a href="#标签云和友情链接" class="headerlink" title="标签云和友情链接"></a>标签云和友情链接</h4><p>blog -&gt;templates -&gt; base_right.html<br>标签云和友情链接部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_rightaf.html" target="_blank" rel="noopener">index.html</a>的修改<br>storm -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py"># 获取文章标签信息，参数文章ID@register.simple_tagdef get_article_tag(article_id):    return Tag.objects.filter(article=article_id)</code></pre><p>有点乱，<a href="https://github.com/luyuonism/blog" target="_blank" rel="noopener">完整代码</a></p><h4 id="渲染分类页面数据"><a href="#渲染分类页面数据" class="headerlink" title="渲染分类页面数据"></a>渲染分类页面数据</h4><p>在 blog -&gt; templates 中新建文件 content.html</p><p>生活笔记分类</p><p>blog -&gt; templates -&gt; <a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/content.html" target="_blank" rel="noopener">content.html</a></p><p>自定义模板标签</p><p>blog -&gt; templatetags -&gt; blog_tags.py</p><pre><code class="py">@register.simple_tagdef get_title(category):    a = BigCategory.objects.filter(slug=category)    if a:        return a[0]</code></pre><p>头部引入</p><pre><code>{% load blog_tags %}</code></pre><p>首页 大分类跳转地址</p><pre><code>&lt;a href=&quot;{% url 'blog:category' big.slug '' %}&quot;&gt;{{ big.name }}&lt;/a&gt;</code></pre><p>首页大分类下拉菜单小分类地址</p><pre><code>&lt;a href=&quot;{% url 'blog:category'  big.slug   c.slug  %}&quot;&gt;{{ c.name }}&lt;/a&gt;</code></pre><p>配置路由</p><pre><code class="py"># 分类页面url(r&#39;^category/(?P&lt;bigslug&gt;.*?)/(?P&lt;slug&gt;.*?)&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;category&#39;),</code></pre><p>简单理解路由，这里都是我的个人理解可能不会有官方文档解释的科学，如果读完还有疑惑不要纠结，问题不大，刚开始接触不需要理解的太深入。</p><pre><code class="py">{% url 'blog:category' big.slug '' %}</code></pre><p>big.slug：是从 bigcategory 表取出的数据，是导航菜单，大分类字段</p><p>Django 的路由其实就是使用正则表达式匹配前端 http 请求的路径</p><p>http 请求可以理解为，前台的点击事件，比如用户点击 生活笔记 或者 个人随笔</p><p>就是告诉服务器我想看这些内容，那么怎么告诉，就是发送 http 请求，这里 {% url 'blog:category' big.slug '' %} 就是 Django 模板定义请求路径的方式</p><p>blog：主路由 url(‘’, include(‘storm.urls’, namespace=’blog’))， 定义应用空间名 namespace 为 blog，这样后台修改应用 storm 名不会影响前台渲染数据，和配置静态路径一样的道理</p><p>category：是storm应用路由 url(r’^category/(?P.?)/(?P.?)’, IndexView.as_view(template_name=’content.html’), name=’category’) 中的开始匹配位置</p><p>比如 这里用户点击生活笔记，那么他的请求路经是</p><p>浏览器解析</p><pre><code class="py">{% url 'blog:category' big.slug '' %}</code></pre><p>后路径即为<br>http://域名.com/category/diary</p><p>则 Django 首先去 项目容器 blog -&gt; blog -&gt; urls.py 中匹配这个路径，匹配的规则是首先精准匹配这个路径，就是拿 category 去对比 路由的第一个参数</p><p>发现没有 category，如果未匹配到，则进行模糊匹配，就是直接走路由第一个参数为空的路由，那么就进到了</p><p>url(‘’, include(‘storm.urls’, namespace=’blog’)) 这里，include 的第一个参数指向的是子路由位置，</p><p>通过这里进入 blog -&gt; storm -&gt; urls.py 继续拿 category 匹配路径，在这里匹配到了</p><pre><code class="py">url(r&#39;^category/(?P&lt;bigslug&gt;.*?)/(?P&lt;slug&gt;.*?)&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;category&#39;)</code></pre><p>好了第一个http请求已经找到归宿</p><pre><code class="py">{% url 'blog:category' big.slug '' %}</code></pre><p>big.slug：第一个参数 就是 diary，通过 正则匹配到 diary</p><p>‘’：第二个参数为空，因为这里请求的是大分类，但是大分类和小分类这里使用的是同一个路由，所以要置空</p><p>如果 用户点击个人随笔，那么请求的路经是 http://域名.com/category/diary/life</p><pre><code class="py">{% url 'blog:category'  big.slug   c.slug  %}</code></pre><p>big.slug：第一个参数，是从数据库中取出的大分类，即为 diary</p><p>c.slug：第二个参数是从 category表取出的文章分类字段，即为 life</p><h4 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h4><p>关于自己(about)、给我留言((message)、赞助作者(donate)、技术交流(exchange)、提问交流(question)、项目合作(project)、属于同一类页面，都是静态展示页面 所以要单独创建页面</p><p>blog -&gt; templates -&gt; about.html<br>配置路由</p><pre><code class="py">url(r&#39;^category/about/$&#39;, AboutView, name=&#39;about&#39;),</code></pre><p>创建视图</p><pre><code class="py">def AboutView(request):    return render(request, &#39;about.html&#39;, {&#39;category&#39;: &#39;about&#39;})</code></pre><p>生活笔记、技术杂谈、福利专区、生活笔记下拉菜单、技术杂谈下拉菜单、标签云、归档、都属于同一类，模仿实现即可</p><h3 id="博客详情页面"><a href="#博客详情页面" class="headerlink" title="博客详情页面"></a>博客详情页面</h3><p>博客的详情页同样继承自 base.html 模板，侧边栏就不需要了</p><p>blog -&gt; luyu -&gt; view.py</p><pre><code class="py">class DetailView(generic.DetailView):    &quot;&quot;&quot;        Django有基于类的视图DetailView,用于显示一个对象的详情页，我们继承它    &quot;&quot;&quot;    # 获取数据库中的文章列表    model = Article    # template_name属性用于指定使用哪个模板进行渲染    template_name = &#39;article.html&#39;    # context_object_name属性用于给上下文变量取名（在模板中使用该名字）    context_object_name = &#39;article&#39;    def get_object(self):        obj = super(DetailView, self).get_object()        # 设置浏览量增加时间判断,同一篇文章两次浏览超过半小时才重新统计阅览量,作者浏览忽略        u = self.request.user        ses = self.request.session        the_key = &#39;is_read_{}&#39;.format(obj.id)        is_read_time = ses.get(the_key)        if u != obj.author:            if not is_read_time:                obj.update_views()                ses[the_key] = time.time()            else:                now_time = time.time()                t = now_time - is_read_time                if t &gt; 60 * 30:                    obj.update_views()                    ses[the_key] = time.time()        # 文章可以使用markdown书写，带格式的文章，像csdn写markdown文章一样        md = markdown.Markdown(extensions=[            &#39;markdown.extensions.extra&#39;,            &#39;markdown.extensions.codehilite&#39;,            TocExtension(slugify=slugify),        ])        obj.body = md.convert(obj.body)        obj.toc = md.toc        return obj    def get_context_data(self, **kwargs):        context = super(DetailView, self).get_context_data(**kwargs)        context[&#39;category&#39;] = self.object.id        return context</code></pre><p>blog -&gt; luyu -&gt; urls.py</p><pre><code class="py">from django.conf.urls import urlfrom .views import IndexView, DetailViewurlpatterns = [    # 首页    url(r&#39;^$&#39;, IndexView.as_view(template_name=&#39;index.html&#39;), name=&#39;index&#39;),  # 主页，自然排序    # 给我留言    url(r&#39;^category/message/$&#39;, MessageView, name=&#39;message&#39;),    # 关于自己    url(r&#39;^category/about/$&#39;, AboutView, name=&#39;about&#39;),    # 赞助作者    url(r&#39;^category/donate/$&#39;, DonateView, name=&#39;donate&#39;),    # 技术交流    url(r&#39;^category/exchange/$&#39;, ExchangeView, name=&#39;exchange&#39;),    # 项目合作    url(r&#39;^category/project/$&#39;, ProjectView, name=&#39;project&#39;),    # 提问交流    url(r&#39;^category/question/$&#39;, QuestionView, name=&#39;question&#39;),    # 分类页面    url(r&#39;^category/(?P&lt;bigslug&gt;.*?)/(?P&lt;slug&gt;.*?)&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;category&#39;),    # 归档页面    url(r&#39;^date/(?P&lt;year&gt;\d+)/(?P&lt;month&gt;\d+)/$&#39;, IndexView.as_view(template_name=&#39;archive.html&#39;), name=&#39;date&#39;),    # 标签页面    url(r&#39;^tag/(?P&lt;tag&gt;.*?)/$&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;tag&#39;),    # 文章详情页面    url(r&#39;^article/(?P&lt;slug&gt;.*?)/$&#39;, DetailView.as_view(), name=&#39;article&#39;),]</code></pre><p>新添加的路由</p><pre><code class="py">url(r&#39;^article/(?P&lt;slug&gt;.*?)/$&#39;, DetailView.as_view(), name=&#39;article&#39;),</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django–Django是一个由Python编写的开放源代码的Web应用框架。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="django" scheme="https://luyuonism.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>MySql</title>
    <link href="https://luyuonism.github.io/2018/06/05/sql/"/>
    <id>https://luyuonism.github.io/2018/06/05/sql/</id>
    <published>2018-06-05T01:11:43.000Z</published>
    <updated>2019-11-25T03:13:05.864Z</updated>
    
    <content type="html"><![CDATA[<p>结构化查询语言</p><a id="more"></a><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><pre><code class="mysql">create database shop;</code></pre><h1 id="一-数据库与SQL"><a href="#一-数据库与SQL" class="headerlink" title="一 数据库与SQL"></a>一 数据库与SQL</h1><h2 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h2><h3 id="我们身边的数据库"><a href="#我们身边的数据库" class="headerlink" title="我们身边的数据库"></a>我们身边的数据库</h3><ul><li>例子：图书馆</li><li>数据库 DB</li><li>数据库管理系统 DBMS</li></ul><h3 id="为什么DBMS那么重要"><a href="#为什么DBMS那么重要" class="headerlink" title="为什么DBMS那么重要"></a>为什么DBMS那么重要</h3><ul><li>多人共享数据</li><li>提供操作大量数据所需的格式</li><li>读写自动化</li><li>应对突发事故</li></ul><h3 id="DBMS的种类"><a href="#DBMS的种类" class="headerlink" title="DBMS的种类"></a>DBMS的种类</h3><ul><li>层次数据库 HDB</li><li>关系数据库 RDB<pre><code>SQL 结构化查询语言RDBMS 关系数据库管理系统 --- Oracle Database(甲骨文)/SQL Server(微软)/DB2(IBM)/PostgreSQL(开源的RDBMS)/MySQL(开源的RDBMS)OODB 面向对象数据库XMLDB XML数据库KVS 键值存储系统</code></pre></li></ul><h2 id="数据库的结构"><a href="#数据库的结构" class="headerlink" title="数据库的结构"></a>数据库的结构</h2><h3 id="RDBMS的常见系统结构-客户端-服务器类型c-s类型"><a href="#RDBMS的常见系统结构-客户端-服务器类型c-s类型" class="headerlink" title="RDBMS的常见系统结构(客户端/服务器类型c/s类型)"></a>RDBMS的常见系统结构(客户端/服务器类型c/s类型)</h3><p><img src="https://i.loli.net/2019/11/10/68wkWgO1TYCNsoF.png" alt="系统结构" title="系统结构"></p><h3 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h3><p>数据库表格一个单元格中无法输入2个数据</p><h2 id="SQL概要"><a href="#SQL概要" class="headerlink" title="SQL概要"></a>SQL概要</h2><h3 id="标准SQL"><a href="#标准SQL" class="headerlink" title="标准SQL"></a>标准SQL</h3><h3 id="SQL语句及其种类"><a href="#SQL语句及其种类" class="headerlink" title="SQL语句及其种类"></a>SQL语句及其种类</h3><ul><li>DDL 数据定义语言<pre><code>CREATE 创建数据库和表等对象DROP 删除数据库和表等对象ALTER 修改数据库和表等对象的结构</code></pre></li><li>DML 数据操作语言<pre><code>SELECT 查询表中数据INSERT 向表中插入数据UPDTE 更新表中数据DELETE 删除表中数据</code></pre></li><li>DCL 数据控制语言<pre><code>COMMIT 确认对数据库中的数据进行修改ROLLBACK 取消对数据库中的数据进行变更GRANT 赋予用户操作权限REVOKE 取消用户的操作权限</code></pre></li></ul><h3 id="SQL的基本书写规则"><a href="#SQL的基本书写规则" class="headerlink" title="SQL的基本书写规则"></a>SQL的基本书写规则</h3><p>以(;)分号结尾<br>不区分关键字大小写<br>常数(字符串、日期、数字)的书写方式是固定的<br>单词需要用半角空格或者换行来分隔</p><h2 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h2><h3 id="表的内容的创建"><a href="#表的内容的创建" class="headerlink" title="表的内容的创建"></a>表的内容的创建</h3><p><img src="https://i.loli.net/2019/11/10/BcyCeAWULs2HtTl.png" alt="实例表" title="实例表"></p><h3 id="数据库的创建-CREATE-DATABASE语句"><a href="#数据库的创建-CREATE-DATABASE语句" class="headerlink" title="数据库的创建(CREATE DATABASE语句)"></a>数据库的创建(CREATE DATABASE语句)</h3><h3 id="表的创建-CREATE-TABLE语句"><a href="#表的创建-CREATE-TABLE语句" class="headerlink" title="表的创建(CREATE TABLE语句)"></a>表的创建(CREATE TABLE语句)</h3><pre><code class="sql">CREATE TABLE Product(product_id       CHAR(4)       NOT NULL,product_name     VARCHAR(100)  NOT NULL,product_type     VARCHAR(32)   NOT NULL,sale_price       INTEGER       ,purchase_price   INTEGER       ,regist_date      DATE          ,PRIMARY KEY (product_id));</code></pre><h2 id="表的删除和更新-DROP-TABLE-ALTER-TABLE"><a href="#表的删除和更新-DROP-TABLE-ALTER-TABLE" class="headerlink" title="表的删除和更新(DROP TABLE/ALTER TABLE)"></a>表的删除和更新(DROP TABLE/ALTER TABLE)</h2><p>删除表</p><pre><code class="sql">DROP TABLE Product;</code></pre><p>更新表结构</p><pre><code class="sql">ALTER TABLE Product ADD COLUMN product_name_pinyin VARCHAR(100);</code></pre><p>删除列</p><pre><code class="sql">ALTER TABLE Product DROP COLUMN product_name_pinyin;</code></pre><p>变更表格名字<br>先创建一个 Productbackup</p><pre><code class="sql">CREATE TABLE Productbackup(product_id       CHAR(4)       NOT NULL,product_name     VARCHAR(100)  NOT NULL,product_type     VARCHAR(32)   NOT NULL,sale_price       INTEGER       ,purchase_price   INTEGER       ,regist_date      DATE          ,PRIMARY KEY (product_id));</code></pre><p>变更表格名字</p><pre><code class="sql">ALTER TABLE Productbackup RENAME TP Productbbk;</code></pre><h2 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a>查询基础</h2><h3 id="SELECT-语句基础"><a href="#SELECT-语句基础" class="headerlink" title="SELECT 语句基础"></a>SELECT 语句基础</h3><h4 id="列的查询"><a href="#列的查询" class="headerlink" title="列的查询"></a>列的查询</h4><p>获取product id/ name/ price 三列内容</p><pre><code class="sql">SELECT product_id, product_name, purchase_price FROM Product;</code></pre><p>查询所有列</p><pre><code class="sql">SELECT * FROM Product;</code></pre><p>设定别名</p><pre><code class="sql">SELECT product_id AS id,product_name      AS name,purchase_price    AS priceFROM Product;</code></pre><p>中文别名</p><pre><code class="sql">SELECT product_id AS &quot;商品编号&quot;,product_name      AS &quot;商品名称&quot;,purchase_price    AS &quot;进货单价&quot;FROM Product;</code></pre><h4 id="常数查询-字符串常数-数字常数-日期常数"><a href="#常数查询-字符串常数-数字常数-日期常数" class="headerlink" title="常数查询(字符串常数/数字常数/日期常数)"></a>常数查询(字符串常数/数字常数/日期常数)</h4><pre><code class="sql">SELECT &#39;商品&#39; AS string,38            AS number,&#39;2009-02-24&#39;  AS date,product_id, product_nameFROM Product;</code></pre><img src="/image/常数查询.png"><h3 id="从结果中删除重复行"><a href="#从结果中删除重复行" class="headerlink" title="从结果中删除重复行"></a>从结果中删除重复行</h3><pre><code class="sql">SELECT DISTINCT product_typeFROM Product;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构化查询语言&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="django" scheme="https://luyuonism.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>黑马面试宝典</title>
    <link href="https://luyuonism.github.io/2018/03/05/heima/"/>
    <id>https://luyuonism.github.io/2018/03/05/heima/</id>
    <published>2018-03-05T04:12:33.000Z</published>
    <updated>2019-11-21T01:15:26.186Z</updated>
    
    <content type="html"><![CDATA[<p>黑马面试宝典</p><a id="more"></a><div class="row">    <embed src="/Python面试宝典Version8.1.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;黑马面试宝典&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="interview" scheme="https://luyuonism.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>python练习</title>
    <link href="https://luyuonism.github.io/2018/03/05/pythonexercise/"/>
    <id>https://luyuonism.github.io/2018/03/05/pythonexercise/</id>
    <published>2018-03-05T04:03:43.000Z</published>
    <updated>2019-11-22T07:38:14.962Z</updated>
    
    <content type="html"><![CDATA[<p>python练习题</p><a id="more"></a><p><a href="#什么是Python">什么是Python</a><br><a href="#PEP8">PEP8</a><br><a href="#python里面如何拷贝一个对象？">python里面如何拷贝一个对象？</a><br><a href="#python的内存管理是怎样的？">python的内存管理是怎样的？</a><br><a href="#什么是lambda函数？它有什么好处？">什么是lambda函数？它有什么好处？</a><br><a href="#python自省">python自省</a><br><a href="#谈一谈python的装饰器">谈一谈python的装饰器</a><br><a href="#python元类">python元类</a><br><a href="#列举Http请求中常见的请求方式">列举Http请求中常见的请求方式</a><br><a href="#谈谈你对HTTP协议的认识">谈谈你对HTTP协议的认识</a><br><a href="#简述MVC模式和MVT模式">简述MVC模式和MVT模式</a><br><a href="#简述Django请求生命周期">简述Django请求生命周期</a><br><a href="#django中间件生命周期">django中间件生命周期</a><br><a href="#简述什么是FBV和CBV">简述什么是FBV和CBV</a><br><a href="#对ORM的理解">对ORM的理解</a><br><a href="#常用视图响应的方式">常用视图响应的方式</a><br><a href="#django中间件的5个方法">django中间件的5个方法</a><br><a href="#django中csrf的实现机制">django中csrf的实现机制</a><br><a href="#cookie和session的区别">cookie和session的区别</a><br><a href="#django orm 中所有的方法">django orm 中所有的方法</a><br><a href="#现有字典d={‘a’:24，’g’:52，’l’:12，’k’:33}请按字典中的value值进行排序">现有字典d={‘a’:24，’g’:52，’l’:12，’k’:33}请按字典中的value值进行排序</a><br><a href="#django orm 中所有的方法">django orm 中所有的方法</a></p><h2 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a><a name="#什么是Python">什么是Python</a></h2><p>Python是种解释型语言。这就是说，与C语言和C衍生语言不同，Python代码在运行前不需要编译。其他的解释型语言还包括PHP和Ruby；<br>Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。可以直接编写类似x=111和x=”I’m a string”这样的代码，程序不会报错；<br>Python非常适合面向对象的编程，因为支持通过组合composition与继承inheritance的方式定义类class。<br>Python中没有访问说明符access specifier，类似C++中的public和private。<br>Python语言中，函数是第一类对象。这指的是它们可以被指定给变量，函数既能返回函数类型，也可以接受函数作为输入。类也是第一类对象；<br>Python代码编写快，但运行速度比编译语言通常要慢。好在Python允许加入基于C语言编写扩展，因此我们能够优化代码，消除瓶颈，这点通常是可以实现的。Numpy就是一个很好地例子，它运行速度真的非常快，因为很多算术运算其实不是通过Python实现的。<br>Python的用途非常广泛：网络应用，科学建模，自动化和大数据应用等。它也常被用作“胶水语言”帮助其他语言和组件改善其运行状况；<br>Python让困难的事变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。</p><h2 id="PEP8"><a href="#PEP8" class="headerlink" title="PEP8"></a><a name="#PEP8">PEP8</a></h2><p>PEP8是一个编程规范，内容是一些关于如何让你的程序更具可读性的建议。<br>主要内容包括代码编排、文档编排、空格使用、注释、文档描述、命名规范、编码建议等等。</p><h2 id="python里面如何拷贝一个对象？"><a href="#python里面如何拷贝一个对象？" class="headerlink" title="python里面如何拷贝一个对象？"></a><a name="#python里面如何拷贝一个对象？">python里面如何拷贝一个对象？</a></h2><ol><li>对象赋值</li></ol><p><strong>赋值（=）</strong>，赋值的本质就是让多个变量同时引用同一个对象的地址，修改其中任意一个变量都会影响到另一个。</p><ul><li>对<strong>不可变对象赋值</strong>，实际就是在内存中<strong>开辟一片空间指向新的对象</strong>，原不可变对象不会被修改。<br><img src="https://i.loli.net/2019/11/15/xX397KNi8BqISel.png" alt="不可变对象赋值.png" title="不可变对象赋值"><pre><code class="py">a = 1print(a, id(a))  # 1 1413639232b = aprint(b, id(b))  # 1 1413639232a = 2print(a, id(a), b, id(b))  # 2 1413639264 1 1413639232</code></pre></li><li><strong>可变对象</strong>保存的并不是真正的对象数据，而是对象的引用。当对可变对象进行赋值时，<strong>只是将可变对象中保存的引用指向了新的对象。（地址没变）</strong><br><img src="https://i.loli.net/2019/11/15/X62Ee9B4FNydVG1.png" alt="可变对象赋值.png" title="可变对象赋值"><pre><code class="py">l1 = [1, 2, 3, [1, 2]]print(l1, id(l1))  # [1, 2, 3, [1, 2]] 1615735547144l2 = l1print(l2, id(l2))  # [1, 2, 3, [1, 2]] 1615735547144l1[3][0] = 11print(l1, id(l1), l2, id(l2))  # [1, 2, 3, [11, 2]] 1615735547144 [1, 2, 3, [11, 2]] 1615735547144</code></pre></li></ul><ol start="2"><li><strong>浅拷贝</strong>：拷贝父对象，不会拷贝对象的内部的子对象。（<strong>顶层拷贝值，底层拷贝引用</strong>）{copy模块的copy.copy()函数}</li></ol><ul><li><strong>不可变对象</strong>只在修改的时候才会在内存中开辟新的空间， 而拷贝实际上是让多个对象同时指向一个引用，<strong>和对象的赋值没区别</strong>。<pre><code class="py">import copya = 1print(a, id(a))    # 1 1413639232b = copy.copy(a)print(b, id(b))    # 1 1413639232a = 2print(a, id(a), b, id(b))   # 2 1413639264 1 1413639232</code></pre></li><li><strong>可变对象</strong>的拷贝，会在内存中开辟一个新的空间来保存拷贝的数据。当再改变之前的对象时，对拷贝之后的对象没有任何影响。（<strong>顶层拷贝值，底层拷贝引用</strong>）<br><img src="https://i.loli.net/2019/11/15/dDzm9Q3OkpqoKv8.png" alt="可变对象拷贝1.png" title="可变对象拷贝1"><br><img src="https://i.loli.net/2019/11/15/H895qgwMEmsTDUS.png" alt="可变对象拷贝2.png" title="可变对象拷贝2"><pre><code class="py">l1 = [1, 2, 3]print(l1, id(l1))   # [1, 2, 3] 2576411846088l2 = copy.copy(l1)print(l2, id(l2))   # [1, 2, 3] 2576411846024l1[0] = 11print(l1, id(l1), l2, id(l2))   # [11, 2, 3] 2576411846088 [1, 2, 3] 2576411846024</code></pre><pre><code class="py">l1 = [1, 2, 3, [1, 2]]print(l1, id(l1))   # [1, 2, 3, [1, 2]] 1595652433288l2 = copy.copy(l1)print(l2, id(l2))   # [1, 2, 3, [1, 2]] 1595652433544l1[3][0] = 11print(l1, id(l1), l2, id(l2))   # [1, 2, 3, [11, 2]] 1595652433288 [1, 2, 3, [11, 2]] 1595652433544</code></pre>再举一个例子：（顶层拷贝值，底层拷贝引用） a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。<br><img src="https://i.loli.net/2019/11/15/pCTkmRcHu8j5Doy.png" alt="例1.png" title="例1"></li></ul><ol start="3"><li><strong>深拷贝</strong>：<strong>完全拷贝</strong>了父对象及其子对象。深拷贝就是将顶级对象以及子对象的值同时复制给新对象，此时<strong>修改任何一个都不会影响另一个</strong>。{copy模块的 copy.deepcopy()函数}</li></ol><ul><li><strong>不可变对象的深拷贝</strong>:<pre><code class="py">import copya = 1print(a, id(a))  # 1 1413639232b = copy.deepcopy(a)print(b, id(b))  # 1 1413639232a = 2print(a, id(a), b, id(b))  # 2 1413639264 1 1413639232</code></pre></li><li><strong>可变对象的深拷贝</strong>:<br><img src="https://i.loli.net/2019/11/15/wAQEXyISLzaPH5c.png" alt="可变对象深拷贝.png" title="可变对象深拷贝"><pre><code class="py">l1 = [1, 2, 3]print(l1, id(l1))   # [1, 2, 3] 2062148953544l2 = copy.deepcopy(l1)print(l2, id(l2))   # [1, 2, 3] 2062148953480l1[0] = 11print(l1, id(l1), l2, id(l2))  # [11, 2, 3] 2062148953544 [1, 2, 3] 2062148953480</code></pre><pre><code class="py">l1 = [1, 2, 3, [1, 2]]print(l1, id(l1))  # [1, 2, 3, [1, 2]] 1911038862728l2 = copy.deepcopy(l1)print(l2, id(l2))  # [1, 2, 3, [1, 2]] 1911038881544l1[3][0] = 11print(l1, id(l1), l2, id(l2))  # [1, 2, 3, [11, 2]] 1911038862728 [1, 2, 3, [1, 2]] 1911038881544</code></pre></li></ul><p><strong>总结</strong>：</p><ul><li>不可变对象在赋值时会开辟新空间。</li><li>可变对象在赋值时，修改一个的值，另一个也会发生改变。</li><li>深、浅拷贝对不可变对象拷贝时，不开辟新空间，相当于赋值操作。</li><li>浅拷贝在拷贝时，只拷贝第一层中的引用，如果元素是可变对象，并且被修改，那么拷贝的对象也会发生变化。</li><li>深拷贝在拷贝时，会逐层进行拷贝，直到所有的引用都是不可变对象为止。</li><li>大多数情况下，编写程序时，都是使用浅拷贝，除非有特定的需求。</li><li>浅拷贝的优点：拷贝速度快，占用空间少，拷贝效率高</li></ul><h2 id="python的内存管理是怎样的？"><a href="#python的内存管理是怎样的？" class="headerlink" title="python的内存管理是怎样的？"></a><a name="#python的内存管理是怎样的？">python的内存管理是怎样的？</a></h2><p>答:python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。为python的堆空间分配内存的是python的内存管理模块进行的，核心api会提供一些访问该模块的方法供程序员使用。python自有的垃圾回收机制回收并释放没有被使用的内存供别的程序使用。<br>详解python的内存管理:</p><ol><li><p>对象的内存使用<br>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵.<br>首先, python的赋值语句：</p><pre><code class="py">a = 1</code></pre><p>整数“1”为一个对象，存储在内存空间中。a是一个引用。利用赋值语句，将引用a指向对象1。Python是动态类型的语言，对象与引用分离。<br>Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。<br>下面通过一系列的实验，可以通过python的内置函数id()，来探索对象在内存的存储:</p><pre><code class="py">&gt;&gt;&gt; a = 1&gt;&gt;&gt; id(a)140035503539424  # 内存地址的十进制表示&gt;&gt;&gt; hex(id(a))&#39;0x7f5c8e71c4e0&#39;  # 内存地址的十六进制表示</code></pre><p>在python中整数和短小的字符，python都会缓存这些对象，以便重复使用，当我们创建多个等于1的引用的时候，实际是让所有引用都指向同一个对象：</p><pre><code class="py">&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(b)140035503539424  # 等于上面id(a)的值</code></pre><p>对比可以看出a和b实际是指向同一个对象的不同引用。<br>为了校验两个引用指向同一个对象，我们可以用“is”来判断。is用于判断两个引用所指的对象是否相同。</p><pre><code class="py">a = 1b = 1print(a is b)Truea = &quot;good&quot;b = &quot;good&quot;print(a is b)Truea = &quot;very good morning&quot;b = &quot;very good morning&quot;print(a is b)True   # 如果此时是False，与我的为True不同，实际是python版本原因# Python2.3简单整数缓存范围是(-1,100)，Python2.5.4以后简单整数缓存范围至少是(-5,256)。所有的短字符也都在缓存区。a = &quot;为了校验两个引用指向同一个对象，我们可以用“is”来判断。is用于判断两个引用所指的对象是否相同。&quot;b = &quot;为了校验两个引用指向同一个对象，我们可以用“is”来判断。is用于判断两个引用所指的对象是否相同。&quot;print(a is b)False  # 增加了字符串的长度，结果也是Falsea = []b = []print(a is b)False</code></pre><p>根据上面的运行结果，可以看到由于python缓存了整数和短字符串，因此每个对象只存有一份。比如所有的1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身，长的字符串和其他对象可以有多个相同对象，可以使用赋值语句创建出新的对象。<br>在python中，每个对象都有存有指向该对象的引用总数，即<strong>引用计数</strong>(reference count)<br>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，会创建一个临时引用，所以结果会比预期多1</p><pre><code class="py">from sys import getrefcounta = [1, 2, 3]print(getrefcount(a))# 2b = aprint(getrefcount(b))# 3</code></pre><p>getrefcount()返回的结果分别是2,3，而不是1,2或者2,2</p></li><li><p>对象引用对象<br>python的一个容器对象（container），比如列表字典等，可以包含多个对象。实际上，容器对象中包含的并不是对象本身，而是指向各个元素对象的引用。</p><pre><code class="py">class from_obj(object): def __init__(self, to_obj):     self.to_obj = to_objb = [1,2,3]a = from_obj(b)print(id(a.to_obj))print(id(b))# 140035473779144# 140035473779144</code></pre><p>可以看到a引用了对象b。<br>对象引用对象是python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值“a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。<br>当一个对象a被另一个对象b引用时，a的引用计数将增加1。</p><pre><code class="py">from sys import getrefcounta = [1, 2, 3]print(getrefcount(a))b = [a, a]print(getrefcount(a))# 2# 4</code></pre><p>容器对象引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系。<br><a href="https://mg.pov.lt/objgraph/" target="_blank" rel="noopener">objgraph</a>是python的一个第三方包。<br><code>pip install objgraph</code> 使用objgraph需要安装xdot。根据自己的系统发行版本安装。<br><code>sudo pacman -S xdot</code> 或者 <code>sudo apt install xdot</code>, <code>sudo yun install xdot</code></p><pre><code class="py">x = [1, 2, 3]y = [x, dict(key1=x)]z = [y, (x, y)]import objgraphobjgraph.show_refs([z], filename=&#39;ref_topo.png&#39;)</code></pre><p><img src="https://i.loli.net/2019/11/15/R5WLcdbVGZTQESo.png" alt="引用环.png" title="引用环"><br>两个对象可能互相引用，从而构成所谓的引用环（reference cycle）</p><pre><code class="py">&gt;&gt;&gt; a = []&gt;&gt;&gt; b = [a]&gt;&gt;&gt; a.append(b)&gt;&gt;&gt; a[[[...]]]</code></pre><p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p><pre><code class="py">&gt;&gt;&gt; a = []&gt;&gt;&gt; a.append(a)&gt;&gt;&gt; print(getrefcount(a))3</code></pre><p>引用环会给垃圾回收机制带来很大的麻烦，后面详细说明。</p></li><li><p>引用减少<br>某个引用对象的引用计数可能减少。比如使用del关键字删除某个引用</p><pre><code class="py">&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; print(getrefcount(b))3&gt;&gt;&gt; del a&gt;&gt;&gt; print(getrefcount(b))2</code></pre><p>del也可以删除容器中的元素，比如：</p><pre><code class="py">&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; del a[0]&gt;&gt;&gt; print(a)[2, 3]&gt;&gt;&gt; b = {&quot;q&quot;: 1, &quot;w&quot;:2}&gt;&gt;&gt; b{&#39;q&#39;: 1, &#39;w&#39;: 2}&gt;&gt;&gt; del b[&quot;q&quot;]&gt;&gt;&gt; b{&#39;w&#39;: 2}</code></pre><p>如果某个引用指向对象a，当这个引用被重新定向到其他对象b的时候，对象a的引用计数会减少</p><pre><code class="py">&gt;&gt;&gt; from sys import getrefcount... ... a = [1, 2, 3]... b = a... print(getrefcount(b))... ... a = 1... print(getrefcount(b))32</code></pre></li><li><p>垃圾回收<br>当python中的对象越来越多，他占据的内存也会越来越大。不过不需要担心太多，python会在适当的时候启动垃圾 <code>回收机制(garbage collection)</code>，将没用的对象清除，在许多语言中都有垃圾回收机制，比如Java和Ruby。<br>从基本原理来说，当一个对象的引用计数降为0的时候，说明没有任何引用指向对象，这时候该对象就成为需要被清除的垃圾了。比如某个新建对象，分配给某个引用，引用数为1,当引用被删除之后，引用数为0，那么该对象就可以被垃圾回收。</p><pre><code class="py">a = [1,2,3]del a</code></pre><p><code>del a</code> 之后已经没有任何引用指向[1,2,3]了，用户不可能通过任何方式接触或者动用这个对象，这个对象如果继续待在内存里，就成了不健康的数据。当python的<strong>垃圾回收</strong>机制启动的时候，python扫描到这个引用为0的对象，就会将它所占据的内存清空。<br>然而清理过程是个费力的过程。垃圾回收的时候，python不能进行其他的任务，频繁的垃圾回收，会大大降低python的工作效率。如果内存中的对象不多，就没必要总启动垃圾回收。所以python只会在特定的条件下，<strong>自动启动垃圾回收</strong>。当python运行的时候，会记录其中分配对象和取消分配对象的次数，两者的差值高于某个阈值的时候，垃圾回收才会启动。<br>我们可以通过gc模块的 <code>get_threshold()</code> 来查看该阈值。</p><pre><code class="py">&gt;&gt;&gt; import gc&gt;&gt;&gt; gc.get_threshold()(700, 10, 10)</code></pre><p>返回值中，后面的两个10,是与分代回收相关的阈值，分代回收在后面会讲到。700既是垃圾回收的启动阈值。可以通过gc中的 <code>set_threshold()</code> 来重新设定。<br>也可以手动使用 <code>gc.collect()</code> 启动垃圾回收机制</p></li><li><p>分代回收<br>python同时使用了分代（generation）回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有长期存在被使用的对象，出于信任和效率，对于这样一些对象，我们相信他的用处，所以减少在垃圾回收中扫描他们的频率。<br>python将所有的对象分为0,1,2三代，所有新建的对象都是0代对象，当某一代对象经历过垃圾回收之后，依然存活，那就归入到下一代中，垃圾回收启动时，一定会扫描所有的0代对象。如果0代对象经历过一定次数的垃圾回收，那么就启动对0待和1代的扫描清理，当1代也经历了一定数量的垃圾回收，那就启动对0,1,2，即所有的对象进行扫描。<br>上面 <code>gc.get_threshold()</code> 返回的（700,10,10）中后面的两个数，意义就是，每经过10次对0代的垃圾回收，就会配合启动一次对1代的扫描，没经过10次对1代的扫描，才会启动一次对2代的垃圾回收。<br>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p><pre><code class="py">import gcgc.set_threshold(700, 10, 5)</code></pre></li><li><p>孤立的引用环<br>引用环的存在会给垃圾回收带来很大的困难，这些引用环可能构成无法使用，但是引用计数不为0的一些对象。</p><pre><code class="py">a = []b = [a]a.append(b)del adel b</code></pre><p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。<br><img src="https://i.loli.net/2019/11/15/9YMgpwvVoNEJKcS.png" alt="孤立的引用环.png" title="孤立的引用环"><br>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。<br><img src="https://i.loli.net/2019/11/15/cz6oACOWBdjis2P.png" alt="遍历结果.png" title="遍历结果"><br>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p></li></ol><p><strong><em>总结</em></strong><br>python作为一种动态类型的语言，其对象和引用分离，这与面向过程的编程语言有很大的区别。为了有效的释放内存，python内置了垃圾回收的支持。python采用了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p><h2 id="什么是lambda函数？它有什么好处？"><a href="#什么是lambda函数？它有什么好处？" class="headerlink" title="什么是lambda函数？它有什么好处？"></a><a href="#什么是lambda函数？它有什么好处？">什么是lambda函数？它有什么好处？</a></h2><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指<strong>匿名函数</strong>。<br>匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算。这是什么意思呢？类比 <code>a = [1, 2, 3]</code> 和 <code>f = lambda x : x + 1</code> ，等号左边的名字只是右边之实体的标识符。<br>lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。</p><h2 id="python自省"><a href="#python自省" class="headerlink" title="python自省"></a><a name="#python自省">python自省</a></h2><p>python自省 — 在运行时能够获得对象的类型</p><p><strong>type()</strong>，判断对象类型</p><pre><code class="py">In [27]: type(123)Out[27]: intIn [28]: type(&#39;123&#39;)Out[28]: strIn [29]: type(None)Out[29]: NoneType</code></pre><p><strong>dir()</strong>， 带参数时获得该对象的所有属性和方法；不带参数时，返回当前范围内的变量、方法和定义的类型列表</p><pre><code class="py">&gt;&gt;&gt; dir()[&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]</code></pre><p>以及</p><pre><code class="py">dir(&#39;ABC&#39;)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]</code></pre><p>len()函数返回字符长度</p><pre><code class="py">&gt;&gt;&gt; len(&#39;ABC&#39;)3</code></pre><p>在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法</p><pre><code class="py">&gt;&gt;&gt; &#39;ABC&#39;.__len__()3</code></pre><p>–&gt;</p><pre><code class="py">In [34]: class Mydog(object):    ...:     def __len__(self):    ...:         return 100    ...:In [35]: mydog = Mydog()In [36]: len(mydog)Out[36]: 100</code></pre><p><strong>isinstance()</strong>，判断对象是否是已知类型</p><pre><code class="py">In [37]: a = [1, 2, 3]In [38]: isinstance(a, list)Out[38]: True</code></pre><p><strong>getattr()</strong>、<strong>hasattr()</strong>、<strong>setattr()</strong>获取对象的状态</p><pre><code class="py">In [1]: class Myobject(object):   ...:     def __init__(self):   ...:         self.x = 9   ...:     def power(self):   ...:         return self.x * self.x   ...:In [2]: obj = Myobject()In [3]: obj.power()Out[3]: 81In [4]: hasattr(obj, &#39;x&#39;) # 有属性x么？Out[4]: TrueIn [5]: hasattr(obj, &#39;y&#39;) # 有属性y么？Out[5]: FalseIn [6]: setattr(obj, &#39;y&#39;) # 设置属性必须有三个参数，少了值---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-6-3b0a0f22117d&gt; in &lt;module&gt;()----&gt; 1 setattr(obj, &#39;y&#39;)TypeError: setattr expected 3 arguments, got 2In [7]: setattr(obj, &#39;y&#39;, 100) # 设置属性y的值为100In [8]: hasattr(obj, &#39;y&#39;) # 有属性y么？Out[8]: TrueIn [9]: getattr(obj, &#39;y&#39;) # 获取属性y！Out[9]: 100In [10]: obj.y # 获取属性yOut[10]: 100In [11]: obj.x # 获取属性xOut[11]: 9</code></pre><p>获取不存在的属性，会抛出AttributeError</p><pre><code class="py">In [12]: getattr(obj, &#39;z&#39;)---------------------------------------------------------------------------AttributeError                            Traceback (most recent call last)&lt;ipython-input-12-95c3c0ec4e01&gt; in &lt;module&gt;()----&gt; 1 getattr(obj, &#39;z&#39;)AttributeError: &#39;Myobject&#39; object has no attribute &#39;z&#39;</code></pre><p>可以传入一个默认参数，不存在就抛出默认参数</p><pre><code class="py">In [13]: getattr(obj, &#39;z&#39;, 404)Out[13]: 404</code></pre><h2 id="谈一谈python的装饰器"><a href="#谈一谈python的装饰器" class="headerlink" title="谈一谈python的装饰器"></a><a name="#谈一谈python的装饰器">谈一谈python的装饰器</a></h2><p><a href="https://luyuonism.github.io/2018/06/05/decorator/">python的装饰器</a></p><h2 id="python元类"><a href="#python元类" class="headerlink" title="python元类"></a><a name="#python元类">python元类</a></h2><p><a href="https://www.cnblogs.com/vipchenwei/p/7239953.html" target="_blank" rel="noopener">python元类</a></p><h2 id="列举Http请求中常见的请求方式"><a href="#列举Http请求中常见的请求方式" class="headerlink" title="列举Http请求中常见的请求方式"></a><a name="#列举Http请求中常见的请求方式">列举Http请求中常见的请求方式</a></h2><p><strong>GET</strong><br>向特定的路径资源发出请求</p><p><strong>POST</strong><br>向指定路径资源提交数据进行处理请求（一般用于提交表单或者上传文件）</p><p><strong>OPTIONS</strong><br>返回服务器针对特定资源所支持的HTTP请求方法<br>允许客户端查看服务器的性能，也可以利用向web服务器发送’*‘的请求来测试服务器的功能性</p><p><strong>HEAD</strong><br>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回<br>这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p><p><strong>PUT</strong><br>从客户端向服务器传送的数据取代指定的文档的内容</p><p><strong>DELETE</strong><br>请求服务器删除指定的页面</p><p><strong>TRACE</strong><br>回显服务器收到的请求，主要用于测试或诊断</p><p><strong>CONNECT</strong><br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务</p><h2 id="谈谈你对HTTP协议的认识"><a href="#谈谈你对HTTP协议的认识" class="headerlink" title="谈谈你对HTTP协议的认识"></a><a name="#谈谈你对HTTP协议的认识">谈谈你对HTTP协议的认识</a></h2><p>HTTP是一个属于应用层的面向对象的协议<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><ul><li><strong>基于TCP/IP</strong><br><a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915?fromtitle=tcp%2Fip&fromid=214077&fr=aladdin" target="_blank" rel="noopener">TCP/IP</a>是指能够在多个不同网络间实现信息传输的协议簇,http协议是基于TCP/IP协议之上的应用层协议。</li><li><strong>基于请求－响应模式</strong><br>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并返回</li><li><strong>无状态保存</strong><br>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。<br>使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了。</li></ul><h2 id="简述MVC模式和MVT模式"><a href="#简述MVC模式和MVT模式" class="headerlink" title="简述MVC模式和MVT模式"></a><a name="#简述MVC模式和MVT模式">简述MVC模式和MVT模式</a></h2><p>所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层,他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求<br><img src="https://i.loli.net/2019/11/15/3paj7P1gr9A4UcI.png" alt="MVC.png" title="MVC"></p><p>MTV<br>    Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：<br>M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。<br>T 代表模板 (Template)：负责如何把页面展示给用户(html)。<br>V 代表视图（View）： 负责业务逻辑，并在适当时候调用Model和Template。<br>除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：<br><img src="https://i.loli.net/2019/11/15/dvtKYM4f5Ix3S1G.png" alt="MTV.png" title="MTV"><br>一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p><h2 id="简述Django请求生命周期"><a href="#简述Django请求生命周期" class="headerlink" title="简述Django请求生命周期"></a><a name="#简述Django请求生命周期">简述Django请求生命周期</a></h2><p>一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p><ol><li>wsgi,请求封装后交给web框架 （Flask、Django）     </li><li>中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session - </li><li>路由匹配根据浏览器发送的不同url去匹配不同的视图函数    </li><li>视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染 - </li><li>中间件，对响应的数据进行处理。 </li><li>wsgi,将响应的内容发送给浏览器。<br><img src="https://i.loli.net/2019/11/15/xEajlm7CFnN1HJi.png" alt="django生命周期.png" title="django生命周期"></li></ol><h2 id="django中间件生命周期"><a href="#django中间件生命周期" class="headerlink" title="django中间件生命周期"></a><a name="#django中间件生命周期">django中间件生命周期</a></h2><p>请求过来：<br>中间件：拦截一部分请求；比如验证session, 没有登录的 请求一些页面，跳转至登录页；(图片为中间件的请求过程)再到 urls ，分发请求到views 视图 ，通过 CBV(dispatch反射) 和 FBV 的 get 请求 讲 template 页面渲染返回给用户；渲染之前 可以从数据库拿出数据，放到render 的参数里面传递过去， locals() 表示 把所有参数传递还可以 实例化 其他 form 类，并渲染给前端<br><img src="https://i.loli.net/2019/11/15/epZqE4oX2zWrQwl.png" alt="django.png" title="django"></p><h2 id="简述什么是FBV和CBV"><a href="#简述什么是FBV和CBV" class="headerlink" title="简述什么是FBV和CBV"></a><a name="#简述什么是FBV和CBV">简述什么是FBV和CBV</a></h2><p>django中请求处理方式有2种:<br>FBV（function base views）就是在视图里面使用函数处理请求<br>CBV（class base views）就是在视图里面使用类处理请求</p><h2 id="对ORM的理解"><a href="#对ORM的理解" class="headerlink" title="对ORM的理解"></a><a href="#对ORM的理解">对ORM的理解</a></h2><p>ORM是“对象-关系-映射”的简称。<br>MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动</p><h2 id="常用视图响应的方式"><a href="#常用视图响应的方式" class="headerlink" title="常用视图响应的方式"></a><a name="#常用视图响应的方式">常用视图响应的方式</a></h2><p><strong>视图的响应返回使用HttpResponse</strong><br>HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)<br>一般不用这种方式，我习惯使用：<br> response = HttpResponse(‘language python’)<br> response.status_code = 400<br> response[‘languaget’] = ‘Python’<br> return response<br><strong>返回json数据，可以使用JsonResponse来构造响应对象</strong><br>帮助我们将数据转换为json字符串<br>设置响应头Content-Type为 application/json<br>例子：from django.http import JsonResponse<br>           def demo_view(request):<br>               return JsonResponse({‘city’: ‘beijing’, ‘subject’: ‘python’})<br><strong>redirect重定向</strong><br>我们也可以将返回的结果重定向到另一个页面或接口，<br>例子：from django.shortcuts import redirect<br>           def demo_view(request):<br>               return redirect(‘/index.html’)</p><h2 id="django中间件的5个方法"><a href="#django中间件的5个方法" class="headerlink" title="django中间件的5个方法"></a><a name="#django中间件的5个方法">django中间件的5个方法</a></h2><p>1.process_request : 请求进来时,权限认证<br>2.process_view : 路由匹配之后,能够得到视图函数<br>3.process_exception : 异常时执行<br>4.process_template_response : 模板渲染时执行<br>5.process_response : 请求有响应时执行</p><h2 id="django中csrf的实现机制"><a href="#django中csrf的实现机制" class="headerlink" title="django中csrf的实现机制"></a><a name="#django中csrf的实现机制">django中csrf的实现机制</a></h2><p>第一步：django第一次响应来自某个客户端的请求时,后端随机产生一个token值，把这个token保存在SESSION状态中;同时,后端把这个token放到cookie中交给前端页面<br>第二步：下次前端需要发起请求（比如发帖）的时候把这个token值加入到请求数据或者头信息中,一起传给后端；Cookies:{csrftoken:xxxxx}<br>第三步：后端校验前端请求带过来的token和SESSION里的token是否一致</p><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a><a name="#cookie和session的区别">cookie和session的区别</a></h2><ul><li>cookie 数据存放在客户端，session 数据放在服务器端。</li><li>cookie 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用session。</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 cookie 。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>将登陆信息等重要信息存放为 session、其他信息如果需要保留，可以放在cookie中</li></ul><h2 id="django-orm-中所有的方法"><a href="#django-orm-中所有的方法" class="headerlink" title="django orm 中所有的方法"></a><a name="#django orm 中所有的方法">django orm 中所有的方法</a></h2><p>all()<br>filter(**kwargs)<br>get(**kwargs)<br>update()<br>delete()<br>create()<br>exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象<br>order_by(*field): 对查询结果排序<br>reverse(): 对查询结果反向排序<br>count(): 返回数据库中匹配查询(QuerySet)的对象数量。<br>first(): 返回第一条记录<br>last(): 返回最后一条记录<br>exists(): 如果QuerySet包含数据，就返回True，否则返回False<br>values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系 model的实例化对象，而是一个可迭代的字典序列 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列<br>distinct(): 从返回结果中剔除重复纪录<br>F(): 操作数据表中的某列值</p><pre><code class="py">from django.db.models import Ffrom app01.models import BookBook.objects.update(price=F(&quot;price&quot;)+20)  # 对于book表中每本书的价格都在原价</code></pre><p>没有F查询，你首先要获取原价格，再做一个算术运算，然后更新字段。F查询专门对对象中某列值的操作，不可使用__双下划线！<br>Q(): 对对象进行复杂查询，并支持 &amp;（and）, | （or）, ~（not）操作符<br>Q查询可以组合使用 “&amp;”, “|” 操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象，Q对象可以用 “~“ 操作符放在前面表示否定，也可允许否定与不否定形式的组合。Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。</p><p>1.orm的开发速度快,操作简单。使开发更加对象化,执行速度慢。处理多表联查等复杂操作时,ORM的语法会变得复杂<br>2.sql开发速度慢,执行速度快。性能强</p><h2 id="现有字典d-‘a’-24，’g’-52，’l’-12，’k’-33-请按字典中的value值进行排序"><a href="#现有字典d-‘a’-24，’g’-52，’l’-12，’k’-33-请按字典中的value值进行排序" class="headerlink" title="现有字典d={‘a’:24，’g’:52，’l’:12，’k’:33}请按字典中的value值进行排序"></a><a href="#现有字典d={‘a’:24，’g’:52，’l’:12，’k’:33}请按字典中的value值进行排序">现有字典d={‘a’:24，’g’:52，’l’:12，’k’:33}请按字典中的value值进行排序</a></h2><pre><code class="py">sorted(d.items()，key = lambda x:x[1])</code></pre><h2 id="将字符串”k-1-k1-2-k2-3-k3-4”，处理成Python字典：-k-1，k1-2，…-字典里的K作为字符串处理"><a href="#将字符串”k-1-k1-2-k2-3-k3-4”，处理成Python字典：-k-1，k1-2，…-字典里的K作为字符串处理" class="headerlink" title="将字符串”k:1|k1:2|k2:3|k3:4”，处理成Python字典：{k:1，k1:2，… }#字典里的K作为字符串处理"></a>将字符串”k:1|k1:2|k2:3|k3:4”，处理成Python字典：{k:1，k1:2，… }#字典里的K作为字符串处理</h2><pre><code class="py">str1 = &quot;k:1|k1:2|k2:3|k3:4&quot;def str2dict(str1):  dict1 = {}  for iterms in str1.split(&#39;|&#39;):    key，value = iterms.split(&#39;:&#39;)      dict1[key] = value  return dict1</code></pre><h2 id="请按alist中元素的age由大到小排序"><a href="#请按alist中元素的age由大到小排序" class="headerlink" title="请按alist中元素的age由大到小排序"></a>请按alist中元素的age由大到小排序</h2><pre><code class="py">alist[{&#39;name&#39;:&#39;a&#39;，&#39;age&#39;:20}，{&#39;name&#39;:&#39;b&#39;，&#39;age&#39;:30}，{&#39;name&#39;:&#39;c&#39;，&#39;age&#39;:25}]def sort_by_age(list1):  return sorted(alist，key=lambda x:x[&#39;age&#39;]，reverse=True)</code></pre><h2 id="给定两个列表，怎么找出他们相同的元素和不同的元素"><a href="#给定两个列表，怎么找出他们相同的元素和不同的元素" class="headerlink" title="给定两个列表，怎么找出他们相同的元素和不同的元素?"></a>给定两个列表，怎么找出他们相同的元素和不同的元素?</h2><pre><code class="py">list1 = [1，2，3]list2 = [3，4，5]set1 = set(list1)set2 = set(list2)print(set1&amp;set2)print(set1^set2)</code></pre><h2 id="下面这段代码的输出结果是什么？请解释？"><a href="#下面这段代码的输出结果是什么？请解释？" class="headerlink" title="下面这段代码的输出结果是什么？请解释？"></a>下面这段代码的输出结果是什么？请解释？</h2><pre><code class="py">def extendlist(val, list=[]):  list.append(val)  return listlist1 = extendlist(10)list2 = extendlist(123, [])list3 = extendlist(&#39;a&#39;)</code></pre><p>运行结果:</p><pre><code class="py">list1 = [10, &#39;a&#39;]list2 = [123]list3 = [10, &#39;a&#39;]</code></pre><h2 id="如何分析代码的性能"><a href="#如何分析代码的性能" class="headerlink" title="如何分析代码的性能"></a>如何分析代码的性能</h2><pre><code class="py">import randomimport cProfilelIn = [random.random() for i in range(100000)]cProfile.run(&#39;f1(lIn)&#39;)cProfile.run(&#39;f2(lIn)&#39;)cProfile.run(&#39;f3(lIn)&#39;)</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>&amp; 交<br>| 并</p><ul><li>差<br>^ 异或(在a或b中，但不会同时出现在二者中)</li></ul><h2 id="print-C"><a href="#print-C" class="headerlink" title="print(C)"></a>print(C)</h2><pre><code class="py">a = 10b = 20c = [a]a = 15print(c)   # [10]</code></pre><h2 id="python-一行代码实现将-1-N-的整数列表以-3为单位分组"><a href="#python-一行代码实现将-1-N-的整数列表以-3为单位分组" class="headerlink" title="python 一行代码实现将 1-N 的整数列表以 3为单位分组"></a>python 一行代码实现将 1-N 的整数列表以 3为单位分组</h2><pre><code>[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24], [25, 26, 27], [28, 29, 30], [31, 32, 33], [34, 35, 36], [37, 38, 39], [40, 41, 42], [43, 44, 45], [46, 47, 48], [49, 50, 51], [52, 53, 54], [55, 56, 57], [58, 59, 60], [61, 62, 63], [64, 65, 66], [67, 68, 69], [70, 71, 72], [73, 74, 75], [76, 77, 78], [79, 80, 81], [82, 83, 84], [85, 86, 87], [88, 89, 90], [91, 92, 93], [94, 95, 96], [97, 98, 99], [100]] </code></pre><pre><code class="py">print([[x for x in range(1,101)][i:i+3] for i in range(0,100,3)])</code></pre><h2 id="django开发中数据库做过什么优化"><a href="#django开发中数据库做过什么优化" class="headerlink" title="django开发中数据库做过什么优化?"></a>django开发中数据库做过什么优化?</h2><p>1.设计表时，尽量少使用外键，因为外键约束会影响插入和删除性能；<br>2.使用缓存，减少对数据库的访问；<br>3.在orm框架下设置表时，能用varchar确定字段长度时，就别用text；<br>4.可以给搜索频率高的字段属性，在定义时创建索引；<br>5.Django orm框架下的Querysets本来就有缓存的；<br>6.如果一个页面需要多次连接数据库，最好一次性取出所有需要的数据，减少对数据库的查询次数；7.若页面只需要数据库里某一个两个字段时，可以用QuerySet.values()；<br>8.在模板标签里使用with标签可以缓存Qset的查询结果。</p><h2 id="验证码过期时间怎么设置？"><a href="#验证码过期时间怎么设置？" class="headerlink" title="验证码过期时间怎么设置？"></a>验证码过期时间怎么设置？</h2><p>将验证码保存到数据库或session，设置过期时间为1分钟，然后页面设置一个倒计时(一般是前端<br>js实现这个计时)的展示，一分钟过后再次点击获取新的信息。</p><h2 id="django如何提升性能（高并发）？"><a href="#django如何提升性能（高并发）？" class="headerlink" title="django如何提升性能（高并发）？"></a>django如何提升性能（高并发）？</h2><p>对一个后端开发程序员来说，提升性能指标主要有两个一个是并发数，另一个是响应时间网站性能的优化一般包括web前端性能优化，应用服务器性能优化，存储服务器优化。<br>对前端的优化主要有：<br>1.减少http请求，减少数据库的访问量，比如使用雪碧图。<br>2.使用浏览器缓存，将一些常用的css，js，logo图标，这些静态资源缓存到本地浏览器，通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以自定义。<br>3对html，css，javascript文件进行压缩，减少网络的通信量。对我个人而言，我做的优化主要是以下三个方面：<br>1.合理的使用缓存技术，对一些常用到的动态数据，比如首页做一个缓存，或者某些常用的数据做个缓存，设置一定得过期时间，这样减少了对数据库的压力，提升网站性能。<br>2.使用celery消息队列，将耗时的操作扔到队列里，让worker去监听队列里的任务，实现异步操作，比如发邮件，发短信。<br>3.就是代码上的一些优化，补充：nginx部署项目也是项目优化，可以配置合适的配置参数，提升效率，增加并发量。<br>4.如果太多考虑安全因素，服务器磁盘用固态硬盘读写，远远大于机械硬盘，这个技术现在没有普及，主要是固态硬盘技术上还不是完全成熟，相信以后会大量普及。<br>5.另外还可以搭建服务器集群，将并发访问请求，分散到多台服务器上处理。<br>6.最后就是运维工作人员的一些性能优化技术了。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>服务器向用户返回的状态码和提示信息，常用的有：<br>200 OK：服务器成功返回用户请求的数据<br>201 CREATED：用户新建或修改数据成功。<br>202 Accepted：表示请求已进入后台排队。<br>400 INVALID REQUEST：用户发出的请求有错误。<br>401 Unauthorized：用户没有权限。<br>403 Forbidden：访问被禁止。<br>404 NOT FOUND：请求针对的是不存在的记录。<br>406 Not Acceptable：用户请求的的格式不正确。<br>500 INTERNAL SERVER ERROR：服务器发生错误。</p><h2 id="什么csrf攻击原理？如何解决？"><a href="#什么csrf攻击原理？如何解决？" class="headerlink" title="什么csrf攻击原理？如何解决？"></a>什么csrf攻击原理？如何解决？</h2><img src="/image/csrf.png">简单来说就是:你访问了信任网站A，然后A会用保存你的个人信息并返回给你的浏览器一个cookie，然后呢，在cookie的过期时间之内，你去访问了恶意网站B，它给你返回一些恶意请求代码，要求你去访问网站A，而你的浏览器在收到这个恶意请求之后，在你不知情的情况下，会带上保存在本地浏览器的cookie信息去访问网站A，然后网站A误以为是用户本身的操作，导致来自恶意网站C的攻击代码会被执：发邮件，发消息，修改你的密码，购物，转账，偷窥你的个人信息，导致私人信息泄漏和账户财产安全收到威胁<h2 id="有过部署经验？用的什么技术？可以满足多少压力？"><a href="#有过部署经验？用的什么技术？可以满足多少压力？" class="headerlink" title="有过部署经验？用的什么技术？可以满足多少压力？"></a>有过部署经验？用的什么技术？可以满足多少压力？</h2><p>1.有部署经验，在阿里云服务器上部署的<br>2.技术有：nginx + uwsgi的方式来部署Django项目<br>3.无标准答案（例：压力测试一两千）</p><h2 id="对cookie与session的了解？他们能单独用吗？"><a href="#对cookie与session的了解？他们能单独用吗？" class="headerlink" title="对cookie与session的了解？他们能单独用吗？"></a>对cookie与session的了解？他们能单独用吗？</h2><p>Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了SessionID，也就得不到Session。</p><h2 id="递归-迭代"><a href="#递归-迭代" class="headerlink" title="递归  迭代"></a>递归  迭代</h2><p>自己调自己</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python练习题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="interview" scheme="https://luyuonism.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>python面试</title>
    <link href="https://luyuonism.github.io/2018/02/26/interview-questions/"/>
    <id>https://luyuonism.github.io/2018/02/26/interview-questions/</id>
    <published>2018-02-26T13:13:33.000Z</published>
    <updated>2019-11-20T03:42:35.991Z</updated>
    
    <content type="html"><![CDATA[<p>面试题总结</p><a id="more"></a><p>皓鲸科技</p><p>Celery分布式任务队列？<br>情景：用户发起request，并等待response返回。在本些views中，可能需要执行一段耗时的程序，那么用户就会等待很长时间，造成不好的用户体验，比如发送邮件、手机验证码等。<br>使用celery后，情况就不一样了。解决：将耗时的程序放到celery中执行。<br>将多个耗时的任务添加到队列queue中，也就是用redis实现broker中间人，然后用多个worker去监听队列里的任务去执行。</p><ul><li>任务task：就是一个Python函数。</li><li>队列queue：将需要执行的任务加入到队列中。</li><li>工人worker：在一个新进程中，负责执行队列中的任务。</li><li>代理人broker：负责调度，在布置环境中使用redis。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题总结&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://luyuonism.github.io/tags/python/"/>
    
      <category term="interview" scheme="https://luyuonism.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luyuonism.github.io/2017/11/13/hello-world/"/>
    <id>https://luyuonism.github.io/2017/11/13/hello-world/</id>
    <published>2017-11-13T12:46:25.000Z</published>
    <updated>2019-11-11T01:28:53.001Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
