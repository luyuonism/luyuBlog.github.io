<!DOCTYPE html>
<html>

<head>
  
  <title>Django - Lu Ruijie&#39;s Personal Homepage</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/timg.ico" type="image/png" />
  <meta name="description" content="Django–Django是一个由Python编写的开放源代码的Web应用框架。">
<meta name="keywords" content="python,django">
<meta property="og:type" content="article">
<meta property="og:title" content="Django">
<meta property="og:url" content="https:&#x2F;&#x2F;luyuonism.github.io&#x2F;2018&#x2F;06&#x2F;05&#x2F;django&#x2F;index.html">
<meta property="og:site_name" content="Lu Ruijie&#39;s Personal Homepage">
<meta property="og:description" content="Django–Django是一个由Python编写的开放源代码的Web应用框架。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;07&#x2F;1cIVjQgrBLUwTE8.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;07&#x2F;nHmhiDqzW2OyGo9.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;07&#x2F;Ofp6F2CSZLqTg8h.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;07&#x2F;xVj6tmMR4qAyG1C.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;07&#x2F;qwRQChyBemLnOix.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;09&#x2F;wtbLJoiRTNW8Fau.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;09&#x2F;8UgS7sJWwDftc1r.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;09&#x2F;XRjFVdeGoNfpbW4.png">
<meta property="og:updated_time" content="2019-11-11T09:00:11.177Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;07&#x2F;1cIVjQgrBLUwTE8.png">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1574562195849">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2019/01/13/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <a href="javascript:;" target="_blank" rel="noopener" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>
        <a href="/" title="ruijielu" class="mdui-btn mdui-btn-icon"><img src="/avatar.png"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="ruijielu">
            <img src="/avatar.png" alt="ruijielu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>10</div>
        <div><span>标签</span>3</div>
        <div><span>分类</span>0</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于主页">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于主页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/8736309" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/luyuonism/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="/weixin.jpg" target="_blank" mdui-tooltip="{content: '微信 luyuonism'}" style="color: rgb(102, 255, 204);background-color: rgba(102, 255, 204, .15);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="/qq.jpg" target="_blank" mdui-tooltip="{content: 'QQ 1501405087'}" style="color: rgb(102, 204, 255);background-color: rgba(102, 204, 255, .15);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://weibo.com/6416453194/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" mdui-tooltip="{content: '微博'}" style="color: rgb(255, 69, 24);background-color: rgba(255, 69, 24, .15);">
            <i class="nexmoefont icon-weibo"></i>
        </a><a class="mdui-ripple" href="https://www.zhihu.com/people/lu-yu-36-39-54/activities" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: rgb(11, 141, 255);background-color: rgba(11, 141, 255, .15);">
            <i class="nexmoefont icon-zhihu"></i>
        </a>
    </div>
</div>
  
  

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/python/" style="font-size: 20px;">python</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2019/11/05/django-STATIC_ROOT/">django配置  STATIC_ROOT</a>
          </li>
        
          <li>
            <a href="/2019/06/05/python-f-string/">python f-string式格式化</a>
          </li>
        
          <li>
            <a href="/2018/07/05/python-basis/">python基础</a>
          </li>
        
          <li>
            <a href="/2018/06/05/decorator/">decorator</a>
          </li>
        
          <li>
            <a href="/2018/06/05/sql/">MySql</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 ruijielu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com" target="_blank">Git</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
        <img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4211954108,196742607&fm=26&gp=0.jpg">
        
        <h1>Django</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2018年06月05日</a>
    <a><i class="nexmoefont icon-areachart"></i>10,351 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 43 分钟</a>
    
    
      <a class="nexmoefont icon-tag-fill -link" href="/tags/django/" rel="tag">django</a> <a class="nexmoefont icon-tag-fill -link" href="/tags/python/" rel="tag">python</a>
    
  </div>
  <article>
    <p>Django–Django是一个由Python编写的开放源代码的Web应用框架。</p>
<a id="more"></a>

<h1 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h1><p><em>文章 分类 评论 搜索 统计</em></p>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p>从用户的角度，通过访问不同的url，来得到不同的网页。<br>从开发者的角度，通过解析不同的url，来输出（render/display）该url指向的网页内容。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>用户请求(request) –&gt; 通过访问不同的url<br>响应(response)的内容，也就是用户看到的内容 –&gt; 用户最终看到的内容</p>
<p>http  用户发起请求 –&gt; 响应：浏览器获得响应内容，解析html，css，javascript</p>
<p>1.获得url请求 request<br>2.解析request （拿到url，解析url，让处理该url的方法去处理request）<br>3.拼接response ，返回给用户<br>4.浏览器获得响应内容，解析html，css，javascript</p>
<h2 id="django框架"><a href="#django框架" class="headerlink" title="django框架"></a>django框架</h2><p>创建项目:</p>
<pre><code class="django">django-admin startproject 项目名</code></pre>
<p>创建一个testdj目录,目录的结构为：</p>
<pre><code>testdj/
    manage.py    一个让你用各种方式管理 Django 项目的命令行工具。
    testdj/        一个纯 Python 包
        __init__.py     一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。
        settings.py     Django 项目的配置文件。
        urls.py     Django 项目的 URL 声明，就像你网站的“目录”。
        wsgi.py     作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。</code></pre><p>启动服务</p>
<pre><code class="python">python manage.py runserver</code></pre>
<p>将会输出如下结果：</p>
<pre><code class="python">python manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).
May 10, 2018 - 17:21:16
Django version 2.0.5, using settings &#39;testdj.settings&#39;
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.</code></pre>
<p>更换端口</p>
<pre><code class="python">python manage.py runserver 8080</code></pre>
<p>如果想要修改服务器监听的IP，在端口之前输入新的</p>
<pre><code class="python">python manage.py runserver 0.0.0.0:8000</code></pre>
<p>简述django的MTV：</p>
<pre><code>MVC
          用户-------------------------------\
          |                     响应给用户显示 \
          |                                   |
发起请求  /    /----控制器将数据显示在视图上----View
        /    / 
    Controller ------\ 
    /                 \
   / 按照请求访问数据库  \
  /                     |  从数据库返回数据给控制器
Model -------------------

MTV
  Model &lt;-----&lt;去models里取数据&lt;-----Views&lt;----&lt;根据url匹配相应的视图函数&lt;----url控制器&lt;----在页面输入访问的URL&lt;--\
    | \                              / \                                                                      |
    |   &gt;------&gt;将数据返回给视图&gt;-----&gt;   &gt;----&gt;把要展示的数据返回给模板&gt;----&gt; Templates----&gt;模板就是html文件---&gt; 用户
    |
去数据库里取数据
    |
   数据库</code></pre><h2 id="使用django开发个人博客"><a href="#使用django开发个人博客" class="headerlink" title="使用django开发个人博客"></a>使用django开发个人博客</h2><p>首先，博客的页面属于前端，不想自己写前端代码，怎么办???</p>
<h3 id="抓取网站源码工具"><a href="#抓取网站源码工具" class="headerlink" title="抓取网站源码工具"></a>抓取网站源码工具</h3><p><a href="'https://smalltool.github.io'">仿站小工具</a>是通过网址下载静态网页的工具。从输入的网址下载html代码，提取出JS、Css、Image、Picture、Flash等静态文件网址，再从下载完好的Css代码中提取出Image静态文件网址，通过网址下载静态文件，根据软件设置好的保存规则，自动修正html和css代码链接路径，最终这些静态文件被按分类保存到电脑文件夹。</p>
<ul>
<li>添加网址<br>输入的网址是要抓取页面网址，相对路径是主域名后边的路径，文件名即抓取后的文件保存的名字<br><img src="https://i.loli.net/2019/11/07/1cIVjQgrBLUwTE8.png" alt="添加地址.png" title="添加网址"></li>
<li>开始下载<br><img src="https://i.loli.net/2019/11/07/nHmhiDqzW2OyGo9.png" alt="开始下载" title="开始下载"></li>
<li>获取的结果</li>
</ul>
<p><img src="https://i.loli.net/2019/11/07/Ofp6F2CSZLqTg8h.png" alt="抓取结果" title="抓取结果"></p>
<ul>
<li>整理结果<br>把获取的除了static文件，其它文件中的 .html文件都放入 templates中，把static文件和templates放于同级目录<br><img src="https://i.loli.net/2019/11/07/xVj6tmMR4qAyG1C.png" alt="整理结果" title="整理结果"><br>此时，django所需的前端页面就有了，static、templates</li>
</ul>
<p><em>此时index.html 文件的静态文件配置的路径如果正确，路径都指向 static 对应的文件，则可以在浏览器中运行</em></p>
<h3 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h3><h4 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h4><h5 id="Virtualenv"><a href="#Virtualenv" class="headerlink" title="Virtualenv"></a>Virtualenv</h5><ol>
<li>安装 Virtualenv<br>Virtualenv 是一个创建隔绝的 Python 环境的工具。Virtualenv 创建一个包含所有必要的可执行文件的文件夹，用来使用Python工程所需的包。<br>可以理解为我们电脑上要开发很多项目，每一个项目的开发环境是不同的，Virtualenv 可以创建出一个个不同的开发环境。<pre><code>pip install virtualenv</code></pre></li>
<li>创建虚拟环境<pre><code>cd 路径
virtualenv 环境名</code></pre></li>
<li>激活·虚拟环境<pre><code>cd 环境名/Scripts
activate.bat </code></pre>激活成功后，命令行前面会有（环境名）的字样<pre><code>(环境名) 路径\环境名\Scripts&gt;</code></pre></li>
<li>退出虚拟环境<pre><code>deactivate.bat</code></pre><h5 id="VirtualenvWrapper"><a href="#VirtualenvWrapper" class="headerlink" title="VirtualenvWrapper"></a>VirtualenvWrapper</h5></li>
<li>安装 VirtualenvWrapper<br>使用 Virtualenv，需要进入相对应的路径，相对麻烦，可以使用 VirtualWrapper 对虚拟环境集中管理。<pre><code>pip install virtualenvwrapper-win</code></pre></li>
<li>设置环境变量<br>环境变量是通过 VirtualenvWrapper 建立虚拟环境时，该虚拟环境的所在目录<br>右键计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;系统变量–&gt;新建，变量值为你虚拟环境的目录。<pre><code>变量名：WORKON_HOME
变量值：路径\virtualenv</code></pre></li>
<li>创建虚拟环境<pre><code>mkvirtualenv 环境名</code></pre>创建的虚拟环境存放位置：路径\virtualenv即可</li>
<li>查看创建的所有虚拟环境<pre><code>workon</code></pre></li>
<li>启动虚拟环境<pre><code>workon 环境名</code></pre></li>
<li>退出虚拟环境<pre><code>deactivate</code></pre>如果这个虚拟环境不想要了，直接进入 路径\virtualenv文件夹删除 环境名的文件夹即可</li>
</ol>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>启动虚拟环境</p>
<pre><code>workon 环境名</code></pre><p>创建方法见上文</p>
<p>这里直接用python IDE Pycharm 创建<br>file-&gt;new profile 新建一个项目</p>
<ul>
<li>选择左侧栏中的 django</li>
<li>位置栏输入自己的项目名称，这里直接叫 blog</li>
<li>解释器这里选择之前创建的虚拟环境 虚拟环境路径/环境名/Scripts/python.exe<br><img src="https://i.loli.net/2019/11/07/qwRQChyBemLnOix.png" alt="创建项目" title="创建项目"></li>
</ul>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行方法见上文</p>
<p>这里用IDE直接run即可</p>
<pre><code>Django version 2.2.4, using settings &#39;blog.settings&#39;
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.</code></pre><p>在setting.py文件中，将语言改为中文，时区改为上海<br>blog -&gt; blog -&gt; settings.py</p>
<pre><code>LANGUAGE_CODE = &#39;zh-hans&#39;

TIME_ZONE = &#39;Asia/Shanghai&#39;</code></pre><h3 id="创建第一个APP"><a href="#创建第一个APP" class="headerlink" title="创建第一个APP"></a>创建第一个APP</h3><p>在Terminal中输入:</p>
<pre><code class="python">python manage.py startapp luyu</code></pre>
<p>于是就创建出一个名为luyu的app<br>此时项目完整的目录结构如下</p>
<pre><code>.
|-- blog
|   |-- luyu                # 博客应用
|   |   |-- migrations      # 数据库映射文件
|   |   |-- __init__.py     # 声明模块，内容默认为空
|   |   |-- admin.py        # 该应用的后台管理系统
|   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成
|   |   |-- models.py       # 数据模块，使用ORM框架
|   |   |-- tests.py        # 自动化测试的模块        
|   |   |-- views.py        # 执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写        
|   |-- blog                # 项目的容器
|   |   |-- __init__.py     # 声明模块，内容默认为空
|   |   |-- settings.py     # 该 Django 项目的设置/配置。
|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。
|   |   |-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目
|   |-- templates           # 模板文件
`-- manage.py</code></pre><p>新创建的app需要注册:<br>blog -&gt; blog -&gt; settings.py</p>
<pre><code class="python">INSTALLED_APPS = [
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;luyu&#39;,    # 添加用户应用
]</code></pre>
<h3 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h3><p>这里使用的数据库是mysql</p>
<h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><p>Django 中默认的数据库是 sqlite3<br>blog -&gt; blog -&gt; settings.py</p>
<pre><code class="python"># 默认
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
}</code></pre>
<p>改为:</p>
<pre><code class="python">DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;HOST&#39;: &#39;localhost&#39;,
        &#39;PORT&#39;: &#39;3306&#39;,
        &#39;USER&#39;: &#39;root&#39;,
        &#39;PASSWORD&#39;: &#39;123456&#39;,
        &#39;NAME&#39;: &#39;luyu&#39;,
        # 避免映射数据库时出现警告
        &#39;OPTIONS&#39;: {
            &#39;init_command&#39;: &quot;SET sql_mode=&#39;STRICT_TRANS_TABLES&#39;&quot;,
            &#39;charset&#39;: &#39;utf8mb4&#39;,
        },
    }
}</code></pre>
<p>此时 Django 与 Mysql 关联上了，但是 Python 并没有与 Mysql 连接上,需要安装pymysql</p>
<pre><code>pip install pymysql</code></pre><p>此时，<br>在Terminal中输入:</p>
<pre><code class="python">python manage.py makemigrations</code></pre>
<p>和</p>
<pre><code class="python">python manage.py migrate</code></pre>
<p>当执行了 makemigrations 后，Django 在 luyu 这个应用的 migrations\ 目录下生成了一个 0001_initial.py 文件，这个文件是 Django 用来记录我们对模型做了哪些修改的文件。<br>不过此时只是告诉了 Django 做了哪些改变，为了让 Django 真正地为我们创建数据库表，接下来执行 migrate 命令。<br>Django 通过检测应用中 migrations\ 目录下的文件，得知我们对数据库做了哪些操作，然后它把这些操作翻译成数据库操作语言，从而把这些操作作用于数据库。<br>经过这两项操作后，我们打开 navicat 等mysql数据库可视化软件中的 blog 数据库，发现多了如下表单，这些表单为Django 自身还内置的很多应用，这些应用本身也是需要存储数据的。</p>
<pre><code>auth_group, 
auth_group_permissions, 
auth_permission, 
auth_user, 
auth_user_groups, 
auth_user_user_permissions, 
django_admin_log, 
django_content_type, 
django_migrations, 
django_session</code></pre><p>此时如果你发现项目文件中并没有 templates 文件，新建 templates 文件，右击鼠标，选择 Mark Directory as -&gt; Template Folder, 点击确定。</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><p>数据库设计是一个难点，先从功能上分析，看看这个博客网站需要建立哪些表，每个表中都需要什么字段。<br>首先，最主要的是我们的博文表，名字可以直接叫做 article，这个表中，肯定要包括以下几点：</p>
<p>博文的标题、博文的内容、博文的发表时间、博文的修改时间、博文的分类、博文的阅读量、博文喜欢量、博文作者 等</p>
<p>针对博文的分类，我们可以参考csdn博客系统，一篇博文只能有一个分类，但是可以有多个标签，比如我现在写的这篇博文，可以分类到 django 下，但是它可以有多个标签：django、博客、数据库、开发……</p>
<p>考虑到每一篇博文都只能有一个分类，而一个分类下是可以包含很多博文的，因此分类与博文是一对多的关系，此时应当使用外键来进行关联。而一篇博文可以有多个标签， 每个标签也可以包含多个博文，因此，标签与博文是多对多的关系。关于一对多与多对多的知识话题，这里就不再展开了，不了解的查看 Django文档 与相关资料。<br>针对网站优化，那么一个网站最基本的<a href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=seo&fromid=102990&fr=aladdin" target="_blank" rel="noopener">SEO</a>就是设置TDK</p>
<pre><code>T： 网站页面 title

D： 网站页面描述

K： 网站页面Keywords，也即网站涵盖的主题</code></pre><p>则需要一个页面关键字表 Keyword，一个页面可能包含多个主题，一个主题可能在多个页面出现，所以应该是多对多的关系 暂且称作 Keyword</p>
<p><a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板博客</a>导航栏菜单存在下拉菜单，下拉菜单即是博文分类，这里的导航栏菜单也需要一个表，因为这个表就是为了给博文分类归类的 暂且称作 Bigcategory</p>
<p>观察<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板博客</a>导航栏下边还一个公告，公告也需要一个表，它和任何表都没关系 暂且称作 Activate</p>
<p>公告下边是幻灯片，思考了一下，这个幻灯片应该和别的表也没啥关系，暂且称作 Carousel</p>
<p>再看看，右侧还有一个友情链接功能，需要一个表，友链和其它表也没啥关系 暂且称作 FriendLink</p>
<p>因此，通过上述分析，我们可以确定出这些数据表，博客（Article）、分类（Category）与标签（Tag）、导航(Bigcategory)、文章关键词 (Keyword)、公告(Activate)、幻灯片(Carousel)、友链(FriendLink)</p>
<h4 id="编写-luyu-应用模型"><a href="#编写-luyu-应用模型" class="headerlink" title="编写 luyu 应用模型"></a>编写 luyu 应用模型</h4><p>blog -&gt; luyu -&gt; models.py</p>
<pre><code class="python">from django.db import models
from django.conf import settings
from django.shortcuts import reverse

import markdown
import re</code></pre>
<p>由于 Article 表包含外键与多对多关系，因此首先应当建立另外两个表：</p>
<p>分类（Category）表的创建：</p>
<p>由于 Category 分类表包含外键，因此首先需要创建导航菜单表 Bigcategory</p>
<pre><code class="python"># 网站导航菜单栏分类表
class BigCategory(models.Model):
    # 导航名称
    name = models.CharField(&#39;文章大分类&#39;, max_length=20)
    # 用作文章的访问路径，每篇文章有独一无二的标识，下同
    slug = models.SlugField(unique=True)
    # 分类页描述
    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,
                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)
    # 分类页Keywords
    keywords = models.TextField(&#39;关键字&#39;, max_length=240, default=settings.SITE_KEYWORDS,
                              help_text=&#39;用来作为SEO中keywords,长度参考SEO标准&#39;)

    class Meta:
        verbose_name = &#39;大分类&#39;
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


# 导航栏，分类下的下拉擦菜单分类
class Category(models.Model):

    # 分类名字
    name = models.CharField(&#39;文章分类&#39;, max_length=20)
    # slug 用作分类路径，对一无二
    slug = models.SlugField(unique=True)
    # 分类栏目页描述
    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,
                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)

    # 对应导航菜单外键
    bigcategory = models.ForeignKey(BigCategory, verbose_name=&#39;大分类&#39;, on_delete=models.CASCADE)

    class Meta:
        verbose_name = &#39;分类&#39;
        verbose_name_plural = verbose_name
        ordering = [&#39;name&#39;]

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse(&#39;blog:category&#39;, kwargs={&#39;slug&#39;: self.slug, &#39;bigslug&#39;: self.bigcategory.slug})

    def get_article_list(self):
        return Article.objects.filter(category=self)</code></pre>
<p>标签（Tag）表的创建：</p>
<pre><code class="python"># 文章标签
class Tag(models.Model):
    name = models.CharField(&#39;文章标签&#39;, max_length=20)
    slug = models.SlugField(unique=True)
    description = models.TextField(&#39;描述&#39;, max_length=240, default=settings.SITE_DESCRIPTION,
                                 help_text=&#39;用来作为SEO中description,长度参考SEO标准&#39;)

    class Meta:
        verbose_name = &#39;标签&#39;
        verbose_name_plural = verbose_name
        ordering = [&#39;id&#39;]

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse(&#39;blog:tag&#39;, kwargs={&#39;tag&#39;: self.name})

    def get_article_list(self):
        &quot;&quot;&quot;返回当前标签下所有发表的文章列表&quot;&quot;&quot;
        return Article.objects.filter(tags=self)</code></pre>
<p>标签（Keyword）表的创建：</p>
<pre><code class="python"># 文章关键词，用来作为 SEO 中 keywords
class Keyword(models.Model):
    name = models.CharField(&#39;文章关键词&#39;, max_length=20)

    class Meta:
        verbose_name = &#39;关键词&#39;
        verbose_name_plural = verbose_name
        ordering = [&#39;name&#39;]

    def __str__(self):
        return self.name</code></pre>
<p>博客（Article）表的创建：</p>
<pre><code class="python"># 文章
class Article(models.Model):
    # 文章默认缩略图
    IMG_LINK = &#39;/static/images/summary.jpg&#39;
    # 文章作者
    author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=&#39;作者&#39;, on_delete=models.CASCADE)
    title = models.CharField(max_length=150, verbose_name=&#39;文章标题&#39;)
    summary = models.TextField(&#39;文章摘要&#39;, max_length=230, default=&#39;文章摘要等同于网页description内容，请务必填写...&#39;)
    # 文章内容
    body = models.TextField(verbose_name=&#39;文章内容&#39;)
    img_link = models.CharField(&#39;图片地址&#39;, default=IMG_LINK, max_length=255)
    create_date = models.DateTimeField(verbose_name=&#39;创建时间&#39;, auto_now_add=True)
    update_date = models.DateTimeField(verbose_name=&#39;修改时间&#39;, auto_now=True)
    views = models.IntegerField(&#39;阅览量&#39;, default=0)
    loves = models.IntegerField(&#39;喜爱量&#39;, default=0)
    # 文章唯一标识符
    slug = models.SlugField(unique=True)
    category = models.ForeignKey(Category, verbose_name=&#39;文章分类&#39;, on_delete=models.CASCADE)
    tags = models.ManyToManyField(Tag, verbose_name=&#39;标签&#39;)
    keywords = models.ManyToManyField(Keyword, verbose_name=&#39;文章关键词&#39;,
                                    help_text=&#39;文章关键词，用来作为SEO中keywords，最好使用长尾词，3-4个足够&#39;)

    class Meta:
        verbose_name = &#39;文章&#39;
        verbose_name_plural = verbose_name
        ordering = [&#39;-create_date&#39;]

    def __str__(self):
        return self.title[:20]

    def get_absolute_url(self):
        return reverse(&#39;blog:article&#39;, kwargs={&#39;slug&#39;: self.slug})

    def body_to_markdown(self):
        return markdown.markdown(self.body, extensions=[
            &#39;markdown.extensions.extra&#39;,
            &#39;markdown.extensions.codehilite&#39;,
        ])

    def update_views(self):
        self.views += 1
        self.save(update_fields=[&#39;views&#39;])

    def get_pre(self):
        return Article.objects.filter(id__lt=self.id).order_by(&#39;-id&#39;).first()

    def get_next(self):
        return Article.objects.filter(id__gt=self.id).order_by(&#39;id&#39;).first()</code></pre>
<p>为什么要用slug给文章起别名呢？这个可能暂且就认为只是为了提升逼格吧</p>
<p>公告（Activate）表的创建：</p>
<pre><code class="python"># 公告
class Activate(models.Model):
    text = models.TextField(&#39;公告&#39;, null=True)
    is_active = models.BooleanField(&#39;是否开启&#39;, default=False)
    add_date = models.DateTimeField(&#39;提交日期&#39;, auto_now_add=True)

    class Meta:
        verbose_name = &#39;公告&#39;
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.id</code></pre>
<p>幻灯片（Carousel）表的创建：</p>
<pre><code class="python"># 幻灯片
class Carousel(models.Model):
    number = models.IntegerField(&#39;编号&#39;, help_text=&#39;编号决定图片播放的顺序，图片不要多于5张&#39;)
    title = models.CharField(&#39;标题&#39;, max_length=20, blank=True, null=True, help_text=&#39;标题可以为空&#39;)
    content = models.CharField(&#39;描述&#39;, max_length=80)
    img_url = models.CharField(&#39;图片地址&#39;, max_length=200)
    url = models.CharField(&#39;跳转链接&#39;, max_length=200, default=&#39;#&#39;, help_text=&#39;图片跳转的超链接，默认#表示不跳转&#39;)

    class Meta:
        verbose_name = &#39;图片轮播&#39;
        verbose_name_plural = verbose_name
        # 编号越小越靠前，添加的时间约晚约靠前
        ordering = [&#39;number&#39;, &#39;-id&#39;]

    def __str__(self):
        return self.content[:25]</code></pre>
<p>友链（FriendLink）表的创建：</p>
<pre><code class="python"># 友情链接表
class FriendLink(models.Model):
    name = models.CharField(&#39;网站名称&#39;, max_length=50)
    description = models.CharField(&#39;网站描述&#39;, max_length=100, blank=True)
    link = models.URLField(&#39;友链地址&#39;, help_text=&#39;请填写http或https开头的完整形式地址&#39;)
    logo = models.URLField(&#39;网站LOGO&#39;, help_text=&#39;请填写http或https开头的完整形式地址&#39;, blank=True)
    create_date = models.DateTimeField(&#39;创建时间&#39;, auto_now_add=True)
    is_active = models.BooleanField(&#39;是否有效&#39;, default=True)
    is_show = models.BooleanField(&#39;是否首页展示&#39;, default=False)

    class Meta:
        verbose_name = &#39;友情链接&#39;
        verbose_name_plural = verbose_name
        ordering = [&#39;create_date&#39;]

    def __str__(self):
        return self.name

    def get_home_url(self):
        &quot;&quot;&quot;提取友链的主页&quot;&quot;&quot;
        u = re.findall(r&#39;(http|https://.*?)/.*?&#39;, self.link)
        home_url = u[0] if u else self.link
        return home_url

    def active_to_false(self):
        self.is_active=False
        self.save(update_fields=[&#39;is_active&#39;])

    def show_to_false(self):
        self.is_show = True
        self.save(update_fields=[&#39;is_show&#39;])</code></pre>
<p>这里需要注意一下，luyu -&gt; models.py 中出现的 AUTH_USER_MODEL、SITE_DESCRIPTION、AUTH_USER_MODEL、SITE_KEYWORDS，把它们当作默认字段放在 setting.py 中，便于管理<br>blog -&gt; blog -&gt; settings.py</p>
<pre><code class="python"># 网站描述，用于SEO
SITE_DESCRIPTION = &quot;luyu的个人网站，记录python学习之路&quot;

# 网站关键词，用于SEO
SITE_KEYWORDS = &quot;luyuonism,luyu,网络,IT,技术,博客,Python&quot;</code></pre>
<p>在文件首部 # 引入 settings.py 文件，即可使用这些字段</p>
<pre><code class="python">from django.conf import settings</code></pre>
<p>以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime），max_length 参数限定长度。</p>
<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul>
<li><p>标题应当限定长度，我们设定最大值为100</p>
</li>
<li><p>内容不用限定长度，因此用的是TextField字段</p>
</li>
<li><p>修改时间直接设定成，auto_now=True，在你修改时，会自动变成当前时间。</p>
</li>
<li><p>关于ForeignKey与ManyToManyField，查看<a href="https://docs.djangoproject.com/en/2.1/topics/db/models/" target="_blank" rel="noopener">Django官方文档</a> <a href="http://djangobook.py3k.cn/2.0/chapter05/" target="_blank" rel="noopener">Django中文文档</a></p>
</li>
</ul>
<h4 id="编写-user-用户模型"><a href="#编写-user-用户模型" class="headerlink" title="编写 user 用户模型"></a>编写 user 用户模型</h4><p>blog -&gt; luyu -&gt; models.py 中文章有一个作者外键</p>
<pre><code class="python">    author = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=&#39;作者&#39;, on_delete=models.CASCADE)</code></pre>
<p>这个外键是网站注册用户，这样用户也可以有发文权限，考虑到以后会扩展用户功能，所以这里还是创建一个用户app比较好。<br>创建app不再赘述, 不要忘了创建app后去配置文件里注册用户app<br>blog -&gt; user -&gt; models.py</p>
<pre><code class="python"># 继承 AbstractUser ，django 自带用户类，扩展用户个人网站字段，用户头像字段
class Ouser(AbstractUser):
    # 扩展用户个人网站字段
    link = models.URLField(&#39;个人网址&#39;, blank=True, help_text=&#39;提示：网址必须填写以http开头的完整形式&#39;)
    # 扩展用户头像字段
    avatar = ProcessedImageField(upload_to=&#39;avatar/%Y/%m/%d&#39;,
                                 default=&#39;avatar/default.png&#39;,
                                 verbose_name=&#39;头像&#39;,
                                 processors=[ResizeToFill(80, 80)]
                                 )

    class Meta:
        verbose_name = &#39;用户&#39; # 定义网站管理后台表名
        verbose_name_plural = verbose_name
        ordering = [&#39;-id&#39;]


    def __str__(self):
        return self.username</code></pre>
<h4 id="迁移-user-用户应用模型"><a href="#迁移-user-用户应用模型" class="headerlink" title="迁移 user 用户应用模型"></a>迁移 user 用户应用模型</h4><p>Terminal中执行命令</p>
<pre><code class="python">python  manage.py  makemigrations
python  manage.py  migrate</code></pre>
<p>如遇以下问题，</p>
<pre><code class="python">    File &quot;E:\\ProgramData\\Anaconda3\\lib\\site-packages\\imagekit\\registry.py&quot;, line 3, in &lt;module&gt;
        from .utils import autodiscover, call_strategy_method
ImportError: cannot import name &#39;autodiscover&#39;</code></pre>
<p>解决办法：</p>
<pre><code>E:\ProgramData\Anaconda3\Lib\site-packages\imagekit 中有一个utils文件和utils.py文件，两个文件名发生冲突产生歧义，将utils文件夹手动改为foo</code></pre><pre><code class="python">SystemCheckError: System check identified some issues:

ERRORS:
auth.User.groups: (fields.E304) Reverse accessor for &#39;User.groups&#39; clashes with reverse accessor for &#39;Ouser.groups&#39;.
        HINT: Add or change a related_name argument to the definition for &#39;User.groups&#39; or &#39;Ouser.groups&#39;.
auth.User.user_permissions: (fields.E304) Reverse accessor for &#39;User.user_permissions&#39; clashes with reverse accessor for &#39;Ouser.user_permissions&#39;.
        HINT: Add or change a related_name argument to the definition for &#39;User.user_permissions&#39; or &#39;Ouser.user_permissions&#39;.
user.Ouser.groups: (fields.E304) Reverse accessor for &#39;Ouser.groups&#39; clashes with reverse accessor for &#39;User.groups&#39;.
        HINT: Add or change a related_name argument to the definition for &#39;Ouser.groups&#39; or &#39;User.groups&#39;.
user.Ouser.user_permissions: (fields.E304) Reverse accessor for &#39;Ouser.user_permissions&#39; clashes with reverse accessor for &#39;User.user_permissions&#39;.
        HINT: Add or change a related_name argument to the definition for &#39;Ouser.user_permissions&#39; or &#39;User.user_permissions&#39;.</code></pre>
<p>解决办法:</p>
<pre><code>抽象基类创建完成后, 没有在setting中声明, 或者声明错误
setting.py 文件中添加一句 AUTH_USER_MODEL = &quot;user.Ouser&quot;</code></pre><pre><code class="python">django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency user.0001_initial on database &#39;default&#39;.</code></pre>
<p>解决办法:</p>
<pre><code>删库跑路，把所有表删掉之后，再次执行 python  manage.py  migrate</code></pre><p>以上，即可将新建的这些表添加到我们的数据库 blog 中：</p>
<pre><code>auth_group, 
auth_group_permissions,
auth_permission,
auth_user_groups,
auth_user_user_permissions, 
django_admin_log, 
django_content_type, 
django_migrations, 
django_session,
storm_activate,         # 公告表 
storm_article,          # 新增的博文表
storm_article_keywords, # 这个是博文与关键词的多对多关系表
storm_article_tags,     # 这个是博文与标签的多对多关系表
storm_bigcategory,      # 导航菜单大分类表
storm_carousel,         # 幻灯片
storm_category,         # 新增的分类表
storm_friendlink,       # 友情链接
storm_keyword,          # 关键词表
storm_tag，              # 新增的标签表
user_ouser,             # 新增扩展用户表
user_ouser_groups,      # 自动产生
user_ouser_user_permissions # 自动产生</code></pre><p>最后两个表示用户表继承了，Django自带的用户models产生的用户关系表<br>需要说明的是，这里我们只给出了最开始设计时考虑到的情况，在后续开发过程中，可以随时对其进行变更。当数据表信息变动时<br>再次执行</p>
<pre><code class="python">python  manage.py  makemigrations
python  manage.py  migrate</code></pre>
<h3 id="通过admin管理后台"><a href="#通过admin管理后台" class="headerlink" title="通过admin管理后台"></a>通过admin管理后台</h3><p>Django 中一个最强大的部分是自动管理接口，在模型中读取元数据来提供一个强大的、生产就绪的接口，使内容提供者能立即用它向站点中添加内容，在这篇文档中，我们讨论如何去激活，使用和自定义Django的站点管理接口。</p>
<h4 id="创建管理员账号"><a href="#创建管理员账号" class="headerlink" title="创建管理员账号"></a>创建管理员账号</h4><p>在浏览器中输入<a href="http://127.0.0.1:8000/admin" target="_blank" rel="noopener">http://127.0.0.1:8000/admin</a>,<br>便可进入到后台管理登录页面，如下图所示：<br><img src="https://i.loli.net/2019/11/09/wtbLJoiRTNW8Fau.png" alt="django登陆" title="django登陆"><br>首先，创建一个能登录管理页面的用户,</p>
<pre><code class="python">python manage.py createsuperuser</code></pre>
<p>键入你想要使用的用户名:</p>
<pre><code>Username: admin</code></pre><p>然后提示你输入想要使用的邮件地址：</p>
<pre><code>Email address: admin@example.com</code></pre><p>最后一步是输入密码。你会被要求输入两次密码，密码需要满足起码的强度。</p>
<pre><code>Password:
Password (again):
Superuser created successfully.</code></pre><h4 id="注册模型到后台"><a href="#注册模型到后台" class="headerlink" title="注册模型到后台"></a>注册模型到后台</h4><p>登录后台后，我们看到此时的后台只有用户、组和最近动作，并没有我们之前创建的我的文章、分类、标签这些内容。<br><img src="https://i.loli.net/2019/11/09/8UgS7sJWwDftc1r.png" alt="django后台" title="django后台"><br>在admin.py中进行配置，将其在后台展现出来：<br>blog -&gt; luyu -&gt; admin.py</p>
<pre><code class="python">from django.contrib import admin
from .models import Article, Tag, Category, Carousel, Keyword, FriendLink, BigCategory


@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    # 这个的作用是给出一个筛选机制，一般按照时间比较好
    date_hierarchy = &#39;create_date&#39;

    exclude = (&#39;views&#39;,)

    # 在查看修改的时候显示的属性，第一个字段带有&lt;a&gt;标签，所以最好放标题
    list_display = (&#39;id&#39;, &#39;title&#39;, &#39;author&#39;, &#39;create_date&#39;, &#39;update_date&#39;)

    # 设置需要添加&lt;a&gt;标签的字段
    list_display_links = (&#39;title&#39;,)

    # 激活过滤器，这个很有用
    list_filter = (&#39;create_date&#39;, &#39;category&#39;)

    list_per_page = 50  # 控制每页显示的对象数量，默认是100

    filter_horizontal = (&#39;tags&#39;, &#39;keywords&#39;)  # 给多选增加一个左右添加的框

    # 限制用户权限，只能看到自己编辑的文章
    def get_queryset(self, request):
        qs = super(ArticleAdmin, self).get_queryset(request)
        if request.user.is_superuser:
            return qs
        return qs.filter(author=request.user)


@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)


@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)


@admin.register(BigCategory)
class BigCategoryAdmin(admin.ModelAdmin):
    list_display = (&#39;name&#39;, &#39;id&#39;, &#39;slug&#39;)


# 自定义管理站点的名称和URL标题
admin.site.site_header = &#39;网站管理&#39;
admin.site.site_title = &#39;博客后台管理&#39;


@admin.register(Carousel)
class CarouselAdmin(admin.ModelAdmin):
    list_display = (&#39;number&#39;, &#39;title&#39;, &#39;content&#39;, &#39;img_url&#39;, &#39;url&#39;)


@admin.register(Keyword)
class KeywordAdmin(admin.ModelAdmin):
    list_display = (&#39;name&#39;, &#39;id&#39;)


@admin.register(FriendLink)
class FriendLinkAdmin(admin.ModelAdmin):
    list_display = (&#39;name&#39;, &#39;description&#39;, &#39;link&#39;, &#39;create_date&#39;, &#39;is_active&#39;, &#39;is_show&#39;)
    date_hierarchy = &#39;create_date&#39;
    list_filter = (&#39;is_active&#39;, &#39;is_show&#39;)</code></pre>
<p>此时，再次刷新博客admin页面，即可看到我们创建的表：<br><img src="https://i.loli.net/2019/11/09/XRjFVdeGoNfpbW4.png" alt="刷新admin页面" title="刷新admin页面"><br>我们可以对其进行增加、修改、删除操作, admin 也是 Django 中最方便的一个特性。</p>
<h3 id="博客首页开发"><a href="#博客首页开发" class="headerlink" title="博客首页开发"></a>博客首页开发</h3><h4 id="添加模板"><a href="#添加模板" class="headerlink" title="添加模板"></a>添加模板</h4><p>前面已经获取了 static、templates 文件，将 static 文件夹整个拷贝到博客项目根目录下，然后在将 templates 文件夹下的 html 文件全部拷贝到到 templates 目录下。</p>
<h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>Django 中后端的控制都是在视图函数中进行的，也就是 view.py，每创建一个 app，该 app 目录下都会有一个view.py，我们主要就是在这里进行后端代码的书写的。</p>
<pre><code class="python"># ---------------------------
__author__ = &#39;luyuonism&#39;
__date__ = &#39;2018/6/5 09:11:43&#39;
# ---------------------------

from django.views import generic
from django.shortcuts import get_object_or_404, get_list_or_404
from .models import Article, BigCategory, Category, Tag

# Create your views here.
class IndexView(generic.ListView):
    &quot;&quot;&quot;
        首页视图,继承自ListVIew，用于展示从数据库中获取的文章列表
    &quot;&quot;&quot;
    # 获取数据库中的文章列表
    model = Article
    # template_name属性用于指定使用哪个模板进行渲染
    template_name = &#39;index.html&#39;
    # context_object_name属性用于给上下文变量取名（在模板中使用该名字）
    context_object_name = &#39;articles&#39;</code></pre>
<h4 id="配置首页路由"><a href="#配置首页路由" class="headerlink" title="配置首页路由"></a>配置首页路由</h4><p>通过 url 将视图函数与模板关联起来</p>
<p>现在我们有了 index.html 页面，也有了视图函数 IndexView，但是怎么才能通过 127.0.0.1:8000 访问到这个页面呢？django中是通过 url 将这个页面与视图函数关联起来，也就是前后端的API接口。</p>
<p>添加 urls.py 文件   blog -&gt; luyu</p>
<p>配置页面路由   blog -&gt; luyu -&gt; urls.py</p>
<pre><code class="python">from django.conf.urls import url
from .views import IndexView

urlpatterns = [
    url(r&#39;^$&#39;, IndexView.as_view(template_name=&#39;index.html&#39;), name=&#39;index&#39;)
]</code></pre>
<p><strong>template_name 是指定使用的模板文件，传递给视图，进行数据渲染，后边详讲路由配置博客应用路由</strong></p>
<p>blog -&gt; blog -&gt; urls.py</p>
<pre><code class="python">from django.conf.urls import url, include
from django.contrib import admin

urlpatterns = [
    # 后台管理应用，django自带
    url(r&#39;^admin/&#39;, admin.site.urls),
    # storm 应用
    url(&#39;&#39;, include(&#39;storm.urls&#39;, namespace=&#39;blog&#39;)),  
]</code></pre>
<p>此时的项目结构：</p>
<pre><code>.
|-- blog
|   |-- luyu                # 博客应用
|   |   |-- migrations      # 数据库映射文件
|   |   |-- __init__.py     # 声明模块，内容默认为空
|   |   |-- admin.py        # 该应用的后台管理系统
|   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成
|   |   |-- models.py       # 数据模块，使用ORM框架
|   |   |-- tests.py        # 自动化测试的模块    
|   |   |-- urls.py         # 应用路由    
|   |   |-- views.py        # 执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写    
|   |-- blog                # 项目的容器
|   |   |-- __init__.py     # 声明模块，内容默认为空
|   |   |-- settings.py     # 该 Django 项目的设置/配置。
|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。
|   `-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目
|   |-- static              # 静态文件
|   |   |-- css
|   |   |-- fonts
|   |   |-- images
|   |   |-- js
|   |-- templates           # 模板文件
|   |   |-- about.html
|   |   |-- donate.html
|   |   |-- exchange.html
|   |   |-- index.html
|   |   |-- message.html
|   |   |-- project.html
|   |   |-- question.html
|   |   |-- resources.html
|   |   |-- technique.html
|   |   |-- wp-login.html
`-- manage.py
</code></pre><h4 id="修改静态文件路径"><a href="#修改静态文件路径" class="headerlink" title="修改静态文件路径"></a>修改静态文件路径</h4><p>访问 127.0.0.1:8000 这个页面时，Django 会通过正则表达式解析这个 url，从而判断出该 url 连接到哪个视图函数，我们这里对应的就是 IndexView。然后在 IndexView 中， 将 index.html 传递给前端，并通过浏览器展示给用户，这样我们便配置好了首页。<br><strong>首页样式的加载</strong></p>
<p>但是在刷新首页时，我们发现并没有样式，样式文件我们放在 static 文件夹中了，而index.html并没有定位到该目录</p>
<p>配置静态路径<br>blog -&gt; blog -&gt; settings.py</p>
<pre><code class="python">STATIC_URL = &#39;/static/&#39;
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, &#39;static&#39;)
]</code></pre>
<p>index.html 中，在第一行添加：</p>
<pre><code class="python">{% load staticfiles %}</code></pre>
<p>修改静态文件路径</p>
<pre><code class="python">&lt;link rel=&#39;stylesheet&#39; id=&#39;l2h_print_style-css&#39;  href=&#39;../static/css/print.min.css&#39; type=&#39;text/css&#39; media=&#39;print&#39; /&gt;
&lt;link rel=&#39;stylesheet&#39; id=&#39;style-css&#39;  href=&#39;../static/css/style.css&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;
&lt;script type=&#39;text/javascript&#39; src=&#39;../static/js/jquery.min.js&#39;&gt;&lt;/script&gt;</code></pre>
<p>修改静态文件路径为绝对路径</p>
<pre><code class="python">&lt;link rel=&#39;stylesheet&#39; id=&#39;l2h_print_style-css&#39;  href=&#39;/static/css/print.min.css&#39; type=&#39;text/css&#39; media=&#39;print&#39; /&gt;
&lt;link rel=&#39;stylesheet&#39; id=&#39;style-css&#39;  href=&#39;/static/css/style.css&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;
&lt;script type=&#39;text/javascript&#39; src=&#39;/static/js/jquery.min.js&#39;&gt;&lt;/script&gt;</code></pre>
<p>把静态路径修改为动态路径</p>
<pre><code class="python">&lt;link rel=&#39;stylesheet&#39; id=&#39;l2h_print_style-css&#39;  href=&#39;{% static 'css/print.min.css' %}&#39; type=&#39;text/css&#39; media=&#39;print&#39; /&gt;
&lt;link rel=&#39;stylesheet&#39; id=&#39;style-css&#39;  href=&#39;{% static 'css/style.css' %}&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;
&lt;script type=&#39;text/javascript&#39; src=&#39;{% static 'js/jquery.min.js' %}&#39;&gt;&lt;/script&gt;</code></pre>
<p>以上只是部分示列，要把 index.html文件中的 ../ 按上边的方式全改掉</p>
<p>绝对路径也可以加载静态文件，为什么要配置动态路径，</p>
<p>settings.py 中设置的静态路径，/static/ 这里对应前端模板的 /static/, 如果后台 static 文件夹名称修改了，前端那么多 /static/ 都要修改那不得累死，所以这里给 把静态文件路由固定为 /static/.</p>
<pre><code class="python">STATIC_URL = &#39;/static/&#39;

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, &#39;static&#39;)
]</code></pre>
<p>这样如果修改了 static 静态文件夹的名称，只需要修改一下 os.path.join(BASE_DIR, ‘static’) 名字即可</p>
<p>(BASE_DIR, ‘static’) 中的 ‘static’ 名字随便修改<br>配置好静态路径后，重启项目，查看运行效果<br>目前展示的还只是静态页面，首页中博客的内容仍然是<a href="https://cuiqingcai.com/" target="_blank" rel="noopener">模板</a>的内容</p>
<p>过程中可能遇到</p>
<pre><code class="python">&#39;Specifying a namespace in include() without providing an app_name &#39;
django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.</code></pre>
<p>的报错，python3 Django 环境下，如果遇到在根目录下urls.py中的include方法的第二个参数namespace添加之后就出错的问题。可以 luyu 目录下的urls.py中的urlpatterns前面加上app_name=’luyu’.</p>
<h4 id="整理项目结构"><a href="#整理项目结构" class="headerlink" title="整理项目结构"></a>整理项目结构</h4><h5 id="集中管理应用"><a href="#集中管理应用" class="headerlink" title="集中管理应用"></a>集中管理应用</h5><p>在项目根目录下新建 apps 文件，让项目变得更精致，把 luyu 和 user 拷贝到内 apps 文件内<br>现在项目结构</p>
<pre><code>.
|-- blog
|   |-- apps
|   |   |-- luyu                # 博客应用
|   |   |   |-- migrations      # 数据库映射文件
|   |   |   |-- __init__.py     # 声明模块，内容默认为空
|   |   |   |-- admin.py        # 该应用的后台管理系统
|   |   |   |-- apps.py         # 应用配置，Django-1.9以后自动生成
|   |   |   |-- models.py       # 数据模块，使用ORM框架
|   |   |   |-- tests.py        # 自动化测试的模块        
|   |   |   |-- views.py        # 项目业务逻辑主要在这里编写 
|   |   |-- user                # 用户应用
|   |   |   |-- migrations      
|   |   |   |-- __init__.py     
|   |   |   |-- admin.py        
|   |   |   |-- apps.py     
|   |   |   |-- models.py       
|   |   |   |-- tests.py          
|   |   |   |-- views.py        
|   |-- blog                # 项目的容器
|   |   |-- __init__.py     # 声明模块，内容默认为空
|   |   |-- settings.py     # 该 Django 项目的设置/配置。
|   |   |-- urls.py         # 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。
|   `-- wsgi.py             # 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目
|   |-- static              # 静态文件
|   |   |-- css
|   |   |-- fonts
|   |   |-- images
|   |   |-- js
|   |-- templates           # 模板文件
|   |   |-- about.html
|   |   |-- donate.html
|   |   |-- exchange.html
|   |   |-- index.html
|   |   |-- message.html
|   |   |-- project.html
|   |   |-- question.html
|   |   |-- resources.html
|   |   |-- technique.html
|   |   |-- wp-login.html
`-- manage.py</code></pre><p>把鼠标放在apps上右击鼠标，选择 Mark Directory as -&gt; Sources Root 点击</p>
<p>在配置文件中配置应用文件路径</p>
<p>blog -&gt; blog -&gt; settings.py</p>
<pre><code class="python"># 添加 apps 目录
sys.path.insert(0, os.path.join(BASE_DIR, &#39;apps&#39;))</code></pre>
<h5 id="制作基础模板"><a href="#制作基础模板" class="headerlink" title="制作基础模板"></a>制作基础模板</h5><p>分析一下模板博客页面<br>生活笔记、技术杂谈、福利专区、文章归档、标签、生活笔记下拉菜单、技术杂谈下拉菜单</p>
<p>这些页面属于同一个页面，只是不同类别展示的文章不同而已</p>
<p>首页和上边的区别就是多了一个轮播图</p>
<p>关于自己、给我留言、赞助作者、属于单个静态页面加上一个评论区</p>
<p>技术交流、提问交流、项目合作、属于单个静态页面</p>
<p>那么初步分析，可以有两个模板</p>
<p>一区为顶部基础模板，几乎网站的每个页面都要用到</p>
<p>二区 为幻灯片，热门推荐，只有首页有</p>
<p>三区为侧边栏，分类页、标签页、归档页也都有用到</p>
<p>四区就是内容展示区了，分类页、标签页、详情页都有用到</p>
<p>综上，用到的地方多的是 一区、三区、四区</p>
<p>四区基本都是伴随一区、三区出现的，也即四区继承一区或者三区</p>
<p>所以，需要两个基础模板，就是 一个是一区，一个是一区结合三区</p>
<p>头部一区称作 base.html、一区加侧边栏三区称作 base_right.html</p>
<p>base_right.html 继承 base.html</p>
<p><a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base.html" target="_blank" rel="noopener">base.html</a></p>
<p><a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_right.html" target="_blank" rel="noopener">base_right.html</a></p>
<p>index.html 改写一下，<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/index.html" target="_blank" rel="noopener">index.html</a></p>
<h4 id="Django-工作原理"><a href="#Django-工作原理" class="headerlink" title="Django 工作原理"></a>Django 工作原理</h4><p>视图函数（类），简称视图，是一个简单的 Python 函数（类），它接收 Web 请求并且返回 Web 响应。响应可以是一个网页的 HTML 内容，一个重定向，一个404错误，一个 XML 文档，或者一张图片，甚至一个文件。无论视图本身包含什么逻辑，都要返回响应。代码书写位置无要求，只要它在你当前项目目录下面。除此之外没有更多的要求——可以说 “没有什么神奇的地方”。为了将代码放在某处，大家约定成俗将视图放置在项目（project）或应用程序（app）目录中的名为views.py的文件中</p>
<p>正确的流程，应该是，先分析前端代码，来配置路由，然后书写视图逻辑</p>
<p>Django 工作原理：<br>用户发出 http 请求 -&gt; 匹配路由 -&gt; 进入视图 -&gt; 根据用户请求在视图内编写逻辑 -&gt; 把渲染后的 html 代码返给浏览器 -&gt; 浏览器解析后呈现给用户</p>
<p>用户请求：就是 url(网址)</p>
<p>路由：Django 根据 用户请求的地址，来判断用户是干啥的，把任务交给指定的视图函数去干活</p>
<p>视图：接收到路由委派的任务后，开始操作数据库，增、删、查，基本就这些个活，干好后，把渲染后的thml交给浏览器，浏览器解析后展示给用户要看的东西</p>
<h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>blog -&gt;templates -&gt; base.html</p>
<p>头部引入文件，staticfiles静态文件、blog_tags 自定义模板标签，记得无论那个页面只要用到里边的函数都要在头部引入</p>
<pre><code class="python">{% load staticfiles %}
{% load blog_tags %}
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;</code></pre>
<p><a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE.html" target="_blank" rel="noopener">导航栏渲染数据</a></p>
<p>blog -&gt; luyu -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py"># 创建了新的tags标签文件后必须重启服务器

from django import template
from ..models import Article, Category, Tag, Carousel, FriendLink, BigCategory, Activate, Keyword
from django.db.models.aggregates import Count
from django.utils.html import mark_safe
import re

# 注册自定义标签函数
register = template.Library()


# 获取导航条大分类查询集
@register.simple_tag
def get_bigcategory_list():
    &quot;&quot;&quot;返回大分类列表&quot;&quot;&quot;
    return BigCategory.objects.all()


# 返回文章分类查询集
@register.simple_tag
def get_category_list(id):
    &quot;&quot;&quot;返回小分类列表&quot;&quot;&quot;
    return Category.objects.filter(bigcategory_id=id)</code></pre>
<p>Templatetags:</p>
<p>必须写的头部</p>
<pre><code class="py">from django import template
# 注册自定义标签函数
register = template.Library()</code></pre>
<p>自定义模版标签，和(view)视图的区别就是不需要接收 request 请求，只需要在模板也即前端页面接收参数，返回需要的数据进行展示即可。也就意味着，除了需要和用户交互的内容，比如用户给某篇章点赞，需要使用 Jquery + ajax 实现无刷新给页面喜欢数量加一，这个就需要 Jquery 接收到用户点击行为后，AJAX 携带信息给指定路由发出请求，视图接收到请求，把处理结果返给 AJAX 实现无数刷新地更新喜欢量。只要不涉及交互，的数据请求都可以放在 Templatetags 处理前端需要展示的数据</p>
<h4 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h4><p>blog -&gt;templates -&gt; index.html<br>幻灯片部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/indexcarousel.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; luyu -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py"># 获取滚动的大幻灯片查询集、获取左侧的幻灯片查询集，这两个部分用的图片是一样的
@register.simple_tag
def get_carousel_index():
    return Carousel.objects.filter(number__lte=5)</code></pre>
<p>在数据库内给幻灯片添加一些图片</p>
<p>不要忘了在index.html中加载blog_tags</p>
<pre><code>{% load blog_tags %}</code></pre><h4 id="热门文章"><a href="#热门文章" class="headerlink" title="热门文章"></a>热门文章</h4><p>blog -&gt;templates -&gt; index.html<br>热门文章部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/indexhotposts.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py"># 获取热门排行数据查询集，参数：sort 文章类型， num 数量
@register.simple_tag
def get_article_list(sort=None, num=None):
    &quot;&quot;&quot;获取指定排序方式和指定数量的文章&quot;&quot;&quot;
    if sort:
        if num:
            return Article.objects.order_by(sort)[:num]
        return Article.objects.order_by(sort)
    if num:
        return Article.objects.all()[:num]
    return Article.objects.all()</code></pre>
<h4 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h4><p>blog -&gt;templates -&gt; index.html<br>文章列表部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/indexarticle.html" target="_blank" rel="noopener">index.html</a>的修改<br>这里没用到自定义模板标签</p>
<h4 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h4><p>blog -&gt;templates -&gt; base_right.html<br>首先个人联系方式的矢量图没显示出来，需要引入一下矢量图文件<br>首先去awesome官网下载 font-awesome-4.7.0或者拷贝Github项目中的矢量文件，然后把文件放入 static 静态文件中，然后在<br>blog -&gt;templates -&gt; base.html中的head标签引入头部文件的地方导入路径</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; id=&#39;page-list-style-css&#39;  href=&#39;/static/font-awesome-4.7.0/css/font-awesome.min.css&#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;</code></pre><p>侧边栏热门专题轮播图</p>
<p>blog -&gt;templates -&gt; base_right.html</p>
<p>不要忘记在头部引入自定义模板标签 </p>
<pre><code>{% load blog_tags %}</code></pre><p>热门专题轮播图部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_righthot.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py"># 获取右侧栏热门专题幻灯片查询集
@register.simple_tag
def get_carousel_right():
    return Carousel.objects.filter(number__gt=5, number__lte=10)</code></pre>
<p>Carousel表前五个是首页大轮播图、后五个是热门专题轮播图</p>
<h4 id="文章归档"><a href="#文章归档" class="headerlink" title="文章归档"></a>文章归档</h4><p>blog -&gt;templates -&gt; base_right.html<br>文章归档部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_righarchive.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py">blog -&gt; templatetags -&gt; blog_tags.py

# 获取归档文章查询集
@register.simple_tag
def get_data_date():
    &quot;&quot;&quot;获取文章发表的不同月份&quot;&quot;&quot;
    article_dates = Article.objects.datetimes(&#39;create_date&#39;, &#39;month&#39;, order=&#39;DESC&#39;)
    return article_dates</code></pre>
<h4 id="猜你喜欢"><a href="#猜你喜欢" class="headerlink" title="猜你喜欢"></a>猜你喜欢</h4><p>blog -&gt;templates -&gt; base_right.html<br>猜你喜欢部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_righlove.html" target="_blank" rel="noopener">index.html</a>的修改<br>blog -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py"># 文章相关标签函数，和热门文章使用同一个函数
@register.simple_tag
def get_article_list(sort=None, num=None):
    &#39;&#39;&#39;获取指定排序方式和指定数量的文章&#39;&#39;&#39;
    if sort:
        if num:
            return Article.objects.order_by(sort)[:num]
        return Article.objects.order_by(sort)
    if num:
        return Article.objects.all()[:num]
    return Article.objects.all()</code></pre>
<p>和热门文章使用同一个函数</p>
<h4 id="标签云和友情链接"><a href="#标签云和友情链接" class="headerlink" title="标签云和友情链接"></a>标签云和友情链接</h4><p>blog -&gt;templates -&gt; base_right.html<br>标签云和友情链接部分<a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/base_rightaf.html" target="_blank" rel="noopener">index.html</a>的修改<br>storm -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py"># 获取文章标签信息，参数文章ID
@register.simple_tag
def get_article_tag(article_id):
    return Tag.objects.filter(article=article_id)</code></pre>
<p>有点乱，<a href="https://github.com/luyuonism/blog" target="_blank" rel="noopener">完整代码</a></p>
<h4 id="渲染分类页面数据"><a href="#渲染分类页面数据" class="headerlink" title="渲染分类页面数据"></a>渲染分类页面数据</h4><p>在 blog -&gt; templates 中新建文件 content.html</p>
<p>生活笔记分类</p>
<p>blog -&gt; templates -&gt; <a href="https://github.com/luyuonism/blog/blob/master/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6/content.html" target="_blank" rel="noopener">content.html</a></p>
<p>自定义模板标签</p>
<p>blog -&gt; templatetags -&gt; blog_tags.py</p>
<pre><code class="py">@register.simple_tag
def get_title(category):
    a = BigCategory.objects.filter(slug=category)
    if a:
        return a[0]</code></pre>
<p>头部引入</p>
<pre><code>{% load blog_tags %}</code></pre><p>首页 大分类跳转地址</p>
<pre><code>&lt;a href=&quot;{% url 'blog:category' big.slug '' %}&quot;&gt;{{ big.name }}&lt;/a&gt;</code></pre><p>首页大分类下拉菜单小分类地址</p>
<pre><code>&lt;a href=&quot;{% url 'blog:category'  big.slug   c.slug  %}&quot;&gt;{{ c.name }}&lt;/a&gt;</code></pre><p>配置路由</p>
<pre><code class="py"># 分类页面
url(r&#39;^category/(?P&lt;bigslug&gt;.*?)/(?P&lt;slug&gt;.*?)&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;category&#39;),</code></pre>
<p>简单理解路由，这里都是我的个人理解可能不会有官方文档解释的科学，如果读完还有疑惑不要纠结，问题不大，刚开始接触不需要理解的太深入。</p>
<pre><code class="py">{% url 'blog:category' big.slug '' %}</code></pre>
<p>big.slug：是从 bigcategory 表取出的数据，是导航菜单，大分类字段</p>
<p>Django 的路由其实就是使用正则表达式匹配前端 http 请求的路径</p>
<p>http 请求可以理解为，前台的点击事件，比如用户点击 生活笔记 或者 个人随笔</p>
<p>就是告诉服务器我想看这些内容，那么怎么告诉，就是发送 http 请求，这里 {% url 'blog:category' big.slug '' %} 就是 Django 模板定义请求路径的方式</p>
<p>blog：主路由 url(‘’, include(‘storm.urls’, namespace=’blog’))， 定义应用空间名 namespace 为 blog，这样后台修改应用 storm 名不会影响前台渲染数据，和配置静态路径一样的道理</p>
<p>category：是storm应用路由 url(r’^category/(?P.?)/(?P.?)’, IndexView.as_view(template_name=’content.html’), name=’category’) 中的开始匹配位置</p>
<p>比如 这里用户点击生活笔记，那么他的请求路经是</p>
<p>浏览器解析</p>
<pre><code class="py">{% url 'blog:category' big.slug '' %}</code></pre>
<p>后路径即为<br>http://域名.com/category/diary</p>
<p>则 Django 首先去 项目容器 blog -&gt; blog -&gt; urls.py 中匹配这个路径，匹配的规则是首先精准匹配这个路径，就是拿 category 去对比 路由的第一个参数</p>
<p>发现没有 category，如果未匹配到，则进行模糊匹配，就是直接走路由第一个参数为空的路由，那么就进到了</p>
<p>url(‘’, include(‘storm.urls’, namespace=’blog’)) 这里，include 的第一个参数指向的是子路由位置，</p>
<p>通过这里进入 blog -&gt; storm -&gt; urls.py 继续拿 category 匹配路径，在这里匹配到了</p>
<pre><code class="py">url(r&#39;^category/(?P&lt;bigslug&gt;.*?)/(?P&lt;slug&gt;.*?)&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;category&#39;)</code></pre>
<p>好了第一个http请求已经找到归宿</p>
<pre><code class="py">{% url 'blog:category' big.slug '' %}</code></pre>
<p>big.slug：第一个参数 就是 diary，通过 正则匹配到 diary</p>
<p>‘’：第二个参数为空，因为这里请求的是大分类，但是大分类和小分类这里使用的是同一个路由，所以要置空</p>
<p>如果 用户点击个人随笔，那么请求的路经是 http://域名.com/category/diary/life</p>
<pre><code class="py">{% url 'blog:category'  big.slug   c.slug  %}</code></pre>
<p>big.slug：第一个参数，是从数据库中取出的大分类，即为 diary</p>
<p>c.slug：第二个参数是从 category表取出的文章分类字段，即为 life</p>
<h4 id="关于自己"><a href="#关于自己" class="headerlink" title="关于自己"></a>关于自己</h4><p>关于自己(about)、给我留言((message)、赞助作者(donate)、技术交流(exchange)、提问交流(question)、项目合作(project)、属于同一类页面，都是静态展示页面 所以要单独创建页面</p>
<p>blog -&gt; templates -&gt; about.html<br>配置路由</p>
<pre><code class="py">url(r&#39;^category/about/$&#39;, AboutView, name=&#39;about&#39;),</code></pre>
<p>创建视图</p>
<pre><code class="py">def AboutView(request):
    return render(request, &#39;about.html&#39;, {&#39;category&#39;: &#39;about&#39;})</code></pre>
<p>生活笔记、技术杂谈、福利专区、生活笔记下拉菜单、技术杂谈下拉菜单、标签云、归档、都属于同一类，模仿实现即可</p>
<h3 id="博客详情页面"><a href="#博客详情页面" class="headerlink" title="博客详情页面"></a>博客详情页面</h3><p>博客的详情页同样继承自 base.html 模板，侧边栏就不需要了</p>
<p>blog -&gt; luyu -&gt; view.py</p>
<pre><code class="py">class DetailView(generic.DetailView):
    &quot;&quot;&quot;
        Django有基于类的视图DetailView,用于显示一个对象的详情页，我们继承它
    &quot;&quot;&quot;
    # 获取数据库中的文章列表
    model = Article

    # template_name属性用于指定使用哪个模板进行渲染
    template_name = &#39;article.html&#39;

    # context_object_name属性用于给上下文变量取名（在模板中使用该名字）
    context_object_name = &#39;article&#39;

    def get_object(self):
        obj = super(DetailView, self).get_object()
        # 设置浏览量增加时间判断,同一篇文章两次浏览超过半小时才重新统计阅览量,作者浏览忽略
        u = self.request.user
        ses = self.request.session
        the_key = &#39;is_read_{}&#39;.format(obj.id)
        is_read_time = ses.get(the_key)
        if u != obj.author:
            if not is_read_time:
                obj.update_views()
                ses[the_key] = time.time()
            else:
                now_time = time.time()
                t = now_time - is_read_time
                if t &gt; 60 * 30:
                    obj.update_views()
                    ses[the_key] = time.time()
        # 文章可以使用markdown书写，带格式的文章，像csdn写markdown文章一样
        md = markdown.Markdown(extensions=[
            &#39;markdown.extensions.extra&#39;,
            &#39;markdown.extensions.codehilite&#39;,
            TocExtension(slugify=slugify),
        ])
        obj.body = md.convert(obj.body)
        obj.toc = md.toc
        return obj

    def get_context_data(self, **kwargs):
        context = super(DetailView, self).get_context_data(**kwargs)
        context[&#39;category&#39;] = self.object.id
        return context</code></pre>
<p>blog -&gt; luyu -&gt; urls.py</p>
<pre><code class="py">from django.conf.urls import url
from .views import IndexView, DetailView

urlpatterns = [
    # 首页
    url(r&#39;^$&#39;, IndexView.as_view(template_name=&#39;index.html&#39;), name=&#39;index&#39;),  # 主页，自然排序
    # 给我留言
    url(r&#39;^category/message/$&#39;, MessageView, name=&#39;message&#39;),
    # 关于自己
    url(r&#39;^category/about/$&#39;, AboutView, name=&#39;about&#39;),
    # 赞助作者
    url(r&#39;^category/donate/$&#39;, DonateView, name=&#39;donate&#39;),
    # 技术交流
    url(r&#39;^category/exchange/$&#39;, ExchangeView, name=&#39;exchange&#39;),
    # 项目合作
    url(r&#39;^category/project/$&#39;, ProjectView, name=&#39;project&#39;),
    # 提问交流
    url(r&#39;^category/question/$&#39;, QuestionView, name=&#39;question&#39;),
    # 分类页面
    url(r&#39;^category/(?P&lt;bigslug&gt;.*?)/(?P&lt;slug&gt;.*?)&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;category&#39;),
    # 归档页面
    url(r&#39;^date/(?P&lt;year&gt;\d+)/(?P&lt;month&gt;\d+)/$&#39;, IndexView.as_view(template_name=&#39;archive.html&#39;), name=&#39;date&#39;),
    # 标签页面
    url(r&#39;^tag/(?P&lt;tag&gt;.*?)/$&#39;, IndexView.as_view(template_name=&#39;content.html&#39;), name=&#39;tag&#39;),
    # 文章详情页面
    url(r&#39;^article/(?P&lt;slug&gt;.*?)/$&#39;, DetailView.as_view(), name=&#39;article&#39;),
]</code></pre>
<p>新添加的路由</p>
<pre><code class="py">url(r&#39;^article/(?P&lt;slug&gt;.*?)/$&#39;, DetailView.as_view(), name=&#39;article&#39;),</code></pre>

  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>本文作者：</strong>ruijielu<br>
<strong>本文链接：</strong><a href="https://luyuonism.github.io/2018/06/05/django/" title="https:&#x2F;&#x2F;luyuonism.github.io&#x2F;2018&#x2F;06&#x2F;05&#x2F;django&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;luyuonism.github.io&#x2F;2018&#x2F;06&#x2F;05&#x2F;django&#x2F;</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '6697f1e2bc68a9625fed',
        clientSecret: '173e837a4a0788e2d0c2ecfe68911cd3a3efc2d1',
        id: window.location.pathname,
        repo: 'https://luyuonism.github.io',
        owner: 'luyuonism',
        admin: 'luyuonism'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1574562195853"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>

  





</body>

</html>
