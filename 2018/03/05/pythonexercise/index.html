<!DOCTYPE html>
<html>

<head>
  
  <title>python练习 - Lu Ruijie&#39;s Personal Homepage</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/timg.ico" type="image/png" />
  <meta name="description" content="python练习题">
<meta name="keywords" content="python,interview">
<meta property="og:type" content="article">
<meta property="og:title" content="python练习">
<meta property="og:url" content="https:&#x2F;&#x2F;luyuonism.github.io&#x2F;2018&#x2F;03&#x2F;05&#x2F;pythonexercise&#x2F;index.html">
<meta property="og:site_name" content="Lu Ruijie&#39;s Personal Homepage">
<meta property="og:description" content="python练习题">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;xX397KNi8BqISel.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;X62Ee9B4FNydVG1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;dDzm9Q3OkpqoKv8.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;H895qgwMEmsTDUS.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;pCTkmRcHu8j5Doy.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;wAQEXyISLzaPH5c.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;9YMgpwvVoNEJKcS.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;cz6oACOWBdjis2P.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;3paj7P1gr9A4UcI.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;dvtKYM4f5Ix3S1G.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;xEajlm7CFnN1HJi.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;epZqE4oX2zWrQwl.png">
<meta property="og:updated_time" content="2019-11-19T11:16:16.200Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;11&#x2F;15&#x2F;xX397KNi8BqISel.png">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1574162503077">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://i.loli.net/2019/01/13/5c3aec85a4343.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <a href="javascript:;" target="_blank" rel="noopener" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>
        <a href="/" title="ruijielu" class="mdui-btn mdui-btn-icon"><img src="/avatar.png"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="ruijielu">
            <img src="/avatar.png" alt="ruijielu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>8</div>
        <div><span>标签</span>3</div>
        <div><span>分类</span>0</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于主页">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于主页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/8736309" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/luyuonism/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="/weixin.jpg" target="_blank" mdui-tooltip="{content: '微信 luyuonism'}" style="color: rgb(102, 255, 204);background-color: rgba(102, 255, 204, .15);">
            <i class="nexmoefont icon-wechat-fill"></i>
        </a><a class="mdui-ripple" href="/qq.jpg" target="_blank" mdui-tooltip="{content: 'QQ 1501405087'}" style="color: rgb(102, 204, 255);background-color: rgba(102, 204, 255, .15);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://weibo.com/6416453194/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" mdui-tooltip="{content: '微博'}" style="color: rgb(255, 69, 24);background-color: rgba(255, 69, 24, .15);">
            <i class="nexmoefont icon-weibo"></i>
        </a><a class="mdui-ripple" href="https://www.zhihu.com/people/lu-yu-36-39-54/activities" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: rgb(11, 141, 255);background-color: rgba(11, 141, 255, .15);">
            <i class="nexmoefont icon-zhihu"></i>
        </a>
    </div>
</div>
  
  

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/django/" style="font-size: 15px;">django</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/python/" style="font-size: 20px;">python</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li></ul>
    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2019/11/05/django-STATIC_ROOT/">django配置  STATIC_ROOT</a>
          </li>
        
          <li>
            <a href="/2019/06/05/python-f-string/">python f-string式格式化</a>
          </li>
        
          <li>
            <a href="/2018/07/05/python-basis/">python基础</a>
          </li>
        
          <li>
            <a href="/2018/06/05/decorator/">decorator</a>
          </li>
        
          <li>
            <a href="/2018/06/05/sql/">MySql</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 ruijielu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com" target="_blank">Git</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
        <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2899602303,325242151&fm=26&gp=0.jpg">
        
        <h1>python练习</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2018年03月05日</a>
    <a><i class="nexmoefont icon-areachart"></i>7,769 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 30 分钟</a>
    
    
      <a class="nexmoefont icon-tag-fill -link" href="/tags/interview/" rel="tag">interview</a> <a class="nexmoefont icon-tag-fill -link" href="/tags/python/" rel="tag">python</a>
    
  </div>
  <article>
    <p>python练习题</p>
<a id="more"></a>

<p><a href="#什么是Python">什么是Python</a><br><a href="#PEP8">PEP8</a><br><a href="#python里面如何拷贝一个对象？">python里面如何拷贝一个对象？</a><br><a href="#python的内存管理是怎样的？">python的内存管理是怎样的？</a><br><a href="#什么是lambda函数？它有什么好处？">什么是lambda函数？它有什么好处？</a><br><a href="#python自省">python自省</a><br><a href="#谈一谈python的装饰器">谈一谈python的装饰器</a><br><a href="#python元类">python元类</a><br><a href="#列举Http请求中常见的请求方式">列举Http请求中常见的请求方式</a><br><a href="#谈谈你对HTTP协议的认识">谈谈你对HTTP协议的认识</a><br><a href="#简述MVC模式和MVT模式">简述MVC模式和MVT模式</a><br><a href="#简述Django请求生命周期">简述Django请求生命周期</a><br><a href="#django中间件生命周期">django中间件生命周期</a><br><a href="#简述什么是FBV和CBV">简述什么是FBV和CBV</a><br><a href="#对ORM的理解">对ORM的理解</a><br><a href="#常用视图响应的方式">常用视图响应的方式</a><br><a href="#django中间件的5个方法">django中间件的5个方法</a><br><a href="#django中csrf的实现机制">django中csrf的实现机制</a><br><a href="#cookie和session的区别">cookie和session的区别</a><br><a href="#django orm 中所有的方法">django orm 中所有的方法</a></p>
<h2 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a><a name="#什么是Python">什么是Python</a></h2><p>Python是种解释型语言。这就是说，与C语言和C衍生语言不同，Python代码在运行前不需要编译。其他的解释型语言还包括PHP和Ruby；<br>Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。可以直接编写类似x=111和x=”I’m a string”这样的代码，程序不会报错；<br>Python非常适合面向对象的编程，因为支持通过组合composition与继承inheritance的方式定义类class。<br>Python中没有访问说明符access specifier，类似C++中的public和private。<br>Python语言中，函数是第一类对象。这指的是它们可以被指定给变量，函数既能返回函数类型，也可以接受函数作为输入。类也是第一类对象；<br>Python代码编写快，但运行速度比编译语言通常要慢。好在Python允许加入基于C语言编写扩展，因此我们能够优化代码，消除瓶颈，这点通常是可以实现的。Numpy就是一个很好地例子，它运行速度真的非常快，因为很多算术运算其实不是通过Python实现的。<br>Python的用途非常广泛：网络应用，科学建模，自动化和大数据应用等。它也常被用作“胶水语言”帮助其他语言和组件改善其运行状况；<br>Python让困难的事变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。</p>
<h2 id="PEP8"><a href="#PEP8" class="headerlink" title="PEP8"></a><a name="#PEP8">PEP8</a></h2><p>PEP8是一个编程规范，内容是一些关于如何让你的程序更具可读性的建议。<br>主要内容包括代码编排、文档编排、空格使用、注释、文档描述、命名规范、编码建议等等。</p>
<h2 id="python里面如何拷贝一个对象？"><a href="#python里面如何拷贝一个对象？" class="headerlink" title="python里面如何拷贝一个对象？"></a><a name="#python里面如何拷贝一个对象？">python里面如何拷贝一个对象？</a></h2><ol>
<li>对象赋值</li>
</ol>
<p><strong>赋值（=）</strong>，赋值的本质就是让多个变量同时引用同一个对象的地址，修改其中任意一个变量都会影响到另一个。</p>
<ul>
<li>对<strong>不可变对象赋值</strong>，实际就是在内存中<strong>开辟一片空间指向新的对象</strong>，原不可变对象不会被修改。<br><img src="https://i.loli.net/2019/11/15/xX397KNi8BqISel.png" alt="不可变对象赋值.png" title="不可变对象赋值"><pre><code class="py">a = 1
print(a, id(a))  # 1 1413639232
b = a
print(b, id(b))  # 1 1413639232
a = 2
print(a, id(a), b, id(b))  # 2 1413639264 1 1413639232</code></pre>
</li>
<li><strong>可变对象</strong>保存的并不是真正的对象数据，而是对象的引用。当对可变对象进行赋值时，<strong>只是将可变对象中保存的引用指向了新的对象。（地址没变）</strong><br><img src="https://i.loli.net/2019/11/15/X62Ee9B4FNydVG1.png" alt="可变对象赋值.png" title="可变对象赋值"><pre><code class="py">l1 = [1, 2, 3, [1, 2]]
print(l1, id(l1))  # [1, 2, 3, [1, 2]] 1615735547144
l2 = l1
print(l2, id(l2))  # [1, 2, 3, [1, 2]] 1615735547144
l1[3][0] = 11
print(l1, id(l1), l2, id(l2))  # [1, 2, 3, [11, 2]] 1615735547144 [1, 2, 3, [11, 2]] 1615735547144</code></pre>
</li>
</ul>
<ol start="2">
<li><strong>浅拷贝</strong>：拷贝父对象，不会拷贝对象的内部的子对象。（<strong>顶层拷贝值，底层拷贝引用</strong>）{copy模块的copy.copy()函数}</li>
</ol>
<ul>
<li><strong>不可变对象</strong>只在修改的时候才会在内存中开辟新的空间， 而拷贝实际上是让多个对象同时指向一个引用，<strong>和对象的赋值没区别</strong>。<pre><code class="py">import copy
a = 1
print(a, id(a))    # 1 1413639232
b = copy.copy(a)
print(b, id(b))    # 1 1413639232
a = 2
print(a, id(a), b, id(b))   # 2 1413639264 1 1413639232</code></pre>
</li>
<li><strong>可变对象</strong>的拷贝，会在内存中开辟一个新的空间来保存拷贝的数据。当再改变之前的对象时，对拷贝之后的对象没有任何影响。（<strong>顶层拷贝值，底层拷贝引用</strong>）<br><img src="https://i.loli.net/2019/11/15/dDzm9Q3OkpqoKv8.png" alt="可变对象拷贝1.png" title="可变对象拷贝1"><br><img src="https://i.loli.net/2019/11/15/H895qgwMEmsTDUS.png" alt="可变对象拷贝2.png" title="可变对象拷贝2"><pre><code class="py">l1 = [1, 2, 3]
print(l1, id(l1))   # [1, 2, 3] 2576411846088
l2 = copy.copy(l1)
print(l2, id(l2))   # [1, 2, 3] 2576411846024
l1[0] = 11
print(l1, id(l1), l2, id(l2))   # [11, 2, 3] 2576411846088 [1, 2, 3] 2576411846024</code></pre>
<pre><code class="py">l1 = [1, 2, 3, [1, 2]]
print(l1, id(l1))   # [1, 2, 3, [1, 2]] 1595652433288
l2 = copy.copy(l1)
print(l2, id(l2))   # [1, 2, 3, [1, 2]] 1595652433544
l1[3][0] = 11
print(l1, id(l1), l2, id(l2))   # [1, 2, 3, [11, 2]] 1595652433288 [1, 2, 3, [11, 2]] 1595652433544</code></pre>
再举一个例子：（顶层拷贝值，底层拷贝引用） a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。<br><img src="https://i.loli.net/2019/11/15/pCTkmRcHu8j5Doy.png" alt="例1.png" title="例1"></li>
</ul>
<ol start="3">
<li><strong>深拷贝</strong>：<strong>完全拷贝</strong>了父对象及其子对象。深拷贝就是将顶级对象以及子对象的值同时复制给新对象，此时<strong>修改任何一个都不会影响另一个</strong>。{copy模块的 copy.deepcopy()函数}</li>
</ol>
<ul>
<li><strong>不可变对象的深拷贝</strong>:<pre><code class="py">import copy
a = 1
print(a, id(a))  # 1 1413639232
b = copy.deepcopy(a)
print(b, id(b))  # 1 1413639232
a = 2
print(a, id(a), b, id(b))  # 2 1413639264 1 1413639232</code></pre>
</li>
<li><strong>可变对象的深拷贝</strong>:<br><img src="https://i.loli.net/2019/11/15/wAQEXyISLzaPH5c.png" alt="可变对象深拷贝.png" title="可变对象深拷贝"><pre><code class="py">l1 = [1, 2, 3]
print(l1, id(l1))   # [1, 2, 3] 2062148953544
l2 = copy.deepcopy(l1)
print(l2, id(l2))   # [1, 2, 3] 2062148953480
l1[0] = 11
print(l1, id(l1), l2, id(l2))  # [11, 2, 3] 2062148953544 [1, 2, 3] 2062148953480</code></pre>
<pre><code class="py">l1 = [1, 2, 3, [1, 2]]
print(l1, id(l1))  # [1, 2, 3, [1, 2]] 1911038862728
l2 = copy.deepcopy(l1)
print(l2, id(l2))  # [1, 2, 3, [1, 2]] 1911038881544
l1[3][0] = 11
print(l1, id(l1), l2, id(l2))  # [1, 2, 3, [11, 2]] 1911038862728 [1, 2, 3, [1, 2]] 1911038881544</code></pre>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>不可变对象在赋值时会开辟新空间。</li>
<li>可变对象在赋值时，修改一个的值，另一个也会发生改变。</li>
<li>深、浅拷贝对不可变对象拷贝时，不开辟新空间，相当于赋值操作。</li>
<li>浅拷贝在拷贝时，只拷贝第一层中的引用，如果元素是可变对象，并且被修改，那么拷贝的对象也会发生变化。</li>
<li>深拷贝在拷贝时，会逐层进行拷贝，直到所有的引用都是不可变对象为止。</li>
<li>大多数情况下，编写程序时，都是使用浅拷贝，除非有特定的需求。</li>
<li>浅拷贝的优点：拷贝速度快，占用空间少，拷贝效率高</li>
</ul>
<h2 id="python的内存管理是怎样的？"><a href="#python的内存管理是怎样的？" class="headerlink" title="python的内存管理是怎样的？"></a><a name="#python的内存管理是怎样的？">python的内存管理是怎样的？</a></h2><p>答:python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。为python的堆空间分配内存的是python的内存管理模块进行的，核心api会提供一些访问该模块的方法供程序员使用。python自有的垃圾回收机制回收并释放没有被使用的内存供别的程序使用。<br>详解python的内存管理:</p>
<ol>
<li><p>对象的内存使用<br>赋值语句是语言最常见的功能了。但即使是最简单的赋值语句，也可以很有内涵.<br>首先, python的赋值语句：</p>
<pre><code class="py">a = 1</code></pre>
<p>整数“1”为一个对象，存储在内存空间中。a是一个引用。利用赋值语句，将引用a指向对象1。Python是动态类型的语言，对象与引用分离。<br>Python像使用“筷子”那样，通过引用来接触和翻动真正的食物——对象。<br>下面通过一系列的实验，可以通过python的内置函数id()，来探索对象在内存的存储:</p>
<pre><code class="py">&gt;&gt;&gt; a = 1
&gt;&gt;&gt; id(a)
140035503539424  # 内存地址的十进制表示
&gt;&gt;&gt; hex(id(a))
&#39;0x7f5c8e71c4e0&#39;  # 内存地址的十六进制表示</code></pre>
<p>在python中整数和短小的字符，python都会缓存这些对象，以便重复使用，当我们创建多个等于1的引用的时候，实际是让所有引用都指向同一个对象：</p>
<pre><code class="py">&gt;&gt;&gt; b = 1
&gt;&gt;&gt; id(b)
140035503539424  # 等于上面id(a)的值</code></pre>
<p>对比可以看出a和b实际是指向同一个对象的不同引用。<br>为了校验两个引用指向同一个对象，我们可以用“is”来判断。is用于判断两个引用所指的对象是否相同。</p>
<pre><code class="py">a = 1
b = 1
print(a is b)
True
a = &quot;good&quot;
b = &quot;good&quot;
print(a is b)
True
a = &quot;very good morning&quot;
b = &quot;very good morning&quot;
print(a is b)
True   # 如果此时是False，与我的为True不同，实际是python版本原因
# Python2.3简单整数缓存范围是(-1,100)，Python2.5.4以后简单整数缓存范围至少是(-5,256)。所有的短字符也都在缓存区。
a = &quot;为了校验两个引用指向同一个对象，我们可以用“is”来判断。is用于判断两个引用所指的对象是否相同。&quot;
b = &quot;为了校验两个引用指向同一个对象，我们可以用“is”来判断。is用于判断两个引用所指的对象是否相同。&quot;
print(a is b)
False  # 增加了字符串的长度，结果也是False
a = []
b = []
print(a is b)
False</code></pre>
<p>根据上面的运行结果，可以看到由于python缓存了整数和短字符串，因此每个对象只存有一份。比如所有的1的引用都指向同一对象。即使使用赋值语句，也只是创造了新的引用，而不是对象本身，长的字符串和其他对象可以有多个相同对象，可以使用赋值语句创建出新的对象。<br>在python中，每个对象都有存有指向该对象的引用总数，即<strong>引用计数</strong>(reference count)<br>我们可以使用sys包中的getrefcount()，来查看某个对象的引用计数。需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，会创建一个临时引用，所以结果会比预期多1</p>
<pre><code class="py">from sys import getrefcount
a = [1, 2, 3]
print(getrefcount(a))
# 2
b = a
print(getrefcount(b))
# 3</code></pre>
<p>getrefcount()返回的结果分别是2,3，而不是1,2或者2,2</p>
</li>
<li><p>对象引用对象<br>python的一个容器对象（container），比如列表字典等，可以包含多个对象。实际上，容器对象中包含的并不是对象本身，而是指向各个元素对象的引用。</p>
<pre><code class="py">class from_obj(object):
 def __init__(self, to_obj):
     self.to_obj = to_obj
b = [1,2,3]
a = from_obj(b)
print(id(a.to_obj))
print(id(b))
# 140035473779144
# 140035473779144</code></pre>
<p>可以看到a引用了对象b。<br>对象引用对象是python最基本的构成方式。即使是a = 1这一赋值方式，实际上是让词典的一个键值“a”的元素引用整数对象1。该词典对象用于记录所有的全局引用。该词典引用了整数对象1。我们可以通过内置函数globals()来查看该词典。<br>当一个对象a被另一个对象b引用时，a的引用计数将增加1。</p>
<pre><code class="py">from sys import getrefcount
a = [1, 2, 3]
print(getrefcount(a))
b = [a, a]
print(getrefcount(a))
# 2
# 4</code></pre>
<p>容器对象引用可能构成很复杂的拓扑结构。我们可以用objgraph包来绘制其引用关系。<br><a href="https://mg.pov.lt/objgraph/" target="_blank" rel="noopener">objgraph</a>是python的一个第三方包。<br><code>pip install objgraph</code> 使用objgraph需要安装xdot。根据自己的系统发行版本安装。<br><code>sudo pacman -S xdot</code> 或者 <code>sudo apt install xdot</code>, <code>sudo yun install xdot</code></p>
<pre><code class="py">x = [1, 2, 3]
y = [x, dict(key1=x)]
z = [y, (x, y)]
</code></pre>
</li>
</ol>
<p>import objgraph<br>objgraph.show_refs([z], filename=’ref_topo.png’)</p>
<pre><code>![引用环.png](https://i.loli.net/2019/11/15/R5WLcdbVGZTQESo.png &#39;引用环&#39;)
两个对象可能互相引用，从而构成所谓的引用环（reference cycle）
``` py
&gt;&gt;&gt; a = []
&gt;&gt;&gt; b = [a]
&gt;&gt;&gt; a.append(b)
&gt;&gt;&gt; a
[[[...]]]</code></pre><p>即使是一个对象，只需要自己引用自己，也能构成引用环。</p>
<pre><code class="py">&gt;&gt;&gt; a = []
&gt;&gt;&gt; a.append(a)
&gt;&gt;&gt; print(getrefcount(a))
3</code></pre>
<p>引用环会给垃圾回收机制带来很大的麻烦，后面详细说明。</p>
<ol start="3">
<li><p>引用减少<br>某个引用对象的引用计数可能减少。比如使用del关键字删除某个引用</p>
<pre><code class="py">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; b = a
&gt;&gt;&gt; print(getrefcount(b))
3
&gt;&gt;&gt; del a
&gt;&gt;&gt; print(getrefcount(b))
2</code></pre>
<p>del也可以删除容器中的元素，比如：</p>
<pre><code class="py">&gt;&gt;&gt; a = [1,2,3]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; print(a)
[2, 3]
&gt;&gt;&gt; b = {&quot;q&quot;: 1, &quot;w&quot;:2}
&gt;&gt;&gt; b
{&#39;q&#39;: 1, &#39;w&#39;: 2}
&gt;&gt;&gt; del b[&quot;q&quot;]
&gt;&gt;&gt; b
{&#39;w&#39;: 2}</code></pre>
<p>如果某个引用指向对象a，当这个引用被重新定向到其他对象b的时候，对象a的引用计数会减少</p>
<pre><code class="py">&gt;&gt;&gt; from sys import getrefcount
... 
... a = [1, 2, 3]
... b = a
... print(getrefcount(b))
... 
... a = 1
... print(getrefcount(b))
3
2</code></pre>
</li>
<li><p>垃圾回收<br>当python中的对象越来越多，他占据的内存也会越来越大。不过不需要担心太多，python会在适当的时候启动垃圾 <code>回收机制(garbage collection)</code>，将没用的对象清除，在许多语言中都有垃圾回收机制，比如Java和Ruby。<br>从基本原理来说，当一个对象的引用计数降为0的时候，说明没有任何引用指向对象，这时候该对象就成为需要被清除的垃圾了。比如某个新建对象，分配给某个引用，引用数为1,当引用被删除之后，引用数为0，那么该对象就可以被垃圾回收。</p>
<pre><code class="py">a = [1,2,3]
del a</code></pre>
<p><code>del a</code> 之后已经没有任何引用指向[1,2,3]了，用户不可能通过任何方式接触或者动用这个对象，这个对象如果继续待在内存里，就成了不健康的数据。当python的<strong>垃圾回收</strong>机制启动的时候，python扫描到这个引用为0的对象，就会将它所占据的内存清空。<br>然而清理过程是个费力的过程。垃圾回收的时候，python不能进行其他的任务，频繁的垃圾回收，会大大降低python的工作效率。如果内存中的对象不多，就没必要总启动垃圾回收。所以python只会在特定的条件下，<strong>自动启动垃圾回收</strong>。当python运行的时候，会记录其中分配对象和取消分配对象的次数，两者的差值高于某个阈值的时候，垃圾回收才会启动。<br>我们可以通过gc模块的 <code>get_threshold()</code> 来查看该阈值。</p>
<pre><code class="py">&gt;&gt;&gt; import gc
&gt;&gt;&gt; gc.get_threshold()
(700, 10, 10)</code></pre>
<p>返回值中，后面的两个10,是与分代回收相关的阈值，分代回收在后面会讲到。700既是垃圾回收的启动阈值。可以通过gc中的 <code>set_threshold()</code> 来重新设定。<br>也可以手动使用 <code>gc.collect()</code> 启动垃圾回收机制</p>
</li>
<li><p>分代回收<br>python同时使用了分代（generation）回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有长期存在被使用的对象，出于信任和效率，对于这样一些对象，我们相信他的用处，所以减少在垃圾回收中扫描他们的频率。<br>python将所有的对象分为0,1,2三代，所有新建的对象都是0代对象，当某一代对象经历过垃圾回收之后，依然存活，那就归入到下一代中，垃圾回收启动时，一定会扫描所有的0代对象。如果0代对象经历过一定次数的垃圾回收，那么就启动对0待和1代的扫描清理，当1代也经历了一定数量的垃圾回收，那就启动对0,1,2，即所有的对象进行扫描。<br>上面 <code>gc.get_threshold()</code> 返回的（700,10,10）中后面的两个数，意义就是，每经过10次对0代的垃圾回收，就会配合启动一次对1代的扫描，没经过10次对1代的扫描，才会启动一次对2代的垃圾回收。<br>同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。</p>
<pre><code class="py">import gc
gc.set_threshold(700, 10, 5)</code></pre>
</li>
<li><p>孤立的引用环<br>引用环的存在会给垃圾回收带来很大的困难，这些引用环可能构成无法使用，但是引用计数不为0的一些对象。</p>
<pre><code class="py">a = []
b = [a]
a.append(b)
del a
del b</code></pre>
<p>上面我们先创建了两个表对象，并引用对方，构成一个引用环。删除了a，b引用之后，这两个对象不可能再从程序中调用，就没有什么用处了。但是由于引用环的存在，这两个对象的引用计数都没有降到0，不会被垃圾回收。<br><img src="https://i.loli.net/2019/11/15/9YMgpwvVoNEJKcS.png" alt="孤立的引用环.png" title="孤立的引用环"><br>为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。<br><img src="https://i.loli.net/2019/11/15/cz6oACOWBdjis2P.png" alt="遍历结果.png" title="遍历结果"><br>在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。</p>
</li>
</ol>
<p><strong><em>总结</em></strong><br>python作为一种动态类型的语言，其对象和引用分离，这与面向过程的编程语言有很大的区别。为了有效的释放内存，python内置了垃圾回收的支持。python采用了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。</p>
<h2 id="什么是lambda函数？它有什么好处？"><a href="#什么是lambda函数？它有什么好处？" class="headerlink" title="什么是lambda函数？它有什么好处？"></a><a href="#什么是lambda函数？它有什么好处？">什么是lambda函数？它有什么好处？</a></h2><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指<strong>匿名函数</strong>。<br>匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算。这是什么意思呢？类比 <code>a = [1, 2, 3]</code> 和 <code>f = lambda x : x + 1</code> ，等号左边的名字只是右边之实体的标识符。<br>lambda函数可以接受任意个参数，包括可选参数，但是表达式只有一个。</p>
<h2 id="python自省"><a href="#python自省" class="headerlink" title="python自省"></a><a name="#python自省">python自省</a></h2><p>python自省 — 在运行时能够获得对象的类型</p>
<p><strong>type()</strong>，判断对象类型</p>
<pre><code class="py">In [27]: type(123)
Out[27]: int

In [28]: type(&#39;123&#39;)
Out[28]: str

In [29]: type(None)
Out[29]: NoneType</code></pre>
<p><strong>dir()</strong>， 带参数时获得该对象的所有属性和方法；不带参数时，返回当前范围内的变量、方法和定义的类型列表</p>
<pre><code class="py">&gt;&gt;&gt; dir()
[&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]</code></pre>
<p>以及</p>
<pre><code class="py">dir(&#39;ABC&#39;)
[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;]</code></pre>
<p>len()函数返回字符长度</p>
<pre><code class="py">&gt;&gt;&gt; len(&#39;ABC&#39;)
3</code></pre>
<p>在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法</p>
<pre><code class="py">&gt;&gt;&gt; &#39;ABC&#39;.__len__()
3</code></pre>
<p>–&gt;</p>
<pre><code class="py">In [34]: class Mydog(object):
    ...:     def __len__(self):
    ...:         return 100
    ...:

In [35]: mydog = Mydog()

In [36]: len(mydog)
Out[36]: 100</code></pre>
<p><strong>isinstance()</strong>，判断对象是否是已知类型</p>
<pre><code class="py">In [37]: a = [1, 2, 3]

In [38]: isinstance(a, list)
Out[38]: True</code></pre>
<p><strong>getattr()</strong>、<strong>hasattr()</strong>、<strong>setattr()</strong>获取对象的状态</p>
<pre><code class="py">In [1]: class Myobject(object):
   ...:     def __init__(self):
   ...:         self.x = 9
   ...:     def power(self):
   ...:         return self.x * self.x
   ...:

In [2]: obj = Myobject()

In [3]: obj.power()
Out[3]: 81

In [4]: hasattr(obj, &#39;x&#39;) # 有属性x么？
Out[4]: True

In [5]: hasattr(obj, &#39;y&#39;) # 有属性y么？
Out[5]: False

In [6]: setattr(obj, &#39;y&#39;) # 设置属性必须有三个参数，少了值
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-6-3b0a0f22117d&gt; in &lt;module&gt;()
----&gt; 1 setattr(obj, &#39;y&#39;)

TypeError: setattr expected 3 arguments, got 2

In [7]: setattr(obj, &#39;y&#39;, 100) # 设置属性y的值为100

In [8]: hasattr(obj, &#39;y&#39;) # 有属性y么？
Out[8]: True

In [9]: getattr(obj, &#39;y&#39;) # 获取属性y！
Out[9]: 100

In [10]: obj.y # 获取属性y
Out[10]: 100

In [11]: obj.x # 获取属性x
Out[11]: 9</code></pre>
<p>获取不存在的属性，会抛出AttributeError</p>
<pre><code class="py">In [12]: getattr(obj, &#39;z&#39;)
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-12-95c3c0ec4e01&gt; in &lt;module&gt;()
----&gt; 1 getattr(obj, &#39;z&#39;)

AttributeError: &#39;Myobject&#39; object has no attribute &#39;z&#39;</code></pre>
<p>可以传入一个默认参数，不存在就抛出默认参数</p>
<pre><code class="py">In [13]: getattr(obj, &#39;z&#39;, 404)
Out[13]: 404</code></pre>
<h2 id="谈一谈python的装饰器"><a href="#谈一谈python的装饰器" class="headerlink" title="谈一谈python的装饰器"></a><a name="#谈一谈python的装饰器">谈一谈python的装饰器</a></h2><p><a href="https://luyuonism.github.io/2018/06/05/decorator/">python的装饰器</a></p>
<h2 id="python元类"><a href="#python元类" class="headerlink" title="python元类"></a><a name="#python元类">python元类</a></h2><p><a href="https://www.cnblogs.com/vipchenwei/p/7239953.html" target="_blank" rel="noopener">python元类</a></p>
<h2 id="列举Http请求中常见的请求方式"><a href="#列举Http请求中常见的请求方式" class="headerlink" title="列举Http请求中常见的请求方式"></a><a name="#列举Http请求中常见的请求方式">列举Http请求中常见的请求方式</a></h2><p><strong>GET</strong><br>向特定的路径资源发出请求</p>
<p><strong>POST</strong><br>向指定路径资源提交数据进行处理请求（一般用于提交表单或者上传文件）</p>
<p><strong>OPTIONS</strong><br>返回服务器针对特定资源所支持的HTTP请求方法<br>允许客户端查看服务器的性能，也可以利用向web服务器发送’*‘的请求来测试服务器的功能性</p>
<p><strong>HEAD</strong><br>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回<br>这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p>
<p><strong>PUT</strong><br>从客户端向服务器传送的数据取代指定的文档的内容</p>
<p><strong>DELETE</strong><br>请求服务器删除指定的页面</p>
<p><strong>TRACE</strong><br>回显服务器收到的请求，主要用于测试或诊断</p>
<p><strong>CONNECT</strong><br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务</p>
<h2 id="谈谈你对HTTP协议的认识"><a href="#谈谈你对HTTP协议的认识" class="headerlink" title="谈谈你对HTTP协议的认识"></a><a name="#谈谈你对HTTP协议的认识">谈谈你对HTTP协议的认识</a></h2><p>HTTP是一个属于应用层的面向对象的协议<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<ul>
<li><strong>基于TCP/IP</strong><br><a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE/212915?fromtitle=tcp%2Fip&fromid=214077&fr=aladdin" target="_blank" rel="noopener">TCP/IP</a>是指能够在多个不同网络间实现信息传输的协议簇,http协议是基于TCP/IP协议之上的应用层协议。</li>
<li><strong>基于请求－响应模式</strong><br>HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并返回</li>
<li><strong>无状态保存</strong><br>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。<br>使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了。</li>
</ul>
<h2 id="简述MVC模式和MVT模式"><a href="#简述MVC模式和MVT模式" class="headerlink" title="简述MVC模式和MVT模式"></a><a name="#简述MVC模式和MVT模式">简述MVC模式和MVT模式</a></h2><p>所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层,他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求<br><img src="https://i.loli.net/2019/11/15/3paj7P1gr9A4UcI.png" alt="MVC.png" title="MVC"></p>
<p>MTV<br>    Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是值：<br>M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。<br>T 代表模板 (Template)：负责如何把页面展示给用户(html)。<br>V 代表视图（View）： 负责业务逻辑，并在适当时候调用Model和Template。<br>除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：<br><img src="https://i.loli.net/2019/11/15/dvtKYM4f5Ix3S1G.png" alt="MTV.png" title="MTV"><br>一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p>
<h2 id="简述Django请求生命周期"><a href="#简述Django请求生命周期" class="headerlink" title="简述Django请求生命周期"></a><a name="#简述Django请求生命周期">简述Django请求生命周期</a></h2><p>一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p>
<ol>
<li>wsgi,请求封装后交给web框架 （Flask、Django）     </li>
<li>中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session - </li>
<li>路由匹配根据浏览器发送的不同url去匹配不同的视图函数    </li>
<li>视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染 - </li>
<li>中间件，对响应的数据进行处理。 </li>
<li>wsgi,将响应的内容发送给浏览器。<br><img src="https://i.loli.net/2019/11/15/xEajlm7CFnN1HJi.png" alt="django生命周期.png" title="django生命周期"></li>
</ol>
<h2 id="django中间件生命周期"><a href="#django中间件生命周期" class="headerlink" title="django中间件生命周期"></a><a name="#django中间件生命周期">django中间件生命周期</a></h2><p>请求过来：<br>中间件：拦截一部分请求；比如验证session, 没有登录的 请求一些页面，跳转至登录页；(图片为中间件的请求过程)再到 urls ，分发请求到views 视图 ，通过 CBV(dispatch反射) 和 FBV 的 get 请求 讲 template 页面渲染返回给用户；渲染之前 可以从数据库拿出数据，放到render 的参数里面传递过去， locals() 表示 把所有参数传递还可以 实例化 其他 form 类，并渲染给前端<br><img src="https://i.loli.net/2019/11/15/epZqE4oX2zWrQwl.png" alt="django.png" title="django"></p>
<h2 id="简述什么是FBV和CBV"><a href="#简述什么是FBV和CBV" class="headerlink" title="简述什么是FBV和CBV"></a><a name="#简述什么是FBV和CBV">简述什么是FBV和CBV</a></h2><p>django中请求处理方式有2种:<br>FBV（function base views）就是在视图里面使用函数处理请求<br>CBV（class base views）就是在视图里面使用类处理请求</p>
<h2 id="对ORM的理解"><a href="#对ORM的理解" class="headerlink" title="对ORM的理解"></a><a href="#对ORM的理解">对ORM的理解</a></h2><p>ORM是“对象-关系-映射”的简称。<br>MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动</p>
<h2 id="常用视图响应的方式"><a href="#常用视图响应的方式" class="headerlink" title="常用视图响应的方式"></a><a name="#常用视图响应的方式">常用视图响应的方式</a></h2><p><strong>视图的响应返回使用HttpResponse</strong><br>HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)<br>一般不用这种方式，我习惯使用：<br> response = HttpResponse(‘language python’)<br> response.status_code = 400<br> response[‘languaget’] = ‘Python’<br> return response<br><strong>返回json数据，可以使用JsonResponse来构造响应对象</strong><br>帮助我们将数据转换为json字符串<br>设置响应头Content-Type为 application/json<br>例子：from django.http import JsonResponse<br>           def demo_view(request):<br>               return JsonResponse({‘city’: ‘beijing’, ‘subject’: ‘python’})<br><strong>redirect重定向</strong><br>我们也可以将返回的结果重定向到另一个页面或接口，<br>例子：from django.shortcuts import redirect<br>           def demo_view(request):<br>               return redirect(‘/index.html’)</p>
<h2 id="django中间件的5个方法"><a href="#django中间件的5个方法" class="headerlink" title="django中间件的5个方法"></a><a name="#django中间件的5个方法">django中间件的5个方法</a></h2><p>1.process_request : 请求进来时,权限认证<br>2.process_view : 路由匹配之后,能够得到视图函数<br>3.process_exception : 异常时执行<br>4.process_template_responseprocess : 模板渲染时执行<br>5.process_response : 请求有响应时执行</p>
<h2 id="django中csrf的实现机制"><a href="#django中csrf的实现机制" class="headerlink" title="django中csrf的实现机制"></a><a name="#django中csrf的实现机制">django中csrf的实现机制</a></h2><p>第一步：django第一次响应来自某个客户端的请求时,后端随机产生一个token值，把这个token保存在SESSION状态中;同时,后端把这个token放到cookie中交给前端页面<br>第二步：下次前端需要发起请求（比如发帖）的时候把这个token值加入到请求数据或者头信息中,一起传给后端；Cookies:{csrftoken:xxxxx}<br>第三步：后端校验前端请求带过来的token和SESSION里的token是否一致</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a><a name="#cookie和session的区别">cookie和session的区别</a></h2><ul>
<li>cookie 数据存放在客户端，session 数据放在服务器端。</li>
<li>cookie 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用session。</li>
<li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 cookie 。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>将登陆信息等重要信息存放为 session、其他信息如果需要保留，可以放在cookie中</li>
</ul>
<h2 id="django-orm-中所有的方法"><a href="#django-orm-中所有的方法" class="headerlink" title="django orm 中所有的方法"></a><a name="#django orm 中所有的方法">django orm 中所有的方法</a></h2><p>all()<br>filter(**kwargs)<br>get(**kwargs)<br>update()<br>delete()<br>create()<br>exclude(**kwargs): 它包含了与所给筛选条件不匹配的对象<br>order_by(*field): 对查询结果排序<br>reverse(): 对查询结果反向排序<br>count(): 返回数据库中匹配查询(QuerySet)的对象数量。<br>first(): 返回第一条记录<br>last(): 返回最后一条记录<br>exists(): 如果QuerySet包含数据，就返回True，否则返回False<br>values(*field): 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系 model的实例化对象，而是一个可迭代的字典序列 values_list(*field): 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列<br>distinct(): 从返回结果中剔除重复纪录<br>F(): 操作数据表中的某列值</p>
<pre><code class="py">from django.db.models import F
from app01.models import Book
Book.objects.update(price=F(&quot;price&quot;)+20)  # 对于book表中每本书的价格都在原价</code></pre>
<p>没有F查询，你首先要获取原价格，再做一个算术运算，然后更新字段。F查询专门对对象中某列值的操作，不可使用__双下划线！<br>Q(): 对对象进行复杂查询，并支持 &amp;（and）, | （or）, ~（not）操作符<br>Q查询可以组合使用 “&amp;”, “|” 操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象，Q对象可以用 “~“ 操作符放在前面表示否定，也可允许否定与不否定形式的组合。Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。</p>
<p>1.orm的开发速度快,操作简单。使开发更加对象化,执行速度慢。处理多表联查等复杂操作时,ORM的语法会变得复杂<br>2.sql开发速度慢,执行速度快。性能强</p>

  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>本文作者：</strong>ruijielu<br>
<strong>本文链接：</strong><a href="https://luyuonism.github.io/2018/03/05/pythonexercise/" title="https:&#x2F;&#x2F;luyuonism.github.io&#x2F;2018&#x2F;03&#x2F;05&#x2F;pythonexercise&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;luyuonism.github.io&#x2F;2018&#x2F;03&#x2F;05&#x2F;pythonexercise&#x2F;</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '6697f1e2bc68a9625fed',
        clientSecret: '173e837a4a0788e2d0c2ecfe68911cd3a3efc2d1',
        id: window.location.pathname,
        repo: 'https://luyuonism.github.io',
        owner: 'luyuonism',
        admin: 'luyuonism'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1574162503080"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>

  





</body>

</html>
